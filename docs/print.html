<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The bspwm-wiki</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon-de23e50b.svg">
        <link rel="shortcut icon" href="favicon-8114d1fc.png">
        <link rel="stylesheet" href="css/variables-8adf115d.css">
        <link rel="stylesheet" href="css/general-2459343d.css">
        <link rel="stylesheet" href="css/chrome-ae938929.css">
        <link rel="stylesheet" href="css/print-9e4910d8.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="fonts/fonts-9644e21d.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="mdbook-highlight-css" href="highlight-493f70e1.css">
        <link rel="stylesheet" id="mdbook-tomorrow-night-css" href="tomorrow-night-4c0ae647.css">
        <link rel="stylesheet" id="mdbook-ayu-highlight-css" href="ayu-highlight-3fdfc3ac.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="./assets/css/admonish.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex-fd703830.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc-a26a57cb.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="mdbook-body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="mdbook-sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("mdbook-sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="mdbook-sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="mdbook-sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="mdbook-page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="mdbook-menu-bar-hover-placeholder"></div>
                <div id="mdbook-menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="mdbook-sidebar-toggle" class="icon-button" for="mdbook-sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="mdbook-sidebar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M0 96C0 78.3 14.3 64 32 64H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H416c17.7 0 32 14.3 32 32z"/></svg></span>
                        </label>
                        <button id="mdbook-theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="mdbook-theme-list">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M371.3 367.1c27.3-3.9 51.9-19.4 67.2-42.9L600.2 74.1c12.6-19.5 9.4-45.3-7.6-61.2S549.7-4.4 531.1 9.6L294.4 187.2c-24 18-38.2 46.1-38.4 76.1L371.3 367.1zm-19.6 25.4l-116-104.4C175.9 290.3 128 339.6 128 400c0 3.9 .2 7.8 .6 11.6c1.8 17.5-10.2 36.4-27.8 36.4H96c-17.7 0-32 14.3-32 32s14.3 32 32 32H240c61.9 0 112-50.1 112-112c0-2.5-.1-5-.2-7.5z"/></svg></span>
                        </button>
                        <ul id="mdbook-theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-ayu">Ayu</button></li>
                        </ul>
                        <button id="mdbook-search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="mdbook-searchbar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9 0 208S93.1 0 208 0S416 93.1 416 208zM208 352c79.5 0 144-64.5 144-144s-64.5-144-144-144S64 128.5 64 208s64.5 144 144 144z"/></svg></span>
                        </button>
                    </div>

                    <h1 class="menu-title">The bspwm-wiki</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <span class=fa-svg id="print-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M128 0C92.7 0 64 28.7 64 64v96h64V64H354.7L384 93.3V160h64V93.3c0-17-6.7-33.3-18.7-45.3L400 18.7C388 6.7 371.7 0 354.7 0H128zM384 352v32 64H128V384 368 352H384zm64 32h32c17.7 0 32-14.3 32-32V256c0-35.3-28.7-64-64-64H64c-35.3 0-64 28.7-64 64v96c0 17.7 14.3 32 32 32H64v64c0 35.3 28.7 64 64 64H384c35.3 0 64-28.7 64-64V384zm-16-88c-13.3 0-24-10.7-24-24s10.7-24 24-24s24 10.7 24 24s-10.7 24-24 24z"/></svg></span>
                        </a>

                    </div>
                </div>

                <div id="mdbook-search-wrapper" class="hidden">
                    <form id="mdbook-searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="mdbook-searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="mdbook-searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <span class=fa-svg id="fa-spin"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M304 48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zm0 416c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM48 304c26.5 0 48-21.5 48-48s-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48zm464-48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM142.9 437c18.7-18.7 18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zm0-294.2c18.7-18.7 18.7-49.1 0-67.9S93.7 56.2 75 75s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zM369.1 437c18.7 18.7 49.1 18.7 67.9 0s18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9z"/></svg></span>
                            </div>
                        </div>
                    </form>
                    <div id="mdbook-searchresults-outer" class="searchresults-outer hidden">
                        <div id="mdbook-searchresults-header" class="searchresults-header"></div>
                        <ul id="mdbook-searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('mdbook-sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('mdbook-sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#mdbook-sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="mdbook-content" class="content">
                    <main>
                        <h1 id="introduction-to-wiki"><a href="#introduction-to-wiki" class="header">Introduction to wiki</a></h1>
<h2 id="what-is-bspwm-wiki"><a class="header" href="#what-is-bspwm-wiki">What is bspwm-wiki?</a></h2>
<p>It is a comprehensive and complete documentation for the Binary Space Partitioning Window Manager (BSPWM).</p>
<p>Bspwm is a tiling window manager which uses binary space partition system. (C students must have known what it means). Unlike other dynamic window managers like dwm and awesomewm, bspwm is what you configure and use. It is possible to do anything with correct integration of configs : bspwm + sxhkd + eww or polybar, you will get a perfectly aligned environment that obeys your thoughts. I named this documentation as bspwm-wiki because it is short and aligns with documentation policy of my interest.</p>
<blockquote class="blockquote-tag blockquote-tag-tip">
<p class="blockquote-tag-title"><svg viewbox="0 0 16 16" width="18" height="18"><path d="M8 1.5c-2.363 0-4 1.69-4 3.75 0 .984.424 1.625.984 2.304l.214.253c.223.264.47.556.673.848.284.411.537.896.621 1.49a.75.75 0 0 1-1.484.211c-.04-.282-.163-.547-.37-.847a8.456 8.456 0 0 0-.542-.68c-.084-.1-.173-.205-.268-.32C3.201 7.75 2.5 6.766 2.5 5.25 2.5 2.31 4.863 0 8 0s5.5 2.31 5.5 5.25c0 1.516-.701 2.5-1.328 3.259-.095.115-.184.22-.268.319-.207.245-.383.453-.541.681-.208.3-.33.565-.37.847a.751.751 0 0 1-1.485-.212c.084-.593.337-1.078.621-1.489.203-.292.45-.584.673-.848.075-.088.147-.173.213-.253.561-.679.985-1.32.985-2.304 0-2.06-1.637-3.75-4-3.75ZM5.75 12h4.5a.75.75 0 0 1 0 1.5h-4.5a.75.75 0 0 1 0-1.5ZM6 15.25a.75.75 0 0 1 .75-.75h2.5a.75.75 0 0 1 0 1.5h-2.5a.75.75 0 0 1-.75-.75Z"></path></svg>Tip</p>
<p>If you do not know what exactly is binary space partitioning, don’t worry, the documentation will teach you.</p>
</blockquote>
<h2 id="what-exactly-is-the-purpose-of-the-bspwm-wiki"><a class="header" href="#what-exactly-is-the-purpose-of-the-bspwm-wiki">What exactly is the purpose of The bspwm-wiki?</a></h2>
<p>There has not been a very good documentation about the bspwm window manager in the web. Many beginners in linux stumble upon understanding the workflow and the exact process behind bspwm and struggle by copying someone else’s configuration blindly hoping that it works on their system too. Real power users do not copy, they build upon an already existing config or build something entirely from the scratch.</p>
<p>Linux punishes weak fundamentals, not because it is cruel towards you, but because it wants to make you stronger. Understanding about The Binary Space Partitioning Window Manager and Binary Space Partitioning before writing your first bspwm configuration will make you write optimised and good configs better than your copycat versions.</p>
<p>Most of the configurations are using bspwm in an underrated way. For example, people rerely use the <code>query selectors with flags</code> to batch-manipulate windows. Here’s an on-liner that toggles hidden states across all windows…</p>
<pre><code class="language-bash">if [ -n "$(bspc query -N -n .hidden)" ]; then flag=off; else flag=on; fi
for i in $(bspc query -N); do 
    bspc node $i --flag hidden=$flag
done

</code></pre>
<p>The above code matters because it unhides or hides all windows dynamically, no tiling rules or scratchpads, reproducible, scriptable UI hacks…</p>
<p>Another powerful feature is the <code>selector magic : @</code>, which looks like : <code>bspc node -f @parent</code>, which lets you targe relative nodes - parent, first child, brother, etc…</p>
<p>This documentation aims in providing short scripts, cool tips for speeding up workflows, links to several popular bspwm configurations for quick references, a detailed explanation for the working logic behind bspwm, complete manipulation of the windows, advanced configurations and complex logic structures like : <strong>Open alacritty in the second workspace on every sunday nights in horizontally tiled mode along with ncmpcpp in a seperate alacritty window with so and so split ratio</strong>, when you have the habit of listening to music on sunday nights while working!</p>
<p>Everything you want to know about the bspwm window manager, you will get it here…</p>
<h2 id="help-people-discover-bspwm-wiki"><a class="header" href="#help-people-discover-bspwm-wiki">Help People Discover bspwm-wiki</a></h2>
<ol>
<li>
<p>Help others find about such an extensive documentation for bspwm by <a href="#how-to-contribute-to-bspwm-wiki">contributing</a> to this project. You can open up pull requests, do corrections and error analysis for the code blocks in this documentation and expand it by adding specific case examples and linking other bspwm related projects.</p>
</li>
<li>
<p>If you find this documentation really useful to you, you can star this <a href="https://github.com/rdbhvr-001/bspwm-wiki.git">repository</a> which will increase the ease with which this documentation is found and make it easier for people to reach out to this.</p>
</li>
</ol>
<blockquote class="blockquote-tag blockquote-tag-note">
<p class="blockquote-tag-title"><svg viewbox="0 0 16 16" width="18" height="18"><path d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z"></path></svg>Note</p>
<p>If you have any issues related to codes provided in this documentation, you can open up an issue in the github repository.</p>
</blockquote>
<h2 id="github-repositories"><a class="header" href="#github-repositories">Github repositories</a></h2>
<ol>
<li><a href="https://github.com/baskerville/bspwm.git">Official BSPWM Binary : baskerville/bspwm</a></li>
<li><a href="https://github.com/rdbhvr-001/bspwm-wiki.git">Official Documentation Repository : rdbhvr-001/bspwm-wiki</a></li>
</ol>
<h2 id="pages"><a class="header" href="#pages">Pages</a></h2>
<ol>
<li><a href="https://rdbhvr-001.github.io/bspwm-wiki">Documentation : This Page</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="how-to-master-bspwm"><a href="#how-to-master-bspwm" class="header">How to master bspwm</a></h1>
<h3 id="how-to-master-the-bspwm"><a class="header" href="#how-to-master-the-bspwm">How to master the bspwm?</a></h3>
<p>To master <strong>bspwm</strong> (Binary Space Partitioning Window Manager), you must move beyond simple configuration and understand it as a programmable environment. Because <code>bspwm</code> is merely a C program controlled by a socket client (<code>bspc</code>), mastery is equivalent to mastering the <code>bspc</code> command and the logic of binary trees.</p>
<p>Here is the exhaustive curriculum for total bspwm mastery, structured from architectural concepts to advanced kernel-level scripting.</p>
<h3 id="the-theoretical-foundation"><a class="header" href="#the-theoretical-foundation">The Theoretical Foundation</a></h3>
<blockquote class="blockquote-tag blockquote-tag-important">
<p class="blockquote-tag-title"><svg viewbox="0 0 16 16" width="18" height="18"><path d="M0 1.75C0 .784.784 0 1.75 0h12.5C15.216 0 16 .784 16 1.75v9.5A1.75 1.75 0 0 1 14.25 13H8.06l-2.573 2.573A1.458 1.458 0 0 1 3 14.543V13H1.75A1.75 1.75 0 0 1 0 11.25Zm1.75-.25a.25.25 0 0 0-.25.25v9.5c0 .138.112.25.25.25h2a.75.75 0 0 1 .75.75v2.19l2.72-2.72a.749.749 0 0 1 .53-.22h6.5a.25.25 0 0 0 .25-.25v-9.5a.25.25 0 0 0-.25-.25Zm7 2.25v2.5a.75.75 0 0 1-1.5 0v-2.5a.75.75 0 0 1 1.5 0ZM9 9a1 1 0 1 1-2 0 1 1 0 0 1 2 0Z"></path></svg>Important</p>
<p>You cannot predict window behavior without understanding the data structure.</p>
</blockquote>
<ol>
<li><strong>The Full Binary Tree</strong>: Understand how every desktop is a root node that splits recursively.</li>
<li><strong>Internal Nodes vs. Leaves</strong>:
<ul>
<li><em>Leaves</em> hold windows (<code>client</code>).</li>
<li><em>Internal Nodes</em> hold structure (Split type: Horizontal/Vertical + Split Ratio).</li>
</ul>
</li>
<li><strong>Traversal Paths</strong>: Understanding how <code>next</code>/<code>prev</code> cycles through the tree (pre-order, in-order, post-order traversal logic).</li>
<li><strong>Tree Rotation</strong>: How “circulate” commands (<code>bspc node -C</code>) physically rotate the tree structure.</li>
</ol>
<h3 id="the-control-interface"><a class="header" href="#the-control-interface">The Control Interface</a></h3>
<p>Mastering every subcommand of the binary space partitioning controller.</p>
<ol>
<li><strong>Node Selection (The Query Language)</strong>:
<ul>
<li><strong>Directional</strong>: <code>north</code>, <code>south</code>, <code>east</code>, <code>west</code>.</li>
<li><strong>History</strong>: <code>last</code>, <code>older</code>, <code>newer</code>.</li>
<li><strong>Family</strong>: <code>parent</code>, <code>brother</code>, <code>ancestor</code>, <code>descendant</code>.</li>
<li><strong>Path Notations</strong>: <code>@/</code> (root), <code>@/1</code> (left child), <code>@/2</code> (right child).</li>
<li><strong>Modifiers</strong>: <code>.floating</code>, <code>.tiled</code>, <code>.pseudo_tiled</code>, <code>.locked</code>, <code>.sticky</code>, <code>.private</code>, <code>.hidden</code>.</li>
</ul>
</li>
<li><strong>Node Manipulation</strong>:
<ul>
<li><strong>Movement</strong>: Moving nodes within a desktop, across desktops, or across monitors (<code>bspc node -m</code>, <code>-d</code>, <code>-n</code>).</li>
<li><strong>Resizing</strong>: Differential resizing (<code>-z top -20 0</code>) vs. Ratio resizing.</li>
<li><strong>Swapping</strong>: Exchanging the position of two nodes (<code>bspc node -s</code>).</li>
<li><strong>Flags</strong>: Toggling <code>hidden</code> (minimized), <code>sticky</code> (global), <code>private</code> (ignored by automatic splitting), <code>locked</code> (immune to closing).</li>
</ul>
</li>
<li><strong>Preselection (<code>-p</code>)</strong>:
<ul>
<li>Manually defining the <em>split direction</em> and <em>ratio</em> for the <em>next</em> window.</li>
<li>Visualizing preselection feedback colors.</li>
<li>Canceling preselection (<code>bspc node -p cancel</code>).</li>
</ul>
</li>
<li><strong>Receptacles (<code>-i</code>)</strong>:
<ul>
<li>Inserting empty nodes (leaves without windows) to reserve layout space.</li>
<li>Dumping windows into receptacles.</li>
</ul>
</li>
</ol>
<h3 id="the-input-daemon"><a class="header" href="#the-input-daemon">The Input Daemon</a></h3>
<p><code>bspwm</code> handles zero keyboard input. You must master <code>sxhkd</code> to drive it.</p>
<ul>
<li><strong>Chord Chains</strong>: Binding sequences (<code>super + a ; b</code>).</li>
<li><strong>Brace Expansion</strong>: Creating compact matrices of commands (<code>super + {h,j,k,l}</code> mapped to <code>{west,south,north,east}</code>).</li>
<li><strong>Command Replay</strong>: Using <code>@</code> to run commands on key release vs. press.</li>
<li><strong>Sync vs. Async</strong>: Understanding when a command blocks <code>sxhkd</code> and when it doesn’t.</li>
<li><strong>Mode Simulation</strong>: Creating “modal” editing (like Vim) using chord chains or dynamic config reloading.</li>
</ul>
<h3 id="logic--automation"><a class="header" href="#logic--automation">Logic &amp; Automation</a></h3>
<ol>
<li><strong>Standard Rules (<code>bspc rule</code>)</strong>:
<ul>
<li>Static assignment: <code>bspc rule -a Firefox desktop='^2' follow=on</code>.</li>
<li>One-shot rules (<code>-o</code>): Rules that apply only to the very next window spawned.</li>
</ul>
</li>
<li><strong>External Rules Command</strong>:
<ul>
<li>Writing shell scripts that intercept <code>Window ID</code>, <code>Class</code>, and <code>Instance</code> before the window is mapped.</li>
<li>Implementing complex logic (e.g., “If GIMP opens and I am on Monitor 1, float it; if Monitor 2, tile it”).</li>
</ul>
</li>
<li><strong>Event Subscription (<code>bspc subscribe</code>)</strong>:
<ul>
<li>Listening to the event stream: <code>node_add</code>, <code>node_remove</code>, <code>desktop_focus</code>, <code>monitor_add</code>.</li>
<li>Building daemon scripts that react to changes (e.g., “When I switch to Desktop 5, automatically change the wallpaper”).</li>
</ul>
</li>
<li><strong>State Dumping (<code>bspc query -T</code>)</strong>:
<ul>
<li>Reading the JSON state of the entire window manager.</li>
<li>Writing scripts to save/load layouts (parsing JSON to reconstruct trees using receptacles).</li>
</ul>
</li>
</ol>
<h3 id="layout-management"><a class="header" href="#layout-management">Layout Management</a></h3>
<ol>
<li><strong>Automatic Schemes</strong>:
<ul>
<li><code>spiral</code>: Windows split the largest node, spiraling inward.</li>
<li><code>longest_side</code>: Windows always split the longest edge (standard tiling).</li>
<li><code>alternate</code>: Windows alternate H/V splits.</li>
</ul>
</li>
<li><strong>Manual Layouts</strong>: Building custom grids on the fly using preselection.</li>
<li><strong>Padding &amp; Gaps</strong>:
<ul>
<li><code>window_gap</code>: Space between nodes.</li>
<li><code>top_padding</code>, <code>left_padding</code>, etc.: Reserving space for bars/panels.</li>
<li>Configuring per-monitor or per-desktop padding (e.g., Mono-monitor setup needs different padding than Dual).</li>
</ul>
</li>
</ol>
<h3 id="the-ecosystem"><a class="header" href="#the-ecosystem">The Ecosystem</a></h3>
<ol>
<li><strong>Polybar / Lemonbar</strong>:
<ul>
<li>Parsing the <code>bspwm</code> internal report (<code>bspc subscribe report</code>) to display workspace tags (Occupied, Free, Urgent, Focused).</li>
</ul>
</li>
<li><strong>X11 Tools</strong>:
<ul>
<li><code>xprop</code>: Finding <code>WM_CLASS</code> and <code>WM_NAME</code> for rules.</li>
<li><code>xwininfo</code>: Debugging geometry.</li>
<li><code>xtitle</code>: Getting dynamic window titles for scripting.</li>
<li><code>xdo</code> / <code>xdotool</code>: Sending fake input or managing windows that <code>bspc</code> cannot touch.</li>
</ul>
</li>
<li><strong>Compositors (Picom)</strong>:
<ul>
<li>Handling transparency, shadows, and blur.</li>
<li>Managing opacity rules for focused vs. unfocused nodes.</li>
</ul>
</li>
</ol>
<h3 id="advanced-hacks--workflows"><a class="header" href="#advanced-hacks--workflows">Advanced Hacks &amp; Workflows</a></h3>
<ol>
<li><strong>Scratchpads</strong>:
<ul>
<li>Using the <code>hidden</code> flag and unique IDs to create “drop-down” terminals that toggle visibility.</li>
<li>Managing a “Scratchpad Desktop” (e.g., Desktop 10) vs. Hidden Nodes.</li>
</ul>
</li>
<li><strong>Swallowing</strong>:
<ul>
<li>implementing terminal swallowing (launching an image viewer “eats” the terminal window until the viewer closes) via generic scripts or tools like <code>devour</code>.</li>
</ul>
</li>
<li><strong>Dynamic Gaps</strong>:
<ul>
<li>Scripting gaps to disappear when only one window is present (<code>smart_gaps</code>).</li>
</ul>
</li>
<li><strong>Urgency Hints</strong>:
<ul>
<li>Handling <code>WM_HINTS</code> (flashing red borders) when a background window needs attention.</li>
</ul>
</li>
</ol>
<h3 id="troubleshooting--debugging"><a class="header" href="#troubleshooting--debugging">Troubleshooting &amp; Debugging</a></h3>
<ol>
<li><strong>The Socket</strong>: Understanding <code>/tmp/bspwm_...socket</code>.</li>
<li><strong>Logs</strong>: Checking <code>~/.xsession-errors</code>.</li>
<li><strong>Visual Debugging</strong>: Using <code>bspc query -T</code> piped to <code>jq</code> to visualize why a window is stuck in a specific split.</li>
</ol>
<h2 id="roadmap-for-learning"><a class="header" href="#roadmap-for-learning">Roadmap for Learning</a></h2>
<blockquote class="blockquote-tag blockquote-tag-note">
<p class="blockquote-tag-title"><svg viewbox="0 0 16 16" width="18" height="18"><path d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z"></path></svg>Note</p>
<p>We recommend you to visit the <strong>Advanced</strong> section of the wiki only after learing the basic chapters since those bulk chapters are a cummulative of all the basics.</p>
</blockquote>
<p>It is best to learn bspwm step by step. Introduction, Basics, Advanced, and then finally writing configurations.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="introduction-to-bspwm"><a href="#introduction-to-bspwm" class="header">Introduction to bspwm</a></h1>
<p>bspwm is a minimal tiling window manager: you mainly configure the WM via a shell script (<code>bspwmrc</code>) and handle keybindings via <code>sxhkd</code> (<code>sxhkdrc</code>).
A good “getting started” path is: install <code>bspwm</code> + <code>sxhkd</code>, copy the example configs into <code>~/.config/…</code>, make <code>bspwmrc</code> executable, then start <code>sxhkd</code> and <code>bspwm</code> from your X session.</p>
<h2 id="install-and-start"><a class="header" href="#install-and-start">Install and start</a></h2>
<ul>
<li>Install <code>bspwm</code> (the WM) and <code>sxhkd</code> (hotkey daemon).</li>
<li>Start <code>bspwm</code> via Xinit (or a display manager session), since bspwm is an X11 window manager.</li>
</ul>
<h2 id="create-initial-config"><a class="header" href="#create-initial-config">Create initial config</a></h2>
<ul>
<li>Copy the example configs from <code>/usr/share/doc/bspwm/examples/</code> into:
<ul>
<li><code>~/.config/bspwm/bspwmrc</code></li>
<li><code>~/.config/sxhkd/sxhkdrc</code></li>
</ul>
</li>
<li>Make sure <code>bspwmrc</code> is executable, because it’s a shell script that configures bspwm by running <code>bspc</code> commands.</li>
<li>ArchWiki’s example uses these commands (adjust if your distro differs):
<ul>
<li><code>install -Dm755 /usr/share/doc/bspwm/examples/bspwmrc ~/.config/bspwm/bspwmrc</code></li>
<li><code>install -Dm644 /usr/share/doc/bspwm/examples/sxhkdrc ~/.config/sxhkd/sxhkdrc</code></li>
</ul>
</li>
</ul>
<h2 id="learn-the-core-concepts"><a class="header" href="#learn-the-core-concepts">Learn the core concepts</a></h2>
<ul>
<li><code>bspwmrc</code> is where you set window manager behavior (desktops, gaps, rules, etc.) by sending messages with <code>bspc</code>.</li>
<li><code>sxhkdrc</code> is where you define keybindings that typically call <code>bspc</code> (focus/move windows, switch desktops, launch apps).</li>
<li>bspwm doesn’t handle keyboard input directly, so a hotkey daemon like <code>sxhkd</code> is required for shortcuts.</li>
</ul>
<h2 id="first-troubleshooting-checklist"><a class="header" href="#first-troubleshooting-checklist">First troubleshooting checklist</a></h2>
<p>If you boot into a blank screen and keys don’t work, check these first:</p>
<ul>
<li><code>sxhkd</code> is installed and actually started (and started in the background, since it blocks).</li>
<li><code>~/.config/bspwm/bspwmrc</code> is executable.</li>
<li>Your <code>sxhkdrc</code> terminal command matches a terminal you have installed (the example config may reference <code>urxvt</code>).</li>
</ul>
<h2 id="1-core-architecture-the-binary-tree-philosophy"><a class="header" href="#1-core-architecture-the-binary-tree-philosophy">1. Core Architecture: The Binary Tree Philosophy</a></h2>
<p>Unlike dynamic tilers (like DWM or Xmonad) that use predefined layout lists (master/stack, grid, spiral), bspwm is a <strong>manual</strong> tiler based on a data structure known as a <strong>full binary tree</strong>.</p>
<h3 id="11-the-data-structure"><a class="header" href="#11-the-data-structure">1.1 The Data Structure</a></h3>
<p>Every monitor contains at least one desktop. Every desktop is the root of a binary tree.</p>
<ul>
<li><strong>Nodes</strong>: The fundamental unit. A node is either a <em>leaf</em> (holding a window) or an <em>internal node</em> (holding two children).</li>
<li><strong>Leaves</strong>: The actual application windows (e.g., Firefox, Terminal).</li>
<li><strong>Internal Nodes</strong>: Containers that define the split direction (Horizontal/Vertical) and the split ratio (e.g., 0.5 for equal halves) between their two children.<br>
<img src="assets/binary-tree-structure.png" alt="BSPWM Binary Tree Structure">
<br>
BSPWM Binary Tree Structure</li>
</ul>
<h3 id="12-the-implication-of-manual-tiling"><a class="header" href="#12-the-implication-of-manual-tiling">1.2 The Implication of “Manual” Tiling</a></h3>
<p>In standard tilers, you “switch layouts.” In bspwm, you manipulate the tree directly.</p>
<ul>
<li><strong>Automatic Mode</strong>: Bspwm decides where the next window goes based on the <code>automatic_scheme</code> (usually “spiral” or “longest_side”).</li>
<li><strong>Manual Mode</strong>: You explicitly “preselect” a region (North, South, East, West) on an existing node. The next window splits <em>that specific node</em> in the chosen direction.
This architecture makes bspwm strictly <strong>deterministic</strong>. The layout is exactly what you build, nothing more, nothing less.</li>
</ul>
<h2 id="2-installation--environment"><a class="header" href="#2-installation--environment">2. Installation &amp; Environment</a></h2>
<p>Bspwm adheres strictly to the Unix philosophy: “Do one thing and do it well.” It only manages windows. It does <strong>not</strong> handle:</p>
<ul>
<li>Keyboard input (handled by <code>sxhkd</code>)</li>
<li>Compositing (handled by <code>picom</code>)</li>
<li>Bars/Panels (handled by <code>polybar</code> or <code>lemonbar</code>)</li>
<li>Wallpaper (handled by <code>feh</code> or <code>nitrogen</code>)</li>
</ul>
<h3 id="21-dependencies-arch-linux--general"><a class="header" href="#21-dependencies-arch-linux--general">2.1 Dependencies (Arch Linux / General)</a></h3>
<p>You must install both the window manager and the hotkey daemon.</p>
<pre><code class="language-bash"># Arch Linux
sudo pacman -S bspwm sxhkd

# Debian/Ubuntu
sudo apt install bspwm sxhkd
</code></pre>
<h3 id="22-x11-session-entry"><a class="header" href="#22-x11-session-entry">2.2 X11 Session Entry</a></h3>
<p>Because bspwm is just a binary, it must be launched via <code>.xinitrc</code> or a Display Manager (LightDM/GDM).
<strong>File</strong>: <code>~/.xinitrc</code></p>
<pre><code class="language-bash"># Load resources
xrdb -merge ~/.Xresources &amp;

# Start the hotkey daemon in the background (CRITICAL)
sxhkd &amp;

# Start the compositor (optional but recommended)
picom &amp;

# Set wallpaper
feh --bg-fill ~/Pictures/wall.jpg &amp;

# Set cursor shape (fixes "X" cursor bug)
xsetroot -cursor_name left_ptr &amp;

# Launch bspwm (must be the last line, no '&amp;')
exec bspwm
</code></pre>
<h2 id="3-the-nervous-system-sxhkd"><a class="header" href="#3-the-nervous-system-sxhkd">3. The Nervous System: <code>sxhkd</code></a></h2>
<p><code>sxhkd</code> is an X daemon that reacts to input events and executes commands. It is independent of bspwm but essential for it.
<strong>Config Location</strong>: <code>~/.config/sxhkd/sxhkdrc</code></p>
<h3 id="31-syntax--chords"><a class="header" href="#31-syntax--chords">3.1 Syntax &amp; Chords</a></h3>
<p><code>sxhkd</code> uses a unique syntax that allows for “chord chains” (pressing keys in sequence) and “brace expansion” (compacting similar commands).</p>
<h4 id="brace-expansion-the-power-feature"><a class="header" href="#brace-expansion-the-power-feature">Brace Expansion (The Power Feature)</a></h4>
<p>Instead of writing 4 separate lines for moving windows, you write one:</p>
<pre><code class="language-bash"># Move window node (super + shift + {h,j,k,l})
super + shift + {h,j,k,l}
    bspc node -v {-20 0, 0 20, 0 -20, 20 0}
</code></pre>
<ul>
<li>When you press <code>Super + Shift + h</code>, it executes <code>bspc node -v -20 0</code>.</li>
<li>When you press <code>Super + Shift + j</code>, it executes <code>bspc node -v 0 20</code>.</li>
</ul>
<h4 id="chord-chains"><a class="header" href="#chord-chains">Chord Chains</a></h4>
<p>You can create “modes” without actual modes.</p>
<pre><code class="language-bash"># Press Super + o, release, then press 'r' to reload config
super + o ; r
    bspc wm -r
</code></pre>
<h3 id="32-essential-keybindings-table"><a class="header" href="#32-essential-keybindings-table">3.2 Essential Keybindings Table</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th style="text-align: left">Key Chord</th><th style="text-align: left">Command</th><th style="text-align: left">Description</th></tr>
</thead>
<tbody>
<tr><td style="text-align: left"><code>super + Return</code></td><td style="text-align: left"><code>$TERMINAL</code></td><td style="text-align: left">Launch terminal</td></tr>
<tr><td style="text-align: left"><code>super + w</code></td><td style="text-align: left"><code>bspc node -c</code></td><td style="text-align: left">Close focused window</td></tr>
<tr><td style="text-align: left"><code>super + {h,j,k,l}</code></td><td style="text-align: left"><code>bspc node -f {west,south,north,east}</code></td><td style="text-align: left">Focus window directionally</td></tr>
<tr><td style="text-align: left"><code>super + {1-9}</code></td><td style="text-align: left"><code>bspc desktop -f ^{1-9}</code></td><td style="text-align: left">Switch to desktop 1-9</td></tr>
<tr><td style="text-align: left"><code>super + shift + {1-9}</code></td><td style="text-align: left"><code>bspc node -d ^{1-9}</code></td><td style="text-align: left">Send window to desktop 1-9</td></tr>
</tbody>
</table>
</div>
<h2 id="4-the-brain-bspwmrc"><a class="header" href="#4-the-brain-bspwmrc">4. The Brain: <code>bspwmrc</code></a></h2>
<p><strong>File</strong>: <code>~/.config/bspwm/bspwmrc</code>
<strong>Requirement</strong>: Must be executable (<code>chmod +x bspwmrc</code>).
This file is simply a shell script. It runs once at startup. If you change it, you must reload bspwm (<code>bspc wm -r</code>) to re-run it.</p>
<h3 id="41-monitor-configuration"><a class="header" href="#41-monitor-configuration">4.1 Monitor Configuration</a></h3>
<p>You must explicitly map desktops to monitors. If you plug in a second monitor, bspwm won’t use it until you tell it to.</p>
<pre><code class="language-bash">#!/bin/sh

# Clean setup for one or two monitors
if [[ $(xrandr -q | grep "HDMI-0 connected") ]]; then
    # Dual monitor setup
    bspc monitor DP-0 -d I II III IV V
    bspc monitor HDMI-0 -d VI VII VIII IX X
else
    # Single monitor setup
    bspc monitor DP-0 -d I II III IV V VI VII VIII IX X
fi
</code></pre>
<h3 id="42-global-aesthetics"><a class="header" href="#42-global-aesthetics">4.2 Global Aesthetics</a></h3>
<pre><code class="language-bash"># Border width (pixels)
bspc config border_width         2

# Window gap (space between windows)
bspc config window_gap          12

# Split ratio (0.5 = 50/50 split)
bspc config split_ratio          0.50

# Border colors
bspc config normal_border_color "#4c566a"
bspc config focused_border_color "#88c0d0"

# Focus follows mouse (true/false)
bspc config focus_follows_pointer true
</code></pre>
<h2 id="5-control-plane-mastering-bspc"><a class="header" href="#5-control-plane-mastering-bspc">5. Control Plane: Mastering <code>bspc</code></a></h2>
<p><code>bspc</code> (Binary Space Partitioning Control) is the command-line client. You use it in <code>bspwmrc</code>, <code>sxhkdrc</code>, and your own scripts. Understanding <code>bspc</code> is understanding bspwm.</p>
<h3 id="51-selectors-the-query-language"><a class="header" href="#51-selectors-the-query-language">5.1 Selectors: The Query Language</a></h3>
<p>Almost every <code>bspc</code> command requires you to select a target.</p>
<ul>
<li><strong>Nodes</strong>: <code>-n</code> (Target a window)</li>
<li><strong>Desktops</strong>: <code>-d</code> (Target a workspace)</li>
<li><strong>Monitors</strong>: <code>-m</code> (Target a screen)</li>
</ul>
<h4 id="advanced-node-selectors"><a class="header" href="#advanced-node-selectors">Advanced Node Selectors</a></h4>
<p>You can target nodes based on relationships, flags, or history.</p>
<ul>
<li><code>focused</code>: The currently active window.</li>
<li><code>east</code>, <code>west</code>, <code>north</code>, <code>south</code>: Directional neighbors.</li>
<li><code>last</code>: The previously focused node.</li>
<li><code>biggest</code>: The largest node on the desktop.</li>
<li><code>@parent</code>: The internal node holding the current window and its sibling.
<strong>Example</strong>: Swap the current window with the biggest window on the desktop:</li>
</ul>
<pre><code class="language-bash">bspc node -s biggest.local
</code></pre>
<h3 id="52-node-modifications"><a class="header" href="#52-node-modifications">5.2 Node Modifications</a></h3>
<ul>
<li><strong>Flags</strong>: Nodes can be <code>hidden</code>, <code>sticky</code> (follows you across desktops), <code>private</code> (ignored by some queries), or <code>locked</code> (cannot be closed).</li>
</ul>
<pre><code class="language-bash">bspc node -g sticky  # Toggle sticky
bspc node -t floating # Float the window
</code></pre>
<ul>
<li><strong>Preselection</strong>: The killer feature. Define where the <em>next</em> window opens.</li>
</ul>
<pre><code class="language-bash">bspc node -p south   # Preselect the bottom half
bspc node -p cancel  # Cancel preselection
</code></pre>
<h2 id="6-window-management-dynamics"><a class="header" href="#6-window-management-dynamics">6. Window Management Dynamics</a></h2>
<h3 id="61-manual-vs-automatic"><a class="header" href="#61-manual-vs-automatic">6.1 Manual vs. Automatic</a></h3>
<p>By default, bspwm splits windows automatically (spiraling inward).
To take control, you use <strong>Preselection</strong>.</p>
<ol>
<li><strong>Input</strong>: User presses <code>Super + Ctrl + L</code> (East).</li>
<li><strong>Visual Feedback</strong>: Bspwm highlights the right half of the current node in a distinct color (configurable via <code>presel_feedback_color</code>).</li>
<li><strong>Action</strong>: User opens a terminal.</li>
<li><strong>Result</strong>: The terminal spawns exactly in that highlighted area.</li>
</ol>
<h3 id="62-receptacles"><a class="header" href="#62-receptacles">6.2 Receptacles</a></h3>
<p>A <strong>Receptacle</strong> is a “placeholder” node—a leaf that contains no window. It reserves space in the tree layout.</p>
<ul>
<li><strong>Use case</strong>: You want to build a complex layout (e.g., 3 small windows on the left, one big on the right) <em>before</em> you open the applications.</li>
<li><strong>Command</strong>: <code>bspc node -i</code> (Insert receptacle).</li>
</ul>
<h3 id="63-swallowing-terminal-suppression"><a class="header" href="#63-swallowing-terminal-suppression">6.3 Swallowing (Terminal Suppression)</a></h3>
<p>“Swallowing” is when you launch a GUI app (like MPV or Sxiv) from a terminal, and the terminal disappears, being “swallowed” by the new app. When the app closes, the terminal returns.</p>
<ul>
<li>Bspwm does not do this natively.</li>
<li><strong>Solution</strong>: Use an external listener script or a wrapper tool like <code>devour</code> in your sxhkd config.</li>
</ul>
<h2 id="7-advanced-logic-external-rules"><a class="header" href="#7-advanced-logic-external-rules">7. Advanced Logic: External Rules</a></h2>
<p>This is bspwm’s most powerful configuration feature. Instead of a simple “If app is Firefox -&gt; move to desktop 2” list, you can point bspwm to a script.
<strong>Config</strong>: <code>bspc config external_rules_command ~/.config/bspwm/external_rules</code></p>
<h3 id="71-the-external-rules-script"><a class="header" href="#71-the-external-rules-script">7.1 The External Rules Script</a></h3>
<p>Bspwm passes the Window ID, Class, Instance, and Title to this script as arguments. The script prints commands to <code>stdout</code> that bspwm executes for that specific window.</p>
<p><strong>Example: <code>~/.config/bspwm/external_rules</code></strong></p>
<pre><code class="language-bash">#!/bin/sh

wid=$1
class=$2
instance=$3
title=$(xtitle "$wid")

# If it's a Picture-in-Picture window (Firefox/Chrome)
if [ "$title" = "Picture-in-Picture" ]; then
    echo "state=floating"
    echo "sticky=on"
    echo "border=off"
    exit 0
fi

# If it's GIMP, move to desktop 8 and follow it
if [ "$class" = "Gimp" ]; then
    echo "desktop=^8"
    echo "follow=on"
    exit 0
fi

# Complex logic: If 2 nodes already exist on desktop 1, send next one to desktop 2
count=$(bspc query -N -d ^1 | wc -l)
if [ "$count" -ge 2 ]; then
    echo "desktop=^2"
fi
</code></pre>
<p>This allows for logic impossible in other window managers (e.g., “Float this window only if it’s Tuesday and I’m on Monitor 2”).</p>
<h2 id="8-the-ecosystem"><a class="header" href="#8-the-ecosystem">8. The Ecosystem</a></h2>
<p>A “naked” bspwm is just black screens. You need the ecosystem to make it a workstation.</p>
<h3 id="81-polybar-status-bar"><a class="header" href="#81-polybar-status-bar">8.1 Polybar (Status Bar)</a></h3>
<p>Polybar has a built-in <code>bspwm</code> module. It can display the focused desktop, occupied desktops, and urgent alerts.
<strong>Module Config</strong>:</p>
<pre><code class="language-ini">[module/bspwm]
type = internal/bspwm
label-focused = %name%
label-focused-background = #3b4252
label-focused-underline= #88c0d0
label-occupied = %name%
label-urgent = %name%!
label-empty =
</code></pre>
<h3 id="82-rofi-application-launcher"><a class="header" href="#82-rofi-application-launcher">8.2 Rofi (Application Launcher)</a></h3>
<p>Rofi works perfectly as a menu. Bind it in <code>sxhkd</code>:</p>
<pre><code class="language-bash">super + space
    rofi -show drun -show-icons
</code></pre>
<h3 id="83-scratchpads-hidden-windows"><a class="header" href="#83-scratchpads-hidden-windows">8.3 Scratchpads (Hidden Windows)</a></h3>
<p>Bspwm creates scratchpads easily using node flags.</p>
<ol>
<li><strong>Hide</strong>: <code>bspc node -g hidden -f</code></li>
<li><strong>Show</strong>: <code>bspc node &lt;selector&gt; -g hidden=off -f</code>
<strong>Scripted Toggle (Sticky Scratchpad)</strong>:</li>
</ol>
<pre><code class="language-bash">#!/bin/sh
id=$(xdotool search --class "scratchpad_term" | tail -1)

if [ -z "$id" ]; then
    # Launch if not running
    alacritty --class scratchpad_term &amp;
else
    # Toggle visibility
    if bspc query -N -n "$id.hidden"; then
        bspc node "$id" -g hidden=off -d focused -f
    else
        bspc node "$id" -g hidden=on
    fi
fi
</code></pre>
<h2 id="9-troubleshooting--debugging"><a class="header" href="#9-troubleshooting--debugging">9. Troubleshooting &amp; Debugging</a></h2>
<h3 id="91-the-blank-screen-of-death"><a class="header" href="#91-the-blank-screen-of-death">9.1 The Blank Screen of Death</a></h3>
<p>If you log in and see nothing:</p>
<ol>
<li><strong>Check Executable</strong>: Did you <code>chmod +x ~/.config/bspwm/bspwmrc</code>?</li>
<li><strong>Check sxhkd</strong>: Is <code>sxhkd</code> running? Switch to TTY (<code>Ctrl+Alt+F2</code>), login, and run <code>pidof sxhkd</code>.</li>
<li><strong>Check Terminal</strong>: Does your <code>sxhkdrc</code> launch a terminal you actually have installed? (Default is often <code>urxvt</code>, you might have <code>alacritty</code> or <code>kitty</code>).</li>
</ol>
<h3 id="92-tree-visualization"><a class="header" href="#92-tree-visualization">9.2 Tree Visualization</a></h3>
<p>To understand why your windows are splitting weirdly, dump the tree state:</p>
<pre><code class="language-bash">bspc query -T -d | jq .
</code></pre>
<p>This outputs the JSON representation of the current desktop’s binary tree.</p>
<h3 id="93-orphaned-nodes"><a class="header" href="#93-orphaned-nodes">9.3 Orphaned Nodes</a></h3>
<p>Sometimes a “ghost” node remains. Cleanup:</p>
<pre><code class="language-bash"># Remove the node explicitly
bspc node &lt;node_id&gt; -k
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="architecture-of-bspwm"><a href="#architecture-of-bspwm" class="header">Architecture of bspwm</a></h1>
<h2 id="1-architectural-internals"><a class="header" href="#1-architectural-internals">1. Architectural Internals</a></h2>
<h3 id="11-the-binary-space-partitioning-bsp-model"><a class="header" href="#11-the-binary-space-partitioning-bsp-model">1.1 The Binary Space Partitioning (BSP) Model</a></h3>
<p>At its core, <strong>bspwm</strong> differs fundamentally from dynamic tilers (like i3, dwm, or xmonad) because it maps windows directly to the leaves of a <strong>full binary tree</strong>. There are no “lists” or “stacks” of windows; there is only the tree.</p>
<h4 id="the-node_t-structure"><a class="header" href="#the-node_t-structure">The <code>node_t</code> Structure</a></h4>
<p>Understanding bspwm requires understanding the C structure that represents every node. A <code>node</code> is the atomic unit of the window manager.</p>
<ul>
<li><strong>Internal Nodes</strong>: These are purely structural. They do not hold windows. Their sole purpose is to define a region of space and how it is split.
<ul>
<li><em>Properties</em>: <code>split_type</code> (Horizontal or Vertical), <code>split_ratio</code> (0.0 to 1.0, default 0.5), <code>first_child</code> (pointer), <code>second_child</code> (pointer).</li>
</ul>
</li>
<li><strong>Leaf Nodes</strong>: These are the containers for actual X11 windows.
<ul>
<li><em>Properties</em>: <code>client</code> (Window ID), <code>vacuity</code> (Occupied or Empty/Receptacle).
<br>
<img src="assets/binary-tree-structure-2.png" alt="BSPWM Binary Tree Structure">
<br>
BSPWM Binary Tree Structure
When you “move” a window in bspwm, you are actually performing tree rotation or swapping pointers in this linked structure.</li>
</ul>
</li>
</ul>
<h3 id="12-the-ipc-architecture-inter-process-communication"><a class="header" href="#12-the-ipc-architecture-inter-process-communication">1.2 The IPC Architecture (Inter-Process Communication)</a></h3>
<p><code>bspwm</code> itself is a daemon that does not read a configuration file at runtime. It opens a Unix domain socket and waits for byte-stream commands.</p>
<ul>
<li><strong>The Daemon (<code>bspwm</code>)</strong>: Sits in an event loop (using <code>select</code> or <code>epoll</code>), listening for two things simultaneously:</li>
</ul>
<ol>
<li><strong>X11 Events</strong>: <code>MapRequest</code>, <code>DestroyNotify</code>, <code>EnterNotify</code> (from the X server).</li>
<li><strong>Socket Messages</strong>: Commands from <code>bspc</code>.</li>
</ol>
<ul>
<li><strong>The Client (<code>bspc</code>)</strong>: A lightweight binary that connects to the socket, sends a null-terminated string (e.g., <code>node\0-f\0west\0</code>), waits for a response, and prints it to stdout.
<strong>Implication</strong>: Your <code>bspwmrc</code> is just a shell script that spams <code>bspc</code> commands to the socket. If <code>bspc</code> fails, <code>bspwm</code> remains completely unconfigured (black screen).</li>
</ul>
<h2 id="2-the-bspc-command-language"><a class="header" href="#2-the-bspc-command-language">2. The <code>bspc</code> Command language</a></h2>
<p><code>bspc</code> is not just a controller; it is a query language. Almost every command follows the pattern: <code>bspc &lt;DOMAIN&gt; &lt;ACTION&gt; &lt;SELECTOR&gt;</code>.</p>
<h3 id="21-selectors-and-descriptors"><a class="header" href="#21-selectors-and-descriptors">2.1 Selectors and Descriptors</a></h3>
<p>A selector uniquely identifies a node, desktop, or monitor.
<strong>Syntax</strong>: <code>[REFERENCE#]DESCRIPTOR(.MODIFIER)*</code></p>
<ul>
<li><strong>Reference</strong>: The starting point. Defaults to <code>focused</code>. You can set it arbitrarily: <code>0x00200005#...</code> starts the search from window <code>0x00200005</code>.</li>
<li><strong>Descriptors</strong>:
<ul>
<li><strong>Directional</strong>: <code>north</code>, <code>south</code>, <code>east</code>, <code>west</code>.</li>
<li><strong>Cyclic</strong>: <code>next</code>, <code>prev</code> (follows the tree traversal order).</li>
<li><strong>Genealogical</strong>: <code>parent</code>, <code>brother</code>, <code>first_child</code>, <code>second_child</code>, <code>ancestor</code>, <code>descendant</code>.</li>
<li><strong>History</strong>: <code>last</code> (last focused), <code>older</code>, <code>newer</code>.</li>
</ul>
</li>
<li><strong>Modifiers</strong>: Filters that refine the selection.
<ul>
<li><code>.local</code> (same desktop), <code>.leaf</code> (ignore internal nodes), <code>.floating</code>, <code>.tiled</code>.</li>
<li><code>!</code>: Negation. <code>.!hidden</code> means “not hidden”.
<strong>Example</strong>: “Focus the first non-hidden floating window on the current desktop.”</li>
</ul>
</li>
</ul>
<pre><code class="language-bash">bspc node -f .floating.!hidden.local.first
</code></pre>
<h3 id="22-path-selectors-"><a class="header" href="#22-path-selectors-">2.2 Path Selectors (<code>@</code>)</a></h3>
<p>You can address nodes by their path from the root of the tree.</p>
<ul>
<li><code>@/</code>: The root of the current desktop.</li>
<li><code>@/1</code>: The first child (left/top) of the root.</li>
<li><code>@/2</code>: The second child (right/bottom) of the root.</li>
<li><code>@/2/1</code>: The first child of the second child of the root.
This is useful for scripts that need to traverse the tree deterministically.</li>
</ul>
<h2 id="3-command-reference"><a class="header" href="#3-command-reference">3. Command Reference</a></h2>
<h3 id="31-node-operations-bspc-node"><a class="header" href="#31-node-operations-bspc-node">3.1 Node Operations (<code>bspc node</code>)</a></h3>
<ul>
<li><strong>Insertion (<code>-i</code>)</strong>: Inserts a “receptacle” (empty leaf) at the given split.
<ul>
<li><code>bspc node -i</code> creates a blank space where you can later dump a window.</li>
</ul>
</li>
<li><strong>Preselection (<code>-p</code>)</strong>: Marks a node to be split in a specific way for the <em>next</em> window.
<ul>
<li><code>bspc node -p south -o 0.75</code>: “The next window will open in the bottom 25% of this node.”</li>
</ul>
</li>
<li><strong>Flags (<code>-g</code>)</strong>:
<ul>
<li><code>hidden</code>: Removes the window from the tree layout but keeps it in memory (minimized).</li>
<li><code>sticky</code>: Keeps the window visible across all desktop switches on that monitor.</li>
<li><code>private</code>: Bspwm will try not to split this node.</li>
<li><code>marked</code>: Tags a node for batch operations.</li>
</ul>
</li>
</ul>
<h3 id="32-desktop--monitor-operations"><a class="header" href="#32-desktop--monitor-operations">3.2 Desktop &amp; Monitor Operations</a></h3>
<ul>
<li><strong>Reordering</strong>: <code>bspc monitor -o I II III IV</code> reorders desktops.</li>
<li><strong>Swapping</strong>: <code>bspc desktop -s prev</code> swaps the current desktop with the previous one.</li>
<li><strong>Bubbling</strong>: <code>bspc desktop -b next</code> “bubbles” the desktop (moves it one slot over in the list).</li>
</ul>
<h3 id="33-the-query-system-bspc-query"><a class="header" href="#33-the-query-system-bspc-query">3.3 The Query System (<code>bspc query</code>)</a></h3>
<p>This is the most powerful tool for scripting.</p>
<ul>
<li><code>bspc query -T</code>: Dumps the <strong>entire world state</strong> (monitors -&gt; desktops -&gt; nodes) as a JSON object.</li>
<li><code>bspc query -N</code>: Lists node IDs.
<ul>
<li><strong>Use Case</strong>: Count windows on current desktop:</li>
</ul>
</li>
</ul>
<pre><code class="language-bash">bspc query -N -d focused -n .leaf.!hidden | wc -l
</code></pre>
<h2 id="4-advanced-logic--scripting"><a class="header" href="#4-advanced-logic--scripting">4. Advanced Logic &amp; Scripting</a></h2>
<h3 id="41-external-rules"><a class="header" href="#41-external-rules">4.1 External Rules</a></h3>
<p>Bspwm allows you to offload window placement logic to an external script. This is defined by <code>external_rules_command</code>.
<strong>How it works</strong>:</p>
<ol>
<li>A new window appears.</li>
<li>Bspwm pauses.</li>
<li>It calls your script with arguments: <code>WindowID</code>, <code>Class</code>, <code>Instance</code>.</li>
<li>Your script prints key-value pairs to stdout (e.g., <code>state=floating</code>, <code>desktop=^3</code>).</li>
<li>Bspwm applies these settings <em>before</em> mapping the window.
<strong>Example Script</strong>:</li>
</ol>
<pre><code class="language-bash">#!/bin/sh
wid=$1
class=$2
instance=$3

# Float all "Save As" dialogs
if [ "$class" = "Gtkwave" ] &amp;&amp; [ "$instance" = "file_chooser" ]; then
    echo "state=floating"
    echo "center=on"
fi
</code></pre>
<h3 id="42-state-restoration-layouts"><a class="header" href="#42-state-restoration-layouts">4.2 State Restoration (Layouts)</a></h3>
<p>Because the state is purely data (JSON), you can save and restore layouts.</p>
<ul>
<li><strong>Save</strong>: <code>bspc query -T -d &gt; layout.json</code>.</li>
<li><strong>Restore</strong>: A script is needed to parse this JSON. It would iterate through the tree, using <code>bspc node -i</code> to create receptacles in the exact structure of the saved tree, and then launch applications to fill those receptacles.</li>
</ul>
<h3 id="43-the-subscriber-bspc-subscribe"><a class="header" href="#43-the-subscriber-bspc-subscribe">4.3 The Subscriber (<code>bspc subscribe</code>)</a></h3>
<p>For status bars (like Polybar) or event-driven scripts.
<code>bspc subscribe report</code> streams a continuous string describing the state:
<code>W:m:DP-0:O:I:f:II:o:III:m:HDMI-0:o:IV:o:V</code></p>
<ul>
<li><code>W</code>: Start of report.</li>
<li><code>m:DP-0</code>: Monitor DP-0.</li>
<li><code>O:I</code>: Desktop I is Occupied.</li>
<li><code>f:II</code>: Desktop II is Free (empty).</li>
<li><code>F:III</code>: Desktop III is Focused.
This allows bars to update instantly without polling.</li>
</ul>
<h2 id="5-event-flow-a-step-by-step"><a class="header" href="#5-event-flow-a-step-by-step">5. Event Flow: A Step-by-Step</a></h2>
<p>When you press <code>Super + Enter</code> (Terminal):</p>
<ol>
<li><strong>X Server</strong> receives KeyPress.</li>
<li><strong>sxhkd</strong> (listening for keys) matches <code>super + Return</code>.</li>
<li><strong>sxhkd</strong> executes <code>$TERMINAL</code> (e.g., Alacritty).</li>
<li><strong>Alacritty</strong> starts and asks X11 for a window (<code>CreateWindow</code>).</li>
<li><strong>X Server</strong> sends <code>MapRequest</code> to bspwm.</li>
<li><strong>bspwm</strong> intercepts:
<ul>
<li>Runs <code>external_rules_command</code>.</li>
<li>Consults the <code>bspwmrc</code> rules (<code>bspc rule -a ...</code>).</li>
<li>Finds the “insertion point” (focused node or preselection).</li>
<li>Splits the tree node.</li>
<li>Resizes existing windows.</li>
</ul>
</li>
<li><strong>bspwm</strong> grants the MapRequest.</li>
<li><strong>X Server</strong> draws the window.</li>
</ol>
<p>This entire chain happens in milliseconds, driven by the binary tree logic that ensures no two windows ever overlap (unless floating).</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="basics-of-bspwm"><a class="header" href="#basics-of-bspwm">Basics of bspwm</a></h1>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="the-bspc-config-command"><a href="#the-bspc-config-command" class="header">The bspc config command</a></h1>
<h2 id="introduction-to-bspc-command"><a class="header" href="#introduction-to-bspc-command">Introduction to <code>bspc</code> command</a></h2>
<p>Bspwm is controlled and configured via the <code>bspc</code> command.  In practice one writes a shell script (typically $XDG_CONFIG_HOME/bspwm/bspwmrc) that calls bspc config to set various options.  The general syntax is:</p>
<pre><code class="language-bash">bspc config [ -m MONITOR | -d DESKTOP | -n NODE ] &lt; setting &gt; [&lt; value &gt;]
</code></pre>
<p>This gets or sets the value of <code>&lt; setting &gt;</code>. Without selectors, the setting applies globally; with -m, -d, or -n it targets a specific monitor, desktop or node.  Each option affects bspwm’s behavior: for example, bspc config border_width 3 sets the width of window borders to 3 pixels.  The settings below comprise every configurable parameter (as of the latest stable bspwm) and include the option’s role, valid values, default behavior, and examples.</p>
<h2 id="window-borders-and-colors"><a class="header" href="#window-borders-and-colors">Window Borders and Colors</a></h2>
<p>Bspwm uses window borders to indicate focus and state.  The global border color settings are:</p>
<p><strong><code>normal_border_color:</code></strong> color for an unfocused window’s border.</p>
<p><strong><code>active_border_color:</code></strong> color for a focused window on an unfocused monitor.</p>
<p><strong><code>focused_border_color</code>:</strong> color for a focused window on the active monitor.
Each of these accepts any color string #RRGGBB or named X color.  For example, to make the focused window’s border red:</p>
<pre><code class="language-bash">bspc config focused_border_color "#FF0000"
</code></pre>
<blockquote class="blockquote-tag blockquote-tag-tip">
<p class="blockquote-tag-title"><svg viewbox="0 0 16 16" width="18" height="18"><path d="M8 1.5c-2.363 0-4 1.69-4 3.75 0 .984.424 1.625.984 2.304l.214.253c.223.264.47.556.673.848.284.411.537.896.621 1.49a.75.75 0 0 1-1.484.211c-.04-.282-.163-.547-.37-.847a8.456 8.456 0 0 0-.542-.68c-.084-.1-.173-.205-.268-.32C3.201 7.75 2.5 6.766 2.5 5.25 2.5 2.31 4.863 0 8 0s5.5 2.31 5.5 5.25c0 1.516-.701 2.5-1.328 3.259-.095.115-.184.22-.268.319-.207.245-.383.453-.541.681-.208.3-.33.565-.37.847a.751.751 0 0 1-1.485-.212c.084-.593.337-1.078.621-1.489.203-.292.45-.584.673-.848.075-.088.147-.173.213-.253.561-.679.985-1.32.985-2.304 0-2.06-1.637-3.75-4-3.75ZM5.75 12h4.5a.75.75 0 0 1 0 1.5h-4.5a.75.75 0 0 1 0-1.5ZM6 15.25a.75.75 0 0 1 .75-.75h2.5a.75.75 0 0 1 0 1.5h-2.5a.75.75 0 0 1-.75-.75Z"></path></svg>Tip</p>
<p>You can query the current color with bspc config focused_border_color</p>
</blockquote>
<p>A special feedback color, <code>presel_feedback_color</code>, governs the border drawn during manual split-preselection (preselection feedback).  For instance, setting</p>
<pre><code class="language-bash">bspc config presel_feedback_color "#00FF00"
</code></pre>
<p>will draw a green highlight where a split will occur.</p>
<p>The <code>border_width</code> option (a node setting) sets the thickness in pixels of the window border. Its default is 1 pixel; to make borders thicker, e.g.:</p>
<pre><code class="language-bash">bspc config border_width 2
</code></pre>
<p>These parameters control the visual frame around windows.  In the <strong>monocle layout</strong> (one-window fullscreen mode), two special flags exist: <strong>borderless_monocle</strong> (boolean) removes borders when in monocle mode, and <strong>gapless_monocle</strong> removes any window gaps in monocle layout.  Finally, <strong>single_monocle</strong> (boolean) forces the layout to switch to monocle when only one window is present. For example:</p>
<pre><code class="language-bash">bspc config borderless_monocle true
bspc config gapless_monocle true
bspc config single_monocle true
</code></pre>
<p>These would eliminate borders and gaps in monocle layout and make that layout automatic for lone windows.</p>
<h2 id="splitting-and-layout"><a class="header" href="#splitting-and-layout">Splitting and Layout</a></h2>
<p>The <code>split_ratio</code> setting defines how a window is partitioned when a new window is inserted in automatic mode. It is a fraction between 0 and 1. For example,</p>
<pre><code class="language-bash">bspc config split_ratio 0.60
</code></pre>
<p>makes new splits 60/40 by default (i.e. the first child gets 60% of the space).  The default is 0.5 (even split) unless changed in your config.</p>
<p><strong>Window spacing is controlled by <code>window_gap</code></strong> (desktop setting), which is the number of pixels of space between tiled windows.  To add a 10px gap everywhere, use:</p>
<pre><code class="language-bash">bspc config window_gap 10
</code></pre>
<p><strong>Monocle-layout</strong> padding can also be set. The options top_monocle_padding, right_monocle_padding, bottom_monocle_padding, and left_monocle_padding (all in pixels) add blank space at the screen edges when in monocle mode. For example, to center a monocle window with a 20px top margin:</p>
<pre><code class="language-bash">bspc config top_monocle_padding 20
</code></pre>
<blockquote class="blockquote-tag blockquote-tag-important">
<p class="blockquote-tag-title"><svg viewbox="0 0 16 16" width="18" height="18"><path d="M0 1.75C0 .784.784 0 1.75 0h12.5C15.216 0 16 .784 16 1.75v9.5A1.75 1.75 0 0 1 14.25 13H8.06l-2.573 2.573A1.458 1.458 0 0 1 3 14.543V13H1.75A1.75 1.75 0 0 1 0 11.25Zm1.75-.25a.25.25 0 0 0-.25.25v9.5c0 .138.112.25.25.25h2a.75.75 0 0 1 .75.75v2.19l2.72-2.72a.749.749 0 0 1 .53-.22h6.5a.25.25 0 0 0 .25-.25v-9.5a.25.25 0 0 0-.25-.25Zm7 2.25v2.5a.75.75 0 0 1-1.5 0v-2.5a.75.75 0 0 1 1.5 0ZM9 9a1 1 0 1 1-2 0 1 1 0 0 1 2 0Z"></path></svg>Important</p>
<p>In summary, <code>split_ratio</code> and <code>window_gap</code> affect tiling splits and inter-window gaps, while the monocle flags/padding fine-tune fullscreen behavior.</p>
</blockquote>
<h3 id="automatic-tiling-and-preselection"><a class="header" href="#automatic-tiling-and-preselection">Automatic Tiling and Preselection</a></h3>
<p>Bspwm can tile windows automatically or under manual preselection. The automatic_scheme option chooses the insertion algorithm: it accepts longest_side, alternate, or spiral.  This determines how the binary partitioning tree expands. For example:</p>
<pre><code class="language-bash">bspc config automatic_scheme spiral
</code></pre>
<p>switches to the <strong>“spiral”</strong> insertion pattern.</p>
<blockquote class="blockquote-tag blockquote-tag-note">
<p class="blockquote-tag-title"><svg viewbox="0 0 16 16" width="18" height="18"><path d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z"></path></svg>Note</p>
<p>By default bspwm uses <code>alternate</code> automatic scheme which alternates between vertical and horizontal splits.</p>
</blockquote>
<p>The <code>initial_polarity</code> option determines on which side a new window is attached in an automatic split when a node has only one child. It can be first_child or second_child. For instance:</p>
<pre><code class="language-bash">bspc config initial_polarity first_child
</code></pre>
<p>makes new windows attach on the first (left or top) side of the split by default. (By default this is usually second_child.)</p>
<p><strong>Other related options:</strong> <code>directional_focus_tightness</code> (high or low) tweaks how strictly bspwm decides whether a window is “in the DIR side” of another for focus commands. <code>removal_adjustment</code> (boolean) controls whether bspwm adjusts (re-splits) the sibling when a node is removed from the tree; turning it off can leave odd splits if windows are closed.</p>
<p><strong>Preselection (manual tiling)</strong> can be toggled with pointer commands or key bindings. The presel_feedback setting (boolean, defaults to true) enables the visible overlay that shows where a manual split will occur. If you disable it (bspc config presel_feedback false), bspwm will still respect manual split commands but won’t draw the highlighted region.</p>
<p>In short, these settings define how bspwm splits windows: the scheme, where new windows attach, and how strictly the tiling is adjusted or visualized.</p>
<h3 id="pointer-and-focus-behavior"><a class="header" href="#pointer-and-focus-behavior">Pointer and Focus Behavior</a></h3>
<p>Bspwm lets you use the mouse (with a modifier key) to move/resize windows and to control focus. The pointer_modifier setting specifies which keyboard modifier (e.g. mod4 for the Super/Windows key) enables pointer actions. For example:</p>
<pre><code class="language-bash">bspc config pointer_modifier mod4
</code></pre>
<p>Means holding Super while clicking/draggings acts on windows.</p>
<p>By default, <code>pointer_modifier+Button1</code> moves a window, <code>Button2</code> resizes by dragging a side, and <code>Button3</code> resizes by dragging a corner. These defaults correspond to <code>pointer_action1=move</code>, <code>pointer_action2=resize_side</code>, <code>pointer_action3=resize_corner</code>. You can reassign them; e.g.:</p>
<pre><code class="language-bash">bspc config pointer_action1 resize_side
bspc config pointer_action2 move
</code></pre>
<p>swaps the actions for button1 and button2. Setting pointer_action&lt; n &gt; to none disables that action.</p>
<p>Focus via mouse clicking is controlled by click_to_focus. It takes button1, button2, button3, any, or none. The default is button1 (left click focuses). For example, to focus windows with a middle-click:</p>
<pre><code class="language-bash">bspc config click_to_focus button2
</code></pre>
<p>The <code>swallow_first_click</code> flag (boolean) prevents the click event that focuses a window from being passed to the application. If true, clicking to focus will not (for example) click buttons in the newly focused window; this is useful if you want a click to only change focus.</p>
<p><strong>Pointer and focus warping:</strong> <code>focus_follows_pointer</code> (boolean) makes focus follow the mouse pointer; if enabled, simply moving the mouse over a window will focus it. Conversely, <code>pointer_follows_focus</code> (boolean) warps the pointer to the center of the newly focused window, and <code>pointer_follows_monitor</code> does the same for the newly focused monitor. These are all off by default, but can be turned on with e.g.:</p>
<pre><code class="language-bash">bspc config focus_follows_pointer true
bspc config pointer_follows_focus true
</code></pre>
<p><strong>In summary, the pointer settings let you pick a modifier key and mouse button actions to move/resize windows, and to configure click-to-focus and pointer warping behaviors.</strong></p>
<h3 id="ewmh-hints-and-miscellaneous"><a class="header" href="#ewmh-hints-and-miscellaneous">EWMH Hints and Miscellaneous</a></h3>
<p>Bspwm can ignore or honor certain EWMH hints (state requests from other applications) via these settings.</p>
<p><code>ignore_ewmh_focus</code> (boolean) ignores focus requests from EWMH-compliant clients. If true, external programs cannot change window focus.</p>
<p><code>ignore_ewmh_fullscreen</code> can be none, all, or a comma-separated list enter,exit. It blocks clients that try to put windows into fullscreen (setting the _NET_WM_STATE_FULLSCREEN hint). For example, bspc config ignore_ewmh_fullscreen all will prevent all EWMH fullscreen changes.</p>
<p><code>ignore_ewmh_struts</code> (boolean) ignores the EWMH strut hints that panels and docks use to reserve screen space. If you have an always-on-top panel, setting this to true makes bspwm ignore its struts (useful if your panel is external and you don’t want bspwm to avoid it).</p>
<p><code>center_pseudo_tiled</code> (boolean, defaults to true) determines whether pseudo-tiled windows (tiled windows that respect size hints) are centered in their area. For example, floating dialogs can be treated as pseudo-tiled; if true, bspwm will center them in their split. You can turn it off with bspc config center_pseudo_tiled false.</p>
<p><code>honor_size_hints</code> (boolean) tells bspwm to apply ICCCM size hints from applications. Enabling this makes bspwm honor the minimum/maximum size hints that some X programs request.</p>
<p><code>mapping_events_count</code> (integer) sets how many mapping notify events bspwm should process. By default it only handles one (focusing windows, etc.), but a negative value means “handle all.” This is a rare, low-level option usually left at 0 or 1.</p>
<blockquote class="blockquote-tag blockquote-tag-important">
<p class="blockquote-tag-title"><svg viewbox="0 0 16 16" width="18" height="18"><path d="M0 1.75C0 .784.784 0 1.75 0h12.5C15.216 0 16 .784 16 1.75v9.5A1.75 1.75 0 0 1 14.25 13H8.06l-2.573 2.573A1.458 1.458 0 0 1 3 14.543V13H1.75A1.75 1.75 0 0 1 0 11.25Zm1.75-.25a.25.25 0 0 0-.25.25v9.5c0 .138.112.25.25.25h2a.75.75 0 0 1 .75.75v2.19l2.72-2.72a.749.749 0 0 1 .53-.22h6.5a.25.25 0 0 0 .25-.25v-9.5a.25.25 0 0 0-.25-.25Zm7 2.25v2.5a.75.75 0 0 1-1.5 0v-2.5a.75.75 0 0 1 1.5 0ZM9 9a1 1 0 1 1-2 0 1 1 0 0 1 2 0Z"></path></svg>Important</p>
<p>These options govern how bspwm reacts to external hints or special windows. Use them to integrate bspwm with other desktop components (EWMH panels, fullscreen requests) or to tweak size-hint behavior.</p>
</blockquote>
<h3 id="monitor-and-desktop-settings"><a class="header" href="#monitor-and-desktop-settings">Monitor and Desktop Settings</a></h3>
<p>Padding at screen edges is controlled by the <code>top_padding</code>, <code>right_padding</code>, <code>bottom_padding</code>, and <code>left_padding</code> settings (monitor/desktop settings). These are pixel values added as empty space on each side of the screen or desktop. This is commonly used to leave room for panels or docks. For example, to leave a 24px gap at the top (e.g. for a status bar):</p>
<pre><code class="language-bash">bspc config top_padding 24
bspc config bottom_padding 0
bspc config left_padding 0
bspc config right_padding 0
</code></pre>
<p>With this, bspwm will tile windows below that 24px area.</p>
<p>Bspwm can also manage multiple monitors dynamically. The boolean flags remove_disabled_monitors, remove_unplugged_monitors, and merge_overlapping_monitors (all default false) adjust bspwm’s behavior on monitor changes. <strong>For instance, if you set bspc config remove_unplugged_monitors true, any monitor that is unplugged (e.g. a laptop lid closing) will be treated as disconnected and its desktops moved elsewhere. These are advanced options for multi-head setups</strong>.</p>
<h3 id="global-misc-settings"><a class="header" href="#global-misc-settings">Global Misc Settings</a></h3>
<p><strong>status_prefix:</strong> a string prefixed to each bspc event line (used in status scripts). For example, setting</p>
<pre><code class="language-bash">bspc config status_prefix "[bspwm] "
</code></pre>
<p>causes all window/desktop events sent to status bars to start with “ ”.</p>
<p><strong>external_rules_command:</strong> path to an external script that provides window rule assignments. If set, bspwm will call this command each time a new window appears, passing it the window’s ID, class, and instance, and expecting key=value outputs for rule keys (like split_ratio=0.7, desktop=2, etc.). For example:</p>
<pre><code class="language-bash">bspc config external_rules_command "$HOME/.config/bspwm/rules.sh"
</code></pre>
<p>where rules.sh might output something like center=on follow=on. This allows dynamic, programmatic control of window placement.</p>
<blockquote class="blockquote-tag blockquote-tag-note">
<p class="blockquote-tag-title"><svg viewbox="0 0 16 16" width="18" height="18"><path d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z"></path></svg>Note</p>
<p>These global options are less frequently changed, but status_prefix can help integrate bspwm with custom panels, and external_rules_command enables advanced window rule logic.</p>
</blockquote>
<h3 id="usage-examples"><a class="header" href="#usage-examples">Usage Examples</a></h3>
<p>Below is a sample snippet of a bspwmrc configuring several options (annotated for clarity):</p>
<pre><code class="language-bash">
# Set focused/unfocused border colors
bspc config focused_border_color "#3585ce"    # blue border for focused windows
bspc config normal_border_color "#444444"     # gray for others

# Set default split ratio and gaps
bspc config split_ratio 0.55                  # 55/45 split by default
bspc config window_gap 10                     # 10px gap between windows

# Monocle layout tweaks
bspc config borderless_monocle true           # no borders in monocle mode
bspc config top_monocle_padding 20            # 20px padding on top in monocle

# Pointer/mouse actions
bspc config pointer_modifier mod4             # use Super key for pointer actions
bspc config pointer_action3 none              # disable corner resize
bspc config click_to_focus any                # any click focuses window
bspc config swallow_first_click true         # do not forward the click event

# Automatic tiling scheme
bspc config automatic_scheme alternate        # alternate insert (default)
bspc config initial_polarity second_child     # new windows on second child by default

# Layout hints
bspc config focus_follows_pointer true        # focus on mouse-over
bspc config center_pseudo_tiled false        # disable centering pseudo-tiled

# Padding for panels
bspc config top_padding 30                   # leave 30px at top for panel
</code></pre>
<p>Each bspc config command above changes an aspect of bspwm’s layout or behavior, as documented. For a complete reference of all options and their meanings, see the bspwm manual (man page).</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="bspwm-interfaces-and-usage"><a class="header" href="#bspwm-interfaces-and-usage">Bspwm interfaces and usage</a></h1>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="writing-configs-using-bspc"><a href="#writing-configs-using-bspc" class="header">Writing configs using bspc</a></h1>
<h2 id="executive-summary"><a class="header" href="#executive-summary">Executive Summary</a></h2>
<p>This documentation provides an in-depth exploration of <strong>bspwm</strong> (Binary Space Partitioning Window Manager) configuration, derived entirely from authoritative web sources. BSPWM is a sophisticated tiling window manager that represents windows as leaves of a full binary tree, controlled entirely through the <strong>bspc</strong> command-line client. This guide comprehensively covers every flag, command-line option, configuration setting, and advanced technique required to create a highly sophisticated and customized BSPWM environment. The documentation is organized to progress from foundational concepts through complex configuration scenarios, with detailed explanations of each component extracted directly from official documentation and community resources.</p>
<h2 id="understanding-the-architecture-and-fundamental-concepts"><a class="header" href="#understanding-the-architecture-and-fundamental-concepts">Understanding the Architecture and Fundamental Concepts</a></h2>
<h3 id="the-binary-space-partitioning-model"><a class="header" href="#the-binary-space-partitioning-model">The Binary Space Partitioning Model</a></h3>
<p>BSPWM fundamentally operates differently from other tiling window managers through its binary tree architecture. Unlike traditional grid-based layouts, BSPWM represents windows as the leaves of a full binary tree, where each split divides the available space into exactly two nodes. This architectural choice provides exceptional flexibility for window arrangements and enables sophisticated manipulation of window layouts through tree operations. The window manager only responds to X11 events and messages received on a dedicated socket, which is handled exclusively through the <strong>bspc</strong> client.</p>
<h3 id="the-client-server-model"><a class="header" href="#the-client-server-model">The Client-Server Model</a></h3>
<p>The relationship between BSPWM and its control interface is built on a socket-based client-server model. BSPWM itself runs as a daemon and listens on a socket for messages from <strong>bspc</strong>, the command-line client that sends configuration commands and window management instructions. This separation provides exceptional modularity and allows complete configuration through shell scripts, making BSPWM exceptionally scriptable compared to window managers that require specialized configuration languages. The socket path, by default, follows the pattern <code>/tmp/bspwm&lt;hostname&gt;_&lt;display&gt;_&lt;screen&gt;-socket</code>, but can be customized through the <code>BSPWM_SOCKET</code> environment variable.</p>
<h3 id="configuration-file-structure"><a class="header" href="#configuration-file-structure">Configuration File Structure</a></h3>
<p>BSPWM configuration resides in a single shell script located at <code>$XDG_CONFIG_HOME/bspwm/bspwmrc</code>, which typically resolves to <code>~/.config/bspwm/bspwmrc</code>. This configuration file contains shell commands that invoke <strong>bspc</strong> to set up the window manager environment. The beauty of this approach lies in its simplicity: no special configuration language is required, and users can leverage any shell scripting capabilities to create dynamic, conditional configurations. When BSPWM starts, it executes this shell script, which should contain commands to start necessary daemons (like keyboard managers), set up monitors and desktops, configure display properties, and launch supporting applications.</p>
<h2 id="bspwm-command-structure-and-domains"><a class="header" href="#bspwm-command-structure-and-domains">BSPWM Command Structure and Domains</a></h2>
<h3 id="overview-of-the-bspc-command"><a class="header" href="#overview-of-the-bspc-command">Overview of the BSPC Command</a></h3>
<p>The <strong>bspc</strong> command functions as the exclusive interface to BSPWM, accepting a specific structure that organizes functionality into domains. The general syntax follows: <code>bspc DOMAIN [SELECTOR] COMMANDS</code>. This structure allows granular control over window manager behavior, from global settings to desktop-specific configurations to individual window manipulations. Understanding this hierarchical structure is essential for creating sophisticated configurations.</p>
<h3 id="available-domains-and-their-purposes"><a class="header" href="#available-domains-and-their-purposes">Available Domains and Their Purposes</a></h3>
<p>BSPWM organizes all functionality into six primary domains:</p>
<ol>
<li><strong>node</strong>: Controls individual window (node) operations</li>
<li><strong>desktop</strong>: Manages desktop/workspace-level settings</li>
<li><strong>monitor</strong>: Handles monitor-specific configurations</li>
<li><strong>query</strong>: Retrieves metadata and state information</li>
<li><strong>rule</strong>: Defines window matching and application rules</li>
<li><strong>wm</strong>: Controls global window manager states</li>
</ol>
<p>Additionally, specialized domains handle <strong>config</strong>, <strong>subscribe</strong>, and <strong>quit</strong> operations. The <strong>subscribe</strong> domain enables event-driven scripting, a powerful feature for creating dynamic window management behaviors.</p>
<h2 id="node-domain-individual-window-control"><a class="header" href="#node-domain-individual-window-control">Node Domain: Individual Window Control</a></h2>
<h3 id="node-specific-commands"><a class="header" href="#node-specific-commands">Node-Specific Commands</a></h3>
<p>The <strong>node</strong> domain manages individual windows (called nodes in BSPWM terminology). When no selector is provided, the command defaults to the focused node. All node operations follow the syntax: <code>bspc node [NODE_SEL] COMMAND</code>.</p>
<h4 id="focus-operations--f-and---focus"><a class="header" href="#focus-operations--f-and---focus">Focus Operations: <code>-f</code> and <code>--focus</code></a></h4>
<p>The <strong>-f</strong> or <strong>–focus</strong> flag changes focus to a specified node. When used alone, it focuses the selected node; when given a NODE_SEL argument, it focuses that specific node. For example:</p>
<ul>
<li><code>bspc node -f west</code> - Focus the window to the west</li>
<li><code>bspc node -f biggest</code> - Focus the largest window</li>
</ul>
<p>The focus command respects node selectors and modifiers, enabling complex selection patterns.</p>
<h4 id="activation--a-and---activate"><a class="header" href="#activation--a-and---activate">Activation: <code>-a</code> and <code>--activate</code></a></h4>
<p>The <strong>-a</strong> or <strong>–activate</strong> flag differs from focus by setting a node as active without necessarily giving it keyboard focus. This distinction is important in multi-monitor setups where you may want to highlight a window’s visual state independently of input focus. The activate command accepts an optional NODE_SEL parameter.</p>
<h4 id="desktop-transfer--d-and---to-desktop"><a class="header" href="#desktop-transfer--d-and---to-desktop">Desktop Transfer: <code>-d</code> and <code>--to-desktop</code></a></h4>
<p>The <strong>-d</strong> or <strong>–to-desktop</strong> flag sends a node to a specified desktop. The syntax is: <code>bspc node -d DESKTOP_SEL</code>. The optional <strong>–follow</strong> flag can be appended to maintain focus on the moved node after transfer. For example:</p>
<ul>
<li><code>bspc node -d '^2' --follow</code> - Move focused node to desktop 2 and maintain focus</li>
</ul>
<h4 id="monitor-transfer--m-and---to-monitor"><a class="header" href="#monitor-transfer--m-and---to-monitor">Monitor Transfer: <code>-m</code> and <code>--to-monitor</code></a></h4>
<p>The <strong>-m</strong> or <strong>–to-monitor</strong> flag transfers a node to a specified monitor. Syntax: <code>bspc node -m MONITOR_SEL</code>. The <strong>–follow</strong> flag similarly maintains focus after the transfer. This is particularly useful in multi-monitor setups for dynamically redistributing windows.</p>
<h4 id="node-to-node-transfer--n-and---to-node"><a class="header" href="#node-to-node-transfer--n-and---to-node">Node-to-Node Transfer: <code>-n</code> and <code>--to-node</code></a></h4>
<p>The <strong>-n</strong> or <strong>–to-node</strong> flag moves a node to become a sibling of another specified node. This powerful operation enables precise positioning within the binary tree structure. The <strong>–follow</strong> flag again allows focus to follow the transferred node. Example:</p>
<ul>
<li><code>bspc node -n newest.!automatic.local</code> - Move focused node to the newest preselected area</li>
</ul>
<h4 id="swapping-nodes--s-and---swap"><a class="header" href="#swapping-nodes--s-and---swap">Swapping Nodes: <code>-s</code> and <code>--swap</code></a></h4>
<p>The <strong>-s</strong> or <strong>–swap</strong> flag exchanges positions of two nodes in the tree, effectively swapping their visual positions and tiling spaces. The syntax is: <code>bspc node -s NODE_SEL</code>. The <strong>–follow</strong> flag moves focus to the swapped node’s new position. This differs from moving: the nodes exchange places rather than one replacing the other.</p>
<h4 id="preselection-direction--p-and---presel-dir"><a class="header" href="#preselection-direction--p-and---presel-dir">Preselection Direction: <code>-p</code> and <code>--presel-dir</code></a></h4>
<p>The <strong>-p</strong> or <strong>–presel-dir</strong> flag enables manual insertion mode by specifying where the next spawned window should appear relative to the current node. Valid directions are: <code>north</code>, <code>south</code>, <code>east</code>, <code>west</code>. Additionally, <code>~DIR</code> syntax cancels a preselection if it matches the specified direction. For example:</p>
<ul>
<li><code>bspc node -p east</code> - Next window spawns to the east of current node</li>
<li><code>bspc node -p ~east</code> - Cancel east preselection if currently active</li>
</ul>
<h4 id="preselection-ratio--o-and---presel-ratio"><a class="header" href="#preselection-ratio--o-and---presel-ratio">Preselection Ratio: <code>-o</code> and <code>--presel-ratio</code></a></h4>
<p>The <strong>-o</strong> or <strong>–presel-ratio</strong> flag sets the proportion of space allocated to the preselected area. The RATIO parameter must be between 0 and 1. For instance, <code>bspc node -o 0.4</code> allocates 40% of space to the preselected area and 60% to the existing content. This works in conjunction with preselection direction.</p>
<h4 id="node-movement--v-and---move"><a class="header" href="#node-movement--v-and---move">Node Movement: <code>-v</code> and <code>--move</code></a></h4>
<p>The <strong>-v</strong> or <strong>–move</strong> flag shifts a node’s position by pixel offsets. Syntax: <code>bspc node -v dx dy</code>. Both <strong>dx</strong> and <strong>dy</strong> are pixel values representing horizontal and vertical displacement. This command is particularly useful for floating windows, allowing pixel-perfect positioning adjustments.</p>
<h4 id="node-resizing--z-and---resize"><a class="header" href="#node-resizing--z-and---resize">Node Resizing: <code>-z</code> and <code>--resize</code></a></h4>
<p>The <strong>-z</strong> or <strong>–resize</strong> flag adjusts node dimensions by specifying an edge and pixel adjustments. Valid edges include: <code>top</code>, <code>left</code>, <code>bottom</code>, <code>right</code>, <code>top_left</code>, <code>top_right</code>, <code>bottom_right</code>, <code>bottom_left</code>. Syntax: <code>bspc node -z EDGE dx dy</code>. The <strong>dx</strong> and <strong>dy</strong> values represent horizontal and vertical pixel adjustments. For example:</p>
<ul>
<li><code>bspc node -z right 20 0</code> - Expand right edge by 20 pixels</li>
</ul>
<h4 id="node-typesplit-cycling--y-and---type"><a class="header" href="#node-typesplit-cycling--y-and---type">Node Type/Split Cycling: <code>-y</code> and <code>--type</code></a></h4>
<p>The <strong>-y</strong> or <strong>–type</strong> flag changes or cycles the split type of a node’s parent. Valid arguments are <code>horizontal</code>, <code>vertical</code>, or <code>next</code> to cycle between types. This operation rotates the tree’s splitting orientation. Example:</p>
<ul>
<li><code>bspc node -y next</code> - Toggle between horizontal and vertical splits</li>
</ul>
<h4 id="split-ratio-adjustment--r-and---ratio"><a class="header" href="#split-ratio-adjustment--r-and---ratio">Split Ratio Adjustment: <code>-r</code> and <code>--ratio</code></a></h4>
<p>The <strong>-r</strong> or <strong>–ratio</strong> flag modifies the split ratio of a node’s parent, controlling space distribution between siblings. Syntax: <code>bspc node -r RATIO</code> where RATIO is a decimal from 0-1, or <code>(+|-)(PIXELS|FRACTION)</code> for relative adjustments. For instance:</p>
<ul>
<li><code>bspc node -r 0.6</code> - Set split ratio to 60/40</li>
<li><code>bspc node -r +0.05</code> - Increase split ratio by 5%</li>
</ul>
<h4 id="tree-rotation--r-and---rotate"><a class="header" href="#tree-rotation--r-and---rotate">Tree Rotation: <code>-R</code> and <code>--rotate</code></a></h4>
<p>The <strong>-R</strong> or <strong>–rotate</strong> flag rotates the tree rooted at the selected node. Valid angles are: <code>90</code>, <code>270</code>, <code>180</code>. This operation is useful for dynamically rearranging window hierarchies. Example:</p>
<ul>
<li><code>bspc node -R 90</code> - Rotate tree 90 degrees clockwise</li>
</ul>
<h4 id="tree-flipping--f-and---flip"><a class="header" href="#tree-flipping--f-and---flip">Tree Flipping: <code>-F</code> and <code>--flip</code></a></h4>
<p>The <strong>-F</strong> or <strong>–flip</strong> flag flips the tree rooted at the selected node. Valid directions are: <code>horizontal</code>, <code>vertical</code>. This mirrors the tree structure along the specified axis. Example:</p>
<ul>
<li><code>bspc node -F horizontal</code> - Flip tree horizontally</li>
</ul>
<h4 id="tree-equalization--e-and---equalize"><a class="header" href="#tree-equalization--e-and---equalize">Tree Equalization: <code>-E</code> and <code>--equalize</code></a></h4>
<p>The <strong>-E</strong> or <strong>–equalize</strong> flag resets all split ratios within a node’s subtree to their default values (typically 0.5). This is useful for restoring a balanced layout after manual ratio adjustments.</p>
<h4 id="tree-balancing--b-and---balance"><a class="header" href="#tree-balancing--b-and---balance">Tree Balancing: <code>-B</code> and <code>--balance</code></a></h4>
<p>The <strong>-B</strong> or <strong>–balance</strong> flag adjusts split ratios within a subtree so all leaves occupy equal area. Unlike equalization, which resets all ratios identically, balancing respects the existing tree structure while equalizing final window areas.</p>
<h4 id="tree-circulation--c-and---circulate"><a class="header" href="#tree-circulation--c-and---circulate">Tree Circulation: <code>-C</code> and <code>--circulate</code></a></h4>
<p>The <strong>-C</strong> or <strong>–circulate</strong> flag moves windows within a tree in a circular pattern. Valid directions are: <code>forward</code>, <code>backward</code>. This operation is particularly useful for dynamic window rotation without explicit swapping.</p>
<h4 id="node-state--t-and---state"><a class="header" href="#node-state--t-and---state">Node State: <code>-t</code> and <code>--state</code></a></h4>
<p>The <strong>-t</strong> or <strong>–state</strong> flag changes a node’s state (tiling mode). Valid states are: <code>tiled</code>, <code>pseudo_tiled</code>, <code>floating</code>, <code>fullscreen</code>. The <code>~</code> prefix toggles to the previous state if the current state matches, or restores the previous state if no state is specified. Syntax: <code>bspc node -t STATE</code>. Examples:</p>
<ul>
<li><code>bspc node -t floating</code> - Make window floating</li>
<li><code>bspc node -t ~floating</code> - Toggle floating state</li>
</ul>
<h4 id="node-flags--g-and---flag"><a class="header" href="#node-flags--g-and---flag">Node Flags: <code>-g</code> and <code>--flag</code></a></h4>
<p>The <strong>-g</strong> or <strong>–flag</strong> flag manages binary flags that modify node behavior. Valid flags are: <code>hidden</code>, <code>sticky</code>, <code>private</code>, <code>locked</code>, <code>marked</code>, <code>urgent</code>. The flag syntax accepts optional <code>=on|off</code> to explicitly set state. Each flag serves a specific purpose:</p>
<ul>
<li><strong>hidden</strong>: Node is hidden and doesn’t occupy tiling space</li>
<li><strong>sticky</strong>: Node stays on the focused desktop of its monitor</li>
<li><strong>private</strong>: Node resists movement and resizing during automatic insertion</li>
<li><strong>locked</strong>: Node ignores the close (<code>-c</code>) message</li>
<li><strong>marked</strong>: Arbitrary flag used for custom operations; unmarked automatically when sent to a preselected node</li>
<li><strong>urgent</strong>: Indicates window urgency (typically set externally); used for window selection</li>
</ul>
<p>Examples:</p>
<ul>
<li><code>bspc node -g sticky=on</code> - Make window sticky</li>
<li><code>bspc node -g marked</code> - Toggle marked flag</li>
</ul>
<h4 id="node-layering--l-and---layer"><a class="header" href="#node-layering--l-and---layer">Node Layering: <code>-l</code> and <code>--layer</code></a></h4>
<p>The <strong>-l</strong> or <strong>–layer</strong> flag changes a node’s stacking layer. Valid layers are: <code>below</code>, <code>normal</code>, <code>above</code>. BSPWM maintains three stacking layers where below &lt; normal &lt; above, and within each layer: tiled/pseudo_tiled &lt; floating &lt; fullscreen. Examples:</p>
<ul>
<li><code>bspc node -l above</code> - Place window above all others</li>
<li><code>bspc node -l below</code> - Place window below all others</li>
</ul>
<h4 id="receptacle-insertion--i-and---insert-receptacle"><a class="header" href="#receptacle-insertion--i-and---insert-receptacle">Receptacle Insertion: <code>-i</code> and <code>--insert-receptacle</code></a></h4>
<p>The <strong>-i</strong> or <code>--insert-receptacle</code> flag creates a receptacle (empty leaf node) at the selected node’s position. Receptacles are particularly useful for creating predefined layouts that can be filled with windows later.</p>
<h4 id="node-closure--c-and---close"><a class="header" href="#node-closure--c-and---close">Node Closure: <code>-c</code> and <code>--close</code></a></h4>
<p>The <strong>-c</strong> or <strong>–close</strong> flag closes a node by sending it the close message. This respects the <code>locked</code> flag; if set, the message is ignored.</p>
<h4 id="node-termination--k-and-kill"><a class="header" href="#node-termination--k-and-kill">Node Termination: <code>-k</code> and <strong>–kill</strong></a></h4>
<p>The <strong>-k</strong> or <strong>–kill</strong> flag forcibly terminates a node’s window regardless of flags or settings. This is a hard termination that bypasses all safety mechanisms.</p>
<h3 id="node-selector-syntax"><a class="header" href="#node-selector-syntax">Node Selector Syntax</a></h3>
<p>Node selectors determine which nodes are affected by commands. They follow the pattern: <code>[REFERENCE#]DESCRIPTOR[.MODIFIER]*</code>.</p>
<h4 id="node-descriptors"><a class="header" href="#node-descriptors">Node Descriptors</a></h4>
<p>Descriptors specify the initial node selection:</p>
<ul>
<li><strong>DIR</strong> (north|west|south|east): Relative direction</li>
<li><strong>CYCLE_DIR</strong> (next|prev): Cyclic direction</li>
<li><strong>any</strong>: Any node</li>
<li><strong>first_ancestor</strong>: First non-leaf ancestor</li>
<li><strong>last</strong>: Most recently focused</li>
<li><strong>newest</strong>: Most recently created</li>
<li><strong>older</strong>: Older than focused in history</li>
<li><strong>newer</strong>: Newer than focused in history</li>
<li><strong>focused</strong>: Currently focused node</li>
<li><strong>pointed</strong>: Node under mouse pointer</li>
<li><strong>biggest</strong>: Largest node by area</li>
<li><strong>smallest</strong>: Smallest node by area</li>
<li><strong>&lt;node_id&gt;</strong>: Direct node ID reference</li>
</ul>
<h4 id="node-modifiers"><a class="header" href="#node-modifiers">Node Modifiers</a></h4>
<p>Modifiers further filter the selection:</p>
<ul>
<li><strong>[!]focused</strong>: Currently/not currently focused</li>
<li><strong>[!]active</strong>: Active/not active on desktop</li>
<li><strong>[!]automatic</strong>: In automatic/manual insertion mode</li>
<li><strong>[!]local</strong>: On/not on current desktop</li>
<li><strong>[!]leaf</strong>: Is/isn’t a leaf node</li>
<li><strong>[!]window</strong>: Has/doesn’t have a window</li>
<li><strong>[!]STATE</strong>: Matches/doesn’t match state (tiled|pseudo_tiled|floating|fullscreen)</li>
<li><strong>[!]FLAG</strong>: Has/doesn’t have flag (hidden|sticky|private|locked|marked|urgent)</li>
<li><strong>[!]LAYER</strong>: On/not on layer (below|normal|above)</li>
<li><strong>[!]SPLIT_TYPE</strong>: Split type (horizontal|vertical)</li>
<li><strong>[!]same_class</strong>: Same/different class as focused</li>
<li><strong>[!]descendant_of</strong>: Is/isn’t descendant of reference</li>
<li><strong>[!]ancestor_of</strong>: Is/isn’t ancestor of reference</li>
</ul>
<h4 id="path-jumps"><a class="header" href="#path-jumps">Path Jumps</a></h4>
<p>Path jumps navigate the tree structure:</p>
<ul>
<li><strong>first|1</strong>: First child</li>
<li><strong>second|2</strong>: Second child</li>
<li><strong>brother</strong>: Sibling node</li>
<li><strong>parent</strong>: Parent node</li>
<li><strong>DIR</strong>: Directional jump</li>
</ul>
<h2 id="desktop-domain-workspace-management"><a class="header" href="#desktop-domain-workspace-management">Desktop Domain: Workspace Management</a></h2>
<h3 id="desktop-specific-commands"><a class="header" href="#desktop-specific-commands">Desktop-Specific Commands</a></h3>
<p>The <strong>desktop</strong> domain manages workspace-level settings and operations. Syntax: <code>bspc desktop [DESKTOP_SEL] COMMAND</code>. If no DESKTOP_SEL is provided, the focused desktop is targeted.</p>
<h4 id="desktop-focus--f-and---focus"><a class="header" href="#desktop-focus--f-and---focus">Desktop Focus: <code>-f</code> and <code>--focus</code></a></h4>
<p>The <strong>-f</strong> or <strong>–focus</strong> flag switches focus to a specified desktop. Example:</p>
<ul>
<li><code>bspc desktop -f '^2'</code> - Focus the 2nd desktop</li>
<li><code>bspc desktop -f next</code> - Focus next desktop</li>
</ul>
<h4 id="desktop-activation--a-and---activate"><a class="header" href="#desktop-activation--a-and---activate">Desktop Activation: <code>-a</code> and <code>--activate</code></a></h4>
<p>The <strong>-a</strong> or <strong>–activate</strong> flag sets a desktop as active (similar to node activation). This is distinct from focus and is useful in multi-monitor scenarios.</p>
<h4 id="desktop-transfer-to-monitor--m-and---to-monitor"><a class="header" href="#desktop-transfer-to-monitor--m-and---to-monitor">Desktop Transfer to Monitor: <code>-m</code> and <code>--to-monitor</code></a></h4>
<p>The <strong>-m</strong> or <code>--to-monitor</code> flag transfers a desktop to a different monitor. Syntax: <code>bspc desktop -m MONITOR_SEL</code>. The optional <strong>–follow</strong> flag moves focus to the transferred desktop.</p>
<h4 id="desktop-swapping--s-and---swap"><a class="header" href="#desktop-swapping--s-and---swap">Desktop Swapping: <code>-s</code> and <code>--swap</code></a></h4>
<p>The <strong>-s</strong> or <strong>–swap</strong> flag exchanges two desktops. Syntax: <code>bspc desktop -s DESKTOP_SEL</code>. The <strong>–follow</strong> flag maintains focus continuity.</p>
<h4 id="layout-selection--l-and---layout"><a class="header" href="#layout-selection--l-and---layout">Layout Selection: <code>-l</code> and <code>--layout</code></a></h4>
<p>The <strong>-l</strong> or <code>--layout</code> flag sets or cycles the desktop’s layout. Valid layouts are: <code>tiled</code>, <code>monocle</code>, or <code>next</code> to cycle. BSPWM provides two built-in layouts:</p>
<ul>
<li><strong>tiled</strong>: Standard binary space partitioning with visible splits</li>
<li><strong>monocle</strong>: Fullscreen layout where only the most recently focused tiled/pseudo_tiled window is visible</li>
</ul>
<p>Examples:</p>
<ul>
<li><code>bspc desktop -l monocle</code> - Switch to monocle layout</li>
<li><code>bspc desktop -l next</code> - Cycle to next layout</li>
</ul>
<h4 id="desktop-renaming--n-and---rename"><a class="header" href="#desktop-renaming--n-and---rename">Desktop Renaming: <code>-n</code> and <code>--rename</code></a></h4>
<p>The <strong>-n</strong> or <code>--rename</code> flag changes a desktop’s name. Syntax: <code>bspc desktop -n &lt;new_name&gt;</code>. Desktop names are used in keybindings and configurations.</p>
<h4 id="desktop-cycling--b-and---bubble"><a class="header" href="#desktop-cycling--b-and---bubble">Desktop Cycling: <code>-b</code> and <code>--bubble</code></a></h4>
<p>The <strong>-b</strong> or <code>--bubble</code> flag moves a desktop within the monitor’s desktop list. Direction values are <code>next</code> or <code>prev</code>. This reorders desktops without changing their content.</p>
<h4 id="desktop-removal--r-and-remove"><a class="header" href="#desktop-removal--r-and-remove">Desktop Removal: <code>-r</code> and `–remove**</a></h4>
<p>The <strong>-r</strong> or <code>--remove</code> flag deletes a desktop. Windows on the removed desktop are transferred to the next available desktop.</p>
<h3 id="desktop-selector-syntax"><a class="header" href="#desktop-selector-syntax">Desktop Selector Syntax</a></h3>
<p>Desktop selectors determine which desktops are affected.</p>
<h4 id="desktop-descriptors"><a class="header" href="#desktop-descriptors">Desktop Descriptors</a></h4>
<ul>
<li><strong>CYCLE_DIR</strong> (next|prev): Cyclic direction</li>
<li><strong>any</strong>: Any desktop</li>
<li><strong>last</strong>: Most recently focused</li>
<li><strong>newest</strong>: Most recently created</li>
<li><strong>older</strong>: Older in history</li>
<li><strong>newer</strong>: Newer in history</li>
<li><strong>focused</strong>: Currently focused</li>
<li><strong>^&lt; n &gt;</strong>: The nth desktop</li>
<li><strong>MONITOR_SEL:focused</strong>: Focused desktop on specified monitor</li>
<li><strong>&lt;desktop_id&gt;</strong>: Direct ID reference</li>
<li><strong>&lt;desktop_name&gt;</strong>: By name</li>
</ul>
<h4 id="desktop-modifiers"><a class="header" href="#desktop-modifiers">Desktop Modifiers</a></h4>
<ul>
<li><strong>[!]focused</strong>: Currently/not focused</li>
<li><strong>[!]active</strong>: Active/not active on desktop</li>
<li><strong>[!]occupied</strong>: Has/doesn’t have windows</li>
<li><strong>[!]urgent</strong>: Contains/doesn’t contain urgent windows</li>
<li><strong>[!]local</strong>: On/not on current monitor</li>
<li><strong>[!]LAYOUT</strong>: Matches/doesn’t match layout</li>
<li><strong>[!]user_LAYOUT</strong>: Custom layout matching</li>
</ul>
<h2 id="monitor-domain-multi-monitor-configuration"><a class="header" href="#monitor-domain-multi-monitor-configuration">Monitor Domain: Multi-Monitor Configuration</a></h2>
<h3 id="monitor-specific-commands"><a class="header" href="#monitor-specific-commands">Monitor-Specific Commands</a></h3>
<p>The <strong>monitor</strong> domain controls monitor-specific settings and operations. Syntax: <code>bspc monitor [MONITOR_SEL] COMMAND</code>.</p>
<h4 id="monitor-focus--f-and---focus"><a class="header" href="#monitor-focus--f-and---focus">Monitor Focus: <code>-f</code> and <code>--focus</code></a></h4>
<p>The <strong>-f</strong> or <code>--focus</code> flag switches focus to a specified monitor. Example:</p>
<ul>
<li><code>bspc monitor -f DP-1</code> - Focus monitor named DP-1</li>
<li><code>bspc monitor -f next</code> - Focus next monitor</li>
</ul>
<h4 id="monitor-swapping--s-and---swap"><a class="header" href="#monitor-swapping--s-and---swap">Monitor Swapping: <code>-s</code> and <code>--swap</code></a></h4>
<p>The <strong>-s</strong> or <code>--swap</code> flag exchanges two monitors. This is useful for reversing display order.</p>
<h4 id="add-desktops--a-and---add-desktops"><a class="header" href="#add-desktops--a-and---add-desktops">Add Desktops: <code>-a</code> and <code>--add-desktops</code></a></h4>
<p>The <strong>-a</strong> or <code>--add-desktops</code> flag creates new desktops on a monitor. Syntax: <code>bspc monitor -a &lt;name&gt;...</code>. Multiple desktop names can be provided. Example:</p>
<ul>
<li><code>bspc monitor -a I II III IV V</code> - Create five desktops named I through V</li>
</ul>
<h4 id="reorder-desktops--o-and---reorder-desktops"><a class="header" href="#reorder-desktops--o-and---reorder-desktops">Reorder Desktops: <code>-o</code> and <code>--reorder-desktops</code></a></h4>
<p>The <strong>-o</strong> or <code>--reorder-desktops</code> flag changes the order of desktops on a monitor. Syntax: <code>bspc monitor -o &lt;name&gt;...</code>. The order must match existing desktop names.</p>
<h4 id="reset-desktops--d-and---reset-desktops"><a class="header" href="#reset-desktops--d-and---reset-desktops">Reset Desktops: <code>-d</code> and <code>--reset-desktops</code></a></h4>
<p>The <strong>-d</strong> or <code>--reset-desktops</code> flag reconfigures desktops, adding, removing, or renaming as needed. Syntax: <code>bspc monitor -d &lt;name&gt;...</code>. This command automatically handles all necessary adjustments.</p>
<h4 id="monitor-rectangle--g-and---rectangle"><a class="header" href="#monitor-rectangle--g-and---rectangle">Monitor Rectangle: <code>-g</code> and <code>--rectangle</code></a></h4>
<p>The <strong>-g</strong> or <code>--rectangle</code> flag manually sets monitor geometry. Syntax: <code>bspc monitor -g WxH+X+Y</code>. This is useful for multi-display configurations or unusual setups.</p>
<h4 id="monitor-renaming--n-and---rename"><a class="header" href="#monitor-renaming--n-and---rename">Monitor Renaming: <code>-n</code> and <code>--rename</code></a></h4>
<p>The <strong>-n</strong> or <code>--rename</code> flag changes a monitor’s name. Syntax: <code>bspc monitor -n &lt;new_name&gt;</code>.</p>
<h4 id="monitor-removal--r-and---remove"><a class="header" href="#monitor-removal--r-and---remove">Monitor Removal: <code>-r</code> and <code>--remove</code></a></h4>
<p>The <strong>-r</strong> or <code>--remove</code> flag removes a monitor from management. Desktops on the removed monitor are transferred to remaining monitors.</p>
<h3 id="monitor-selector-syntax"><a class="header" href="#monitor-selector-syntax">Monitor Selector Syntax</a></h3>
<p>Monitor selectors determine which monitors are affected.</p>
<h4 id="monitor-descriptors"><a class="header" href="#monitor-descriptors">Monitor Descriptors</a></h4>
<ul>
<li><strong>DIR</strong> (north|west|south|east): Spatial direction</li>
<li><strong>CYCLE_DIR</strong> (next|prev): Cyclic direction</li>
<li><strong>any</strong>: Any monitor</li>
<li><strong>last</strong>: Most recently focused</li>
<li><strong>newest</strong>: Most recently added</li>
<li><strong>older</strong>: Older in history</li>
<li><strong>newer</strong>: Newer in history</li>
<li><strong>focused</strong>: Currently focused</li>
<li><strong>pointed</strong>: Monitor under pointer</li>
<li><strong>primary</strong>: Primary monitor</li>
<li><strong>^&lt; n &gt;</strong>: The nth monitor</li>
<li><strong>&lt;monitor_id&gt;</strong>: By monitor ID</li>
<li><strong>&lt;monitor_name&gt;</strong>: By name (e.g., HDMI-1)</li>
</ul>
<h4 id="monitor-modifiers"><a class="header" href="#monitor-modifiers">Monitor Modifiers</a></h4>
<ul>
<li><strong>[!]focused</strong>: Currently/not focused</li>
<li><strong>[!]occupied</strong>: Has/doesn’t have occupied desktops</li>
</ul>
<h2 id="query-domain-state-information-retrieval"><a class="header" href="#query-domain-state-information-retrieval">Query Domain: State Information Retrieval</a></h2>
<h3 id="query-commands"><a class="header" href="#query-commands">Query Commands</a></h3>
<p>The <strong>query</strong> domain retrieves metadata and state information. Syntax: <code>bspc query COMMANDS [OPTIONS]</code>.</p>
<h4 id="node-query--n-and---nodes"><a class="header" href="#node-query--n-and---nodes">Node Query: <code>-N</code> and <code>--nodes</code></a></h4>
<p>The <strong>-N</strong> or <code>--nodes</code> flag returns node IDs. Syntax: <code>bspc query -N [NODE_SEL]</code>. Without selectors, returns all node IDs. With selectors, returns matching nodes. Example:</p>
<ul>
<li><code>bspc query -N -n focused</code> - Get ID of focused node</li>
<li><code>bspc query -N -n .window</code> - Get IDs of all window nodes</li>
</ul>
<h4 id="desktop-query--d-and---desktops"><a class="header" href="#desktop-query--d-and---desktops">Desktop Query: <code>-D</code> and <code>--desktops</code></a></h4>
<p>The <strong>-D</strong> or <code>--desktops</code> flag returns desktop IDs. Syntax: <code>bspc query -D [DESKTOP_SEL]</code>. Returns all desktop IDs when no selector is given.</p>
<h4 id="monitor-query--m-and---monitors"><a class="header" href="#monitor-query--m-and---monitors">Monitor Query: <code>-M</code> and <code>--monitors</code></a></h4>
<p>The <strong>-M</strong> or <code>--monitors</code> flag returns monitor IDs. Syntax: <code>bspc query -M [MONITOR_SEL]</code>. Returns all monitor IDs without selector.</p>
<h4 id="tree-query--t-and---tree"><a class="header" href="#tree-query--t-and---tree">Tree Query: <code>-T</code> and <code>--tree</code></a></h4>
<p>The <strong>-T</strong> or <code>--tree</code> flag returns the complete tree structure in JSON or text format. This comprehensive output shows all relationships and states. Example:</p>
<ul>
<li><code>bspc query -T</code> - Output complete tree state</li>
<li><code>bspc query -T -m DP-1</code> - Tree for specific monitor</li>
</ul>
<h3 id="query-options"><a class="header" href="#query-options">Query Options</a></h3>
<p>Query results can be filtered and formatted.</p>
<h4 id="monitor-specification--m-and---monitor"><a class="header" href="#monitor-specification--m-and---monitor">Monitor Specification: <code>-m</code> and <code>--monitor</code></a></h4>
<p>The <strong>-m</strong> or <code>--monitor</code> option filters results to a specific monitor. Syntax: <code>bspc query -m MONITOR_SEL</code>.</p>
<h4 id="desktop-specification--d-and---desktop"><a class="header" href="#desktop-specification--d-and---desktop">Desktop Specification: <code>-d</code> and <code>--desktop</code></a></h4>
<p>The <strong>-d</strong> or <code>--desktop</code> option filters to a specific desktop. Syntax: <code>bspc query -d DESKTOP_SEL</code>.</p>
<h4 id="node-specification--n-and---node"><a class="header" href="#node-specification--n-and---node">Node Specification: <code>-n</code> and <code>--node</code></a></h4>
<p>The <strong>-n</strong> or <code>--node</code> option filters to a specific node. Syntax: <code>bspc query -n NODE_SEL</code>.</p>
<h4 id="names-output---names"><a class="header" href="#names-output---names">Names Output: <code>--names</code></a></h4>
<p>The <code>--names</code> flag outputs entity names instead of IDs. This is useful for human-readable output.</p>
<h2 id="rule-domain-window-matching-and-defaults"><a class="header" href="#rule-domain-window-matching-and-defaults">Rule Domain: Window Matching and Defaults</a></h2>
<h3 id="rule-management-commands"><a class="header" href="#rule-management-commands">Rule Management Commands</a></h3>
<p>The <strong>rule</strong> domain defines patterns and default configurations for new windows.</p>
<h4 id="adding-rules--a-and---add"><a class="header" href="#adding-rules--a-and---add">Adding Rules: <code>-a</code> and <code>--add</code></a></h4>
<p>The <strong>-a</strong> or <code>--add</code> flag creates a new rule. Syntax: <code>bspc rule -a [CLASS[:INSTANCE[:NAME]]] [options]</code>. The class, instance, and name can be wildcards using <code>*</code>. Fields can be escaped with backslash.</p>
<p>Rule properties include:</p>
<ul>
<li><strong>monitor=MONITOR_SEL</strong>: Target monitor</li>
<li><strong>desktop=DESKTOP_SEL</strong>: Target desktop</li>
<li><strong>node=NODE_SEL</strong>: Target node (for insertion)</li>
<li><strong>state=STATE</strong>: Initial state (tiled|pseudo_tiled|floating|fullscreen)</li>
<li><strong>layer=LAYER</strong>: Initial layer (below|normal|above)</li>
<li><strong>honor_size_hints=(true|false|tiled|floating)</strong>: Whether to respect ICCCM size hints</li>
<li><strong>split_dir=DIR</strong>: Preselection direction</li>
<li><strong>split_ratio=RATIO</strong>: Preselection ratio</li>
<li><strong>hidden=(on|off)</strong>: Initially hidden state</li>
<li><strong>sticky=(on|off)</strong>: Sticky flag state</li>
<li><strong>private=(on|off)</strong>: Private flag state</li>
<li><strong>locked=(on|off)</strong>: Locked flag state</li>
<li><strong>marked=(on|off)</strong>: Marked flag state</li>
<li><strong>center=(on|off)</strong>: Center floating windows</li>
<li><strong>follow=(on|off)</strong>: Focus follows window</li>
<li><strong>manage=(on|off)</strong>: Whether window is managed</li>
<li><strong>focus=(on|off)</strong>: Initial focus state</li>
<li><strong>border=(on|off)</strong>: Show window borders</li>
<li><strong>rectangle=WxH+X+Y</strong>: Initial geometry for floating windows</li>
</ul>
<p>The <strong>-o</strong> or <code>--one-shot</code> flag makes the rule apply only once.</p>
<p>Examples:</p>
<ul>
<li><code>bspc rule -a Firefox desktop=^2 follow=on</code></li>
<li><code>bspc rule -a Gimp state=floating follow=off</code></li>
</ul>
<h4 id="removing-rules--r-and---remove"><a class="header" href="#removing-rules--r-and---remove">Removing Rules: <code>-r</code> and <code>--remove</code></a></h4>
<p>The <strong>-r</strong> or <code>--remove</code> flag deletes rules. Syntax: <code>bspc rule -r PATTERN</code>. Patterns can be <code>head</code>, <code>tail</code>, <code>^&lt; n &gt;</code> for index, or a class/instance/name pattern.</p>
<h4 id="listing-rules--l-and---list"><a class="header" href="#listing-rules--l-and---list">Listing Rules: <code>-l</code> and <code>--list</code></a></h4>
<p>The <strong>-l</strong> or <code>--list</code> flag displays all currently active rules.</p>
<h3 id="external-rules-script"><a class="header" href="#external-rules-script">External Rules Script</a></h3>
<p>For complex matching logic beyond the built-in rule syntax, BSPWM supports external rule scripts. The <strong>external_rules_command</strong> setting specifies a script path. This script receives window information and outputs rule properties.</p>
<p>Script invocation: <code>SCRIPT wid class instance name</code></p>
<p>Example external rules script:</p>
<pre><code class="language-bash">#!/bin/sh
case "$2" in
    Firefox)
        echo "desktop=^2 follow=on"
        ;;
    Gimp)
        echo "state=floating"
        ;;
esac
</code></pre>
<h2 id="config-domain-global-configuration"><a class="header" href="#config-domain-global-configuration">Config Domain: Global Configuration</a></h2>
<h3 id="configuration-settings"><a class="header" href="#configuration-settings">Configuration Settings</a></h3>
<p>The <strong>config</strong> domain manages global, monitor-specific, desktop-specific, and node-specific settings.</p>
<h4 id="general-syntax"><a class="header" href="#general-syntax">General Syntax</a></h4>
<p><code>bspc config [-m MONITOR_SEL|-d DESKTOP_SEL|-n NODE_SEL] &lt;setting&gt; [&lt;value&gt;]</code></p>
<h3 id="global-settings"><a class="header" href="#global-settings">Global Settings</a></h3>
<h4 id="color-settings"><a class="header" href="#color-settings">Color Settings</a></h4>
<p>Colors are specified in hexadecimal format: <code>#RRGGBB</code></p>
<ul>
<li><strong>normal_border_color</strong>: Border color for unfocused windows</li>
<li><strong>active_border_color</strong>: Border color for active (desktop-focused) windows</li>
<li><strong>focused_border_color</strong>: Border color for focused windows</li>
<li><strong>presel_feedback_color</strong>: Color of preselection indicator</li>
</ul>
<h4 id="layout-and-splitting"><a class="header" href="#layout-and-splitting">Layout and Splitting</a></h4>
<ul>
<li><strong>split_ratio</strong>: Default ratio for binary splits (0 &lt; ratio &lt; 1)</li>
<li><strong>automatic_scheme</strong>: Algorithm for automatic window placement. Valid values:
<ul>
<li><strong>longest_side</strong>: Split along longest edge</li>
<li><strong>alternate</strong>: Alternate between horizontal and vertical</li>
<li><strong>spiral</strong>: Create spiral patterns</li>
</ul>
</li>
<li><strong>initial_polarity</strong>: Which child receives the new window in automatic mode. Valid values:
<ul>
<li><strong>first_child</strong>: New window becomes first child</li>
<li><strong>second_child</strong>: New window becomes second child</li>
</ul>
</li>
<li><strong>directional_focus_tightness</strong>: Strictness of directional focus algorithm. Valid values:
<ul>
<li><strong>high</strong>: Stricter matching</li>
<li><strong>low</strong>: Looser matching</li>
</ul>
</li>
</ul>
<h4 id="insertion-and-removal"><a class="header" href="#insertion-and-removal">Insertion and Removal</a></h4>
<ul>
<li><strong>removal_adjustment</strong>: Whether to readjust layout after window removal</li>
<li><strong>presel_feedback</strong>: Whether to show preselection feedback</li>
</ul>
<h4 id="monocle-layout"><a class="header" href="#monocle-layout">Monocle Layout</a></h4>
<ul>
<li><strong>borderless_monocle</strong>: Remove borders in monocle layout</li>
<li><strong>gapless_monocle</strong>: Remove gaps in monocle layout</li>
<li><strong>top_monocle_padding</strong>, <strong>right_monocle_padding</strong>, <strong>bottom_monocle_padding</strong>, <strong>left_monocle_padding</strong>: Padding for monocle layout</li>
<li><strong>single_monocle</strong>: Switch to monocle if only one window remains</li>
</ul>
<h4 id="status-and-behavior"><a class="header" href="#status-and-behavior">Status and Behavior</a></h4>
<ul>
<li><strong>borderless_singleton</strong>: Remove borders when only one window exists</li>
<li><strong>status_prefix</strong>: Prefix for status messages</li>
<li><strong>pointer_motion_interval</strong>: Minimum milliseconds between pointer motion updates</li>
<li><strong>pointer_modifier</strong>: Keyboard modifier for pointer actions. Valid values:
<ul>
<li><strong>shift</strong>, <strong>control</strong>, <strong>lock</strong></li>
<li><strong>mod1</strong> (Alt), <strong>mod2</strong>, <strong>mod3</strong></li>
<li><strong>mod4</strong> (Super), <strong>mod5</strong></li>
</ul>
</li>
<li><strong>pointer_action1</strong>, <strong>pointer_action2</strong>, <strong>pointer_action3</strong>: Mouse button actions. Valid values:
<ul>
<li><strong>move</strong>: Move floating windows</li>
<li><strong>resize_side</strong>: Resize from edge</li>
<li><strong>resize_corner</strong>: Resize from corner</li>
<li><strong>focus</strong>: Focus on click</li>
<li><strong>none</strong>: No action</li>
</ul>
</li>
<li><strong>click_to_focus</strong>: Mouse button for focus-on-click. Valid values: <strong>button1</strong>, <strong>button2</strong>, <strong>button3</strong>, <strong>any</strong>, <strong>none</strong></li>
<li><strong>swallow_first_click</strong>: Consume first click when focusing</li>
<li><strong>focus_follows_pointer</strong>: Focus window under pointer</li>
<li><strong>pointer_follows_focus</strong>: Move pointer to focused window</li>
<li><strong>pointer_follows_monitor</strong>: Move pointer to focused monitor</li>
</ul>
<h4 id="ewmh-compatibility"><a class="header" href="#ewmh-compatibility">EWMH Compatibility</a></h4>
<ul>
<li><strong>mapping_events_count</strong>: How many mapping events to process</li>
<li><strong>ignore_ewmh_focus</strong>: Ignore EWMH focus requests</li>
<li><strong>ignore_ewmh_fullscreen</strong>: Ignore fullscreen requests. Valid values: <strong>none</strong>, <strong>all</strong>, or comma-separated <strong>enter</strong>, <strong>exit</strong></li>
<li><strong>ignore_ewmh_struts</strong>: Ignore taskbar/panel space reservations</li>
<li><strong>center_pseudo_tiled</strong>: Center pseudo_tiled windows</li>
</ul>
<h4 id="monitor-management"><a class="header" href="#monitor-management">Monitor Management</a></h4>
<ul>
<li><strong>remove_disabled_monitors</strong>: Remove monitors that are disabled</li>
<li><strong>remove_unplugged_monitors</strong>: Remove unplugged monitors</li>
<li><strong>merge_overlapping_monitors</strong>: Merge monitors with overlapping geometry</li>
</ul>
<h3 id="monitor-and-desktop-settings-1"><a class="header" href="#monitor-and-desktop-settings-1">Monitor and Desktop Settings</a></h3>
<h4 id="padding"><a class="header" href="#padding">Padding</a></h4>
<p>Applied at monitor and desktop levels:</p>
<ul>
<li><strong>top_padding</strong>, <strong>right_padding</strong>, <strong>bottom_padding</strong>, <strong>left_padding</strong>: Space reserved around the desktop edges. Commonly set to bar heights</li>
</ul>
<h3 id="desktop-settings"><a class="header" href="#desktop-settings">Desktop Settings</a></h3>
<h4 id="window-gap"><a class="header" href="#window-gap">Window Gap</a></h4>
<ul>
<li><strong>window_gap</strong>: Pixel spacing between windows. Can be set negative to create gapless layouts</li>
</ul>
<h3 id="node-settings"><a class="header" href="#node-settings">Node Settings</a></h3>
<h4 id="borders-and-hints"><a class="header" href="#borders-and-hints">Borders and Hints</a></h4>
<ul>
<li><strong>border_width</strong>: Border thickness in pixels</li>
<li><strong>honor_size_hints</strong>: Respect ICCCM window size hints. Valid values:
<ul>
<li><strong>true</strong>: Apply to all windows</li>
<li><strong>false</strong>: Don’t apply</li>
<li><strong>tiled</strong>: Apply only to tiled windows</li>
<li><strong>floating</strong>: Apply only to floating windows</li>
</ul>
</li>
</ul>
<h2 id="subscribe-domain-event-driven-scripting"><a class="header" href="#subscribe-domain-event-driven-scripting">Subscribe Domain: Event-Driven Scripting</a></h2>
<h3 id="event-subscription"><a class="header" href="#event-subscription">Event Subscription</a></h3>
<p>The <strong>subscribe</strong> domain enables reactive scripting based on window manager events. Syntax: <code>bspc subscribe [OPTIONS] (all|report|monitor|desktop|node|...)*</code>.</p>
<h3 id="subscription-options"><a class="header" href="#subscription-options">Subscription Options</a></h3>
<h4 id="fifo-output--f-and---fifo"><a class="header" href="#fifo-output--f-and---fifo">FIFO Output: <code>-f</code> and <code>--fifo</code></a></h4>
<p>The <strong>-f</strong> or <code>--fifo</code> flag outputs events to a named FIFO instead of stdout. This enables long-lived subscriptions.</p>
<h4 id="event-count--c-and---count"><a class="header" href="#event-count--c-and---count">Event Count: <code>-c</code> and <code>--count</code></a></h4>
<p>The <strong>-c</strong> or <code>--count</code> flag exits after receiving COUNT events.</p>
<h3 id="available-events"><a class="header" href="#available-events">Available Events</a></h3>
<h4 id="monitor-events"><a class="header" href="#monitor-events">Monitor Events</a></h4>
<ul>
<li><strong>monitor_add</strong>: New monitor connected</li>
<li><strong>monitor_rename</strong>: Monitor renamed</li>
<li><strong>monitor_remove</strong>: Monitor disconnected</li>
<li><strong>monitor_swap</strong>: Monitors swapped positions</li>
<li><strong>monitor_focus</strong>: Focus changed to monitor</li>
<li><strong>monitor_geometry</strong>: Monitor geometry changed</li>
</ul>
<h4 id="desktop-events"><a class="header" href="#desktop-events">Desktop Events</a></h4>
<ul>
<li><strong>desktop_add</strong>: Desktop created</li>
<li><strong>desktop_rename</strong>: Desktop renamed</li>
<li><strong>desktop_remove</strong>: Desktop deleted</li>
<li><strong>desktop_swap</strong>: Desktops swapped</li>
<li><strong>desktop_transfer</strong>: Desktop transferred to different monitor</li>
<li><strong>desktop_focus</strong>: Desktop focus changed</li>
<li><strong>desktop_activate</strong>: Desktop activated</li>
<li><strong>desktop_layout</strong>: Layout changed</li>
</ul>
<h4 id="node-events"><a class="header" href="#node-events">Node Events</a></h4>
<ul>
<li><strong>node_add</strong>: Window added</li>
<li><strong>node_remove</strong>: Window removed</li>
<li><strong>node_swap</strong>: Windows swapped</li>
<li><strong>node_transfer</strong>: Window transferred</li>
<li><strong>node_focus</strong>: Window focus changed</li>
<li><strong>node_activate</strong>: Window activated</li>
<li><strong>node_presel</strong>: Preselection changed</li>
<li><strong>node_stack</strong>: Stack order changed</li>
<li><strong>node_geometry</strong>: Window geometry changed</li>
<li><strong>node_state</strong>: Window state changed</li>
<li><strong>node_flag</strong>: Window flag changed</li>
<li><strong>node_layer</strong>: Stacking layer changed</li>
</ul>
<h4 id="report-event"><a class="header" href="#report-event">Report Event</a></h4>
<p>The <strong>report</strong> event outputs the complete current state in a specific format.</p>
<h3 id="event-processing-example"><a class="header" href="#event-processing-example">Event Processing Example</a></h3>
<p>Using events to perform actions:</p>
<pre><code class="language-bash">bspc subscribe node_add | while read -a msg; do
    desk_id=${msg[^1_2]}
    wid=${msg[^1_4]}
    # Make new windows fullscreen
    bspc node "$wid" -t fullscreen
done
</code></pre>
<h2 id="wm-domain-window-manager-state"><a class="header" href="#wm-domain-window-manager-state">Wm Domain: Window Manager State</a></h2>
<h3 id="global-window-manager-operations"><a class="header" href="#global-window-manager-operations">Global Window Manager Operations</a></h3>
<p>The <strong>wm</strong> domain controls global window manager state and operations.</p>
<h4 id="dump-state--d-and---dump-state"><a class="header" href="#dump-state--d-and---dump-state">Dump State: <code>-d</code> and <code>--dump-state</code></a></h4>
<p>The <strong>-d</strong> or <code>--dump-state</code> flag outputs the complete window manager state. This is useful for backing up configurations or analysis.</p>
<h4 id="load-state--l-and---load-state"><a class="header" href="#load-state--l-and---load-state">Load State: <code>-l</code> and <code>--load-state</code></a></h4>
<p>The <strong>-l</strong> or <code>--load-state** flag restores a previously dumped state. Syntax: </code>bspc wm -l &lt;file_path&gt;`.</p>
<h4 id="add-monitor--a-and---add-monitor"><a class="header" href="#add-monitor--a-and---add-monitor">Add Monitor: <code>-a</code> and <code>--add-monitor</code></a></h4>
<p>The <strong>-a</strong> or <code>--add-monitor</code> flag manually adds a monitor to management. Syntax: <code>bspc wm -a &lt;name&gt; WxH+X+Y</code>. Useful for dynamic monitor addition.</p>
<h4 id="reorder-monitors--o-and---reorder-monitors"><a class="header" href="#reorder-monitors--o-and---reorder-monitors">Reorder Monitors: <code>-O</code> and <code>--reorder-monitors</code></a></h4>
<p>The <strong>-O</strong> or <code>--reorder-monitors</code> flag changes the global monitor order. Syntax: <code>bspc wm -O &lt;name&gt;...</code>.</p>
<h4 id="adopt-orphans--o-and---adopt-orphans"><a class="header" href="#adopt-orphans--o-and---adopt-orphans">Adopt Orphans: <code>-o</code> and <code>--adopt-orphans</code></a></h4>
<p>The <strong>-o</strong> or <code>--adopt-orphans</code> flag brings unmanaged windows under BSPWM control.</p>
<h4 id="record-history--h-and---record-history"><a class="header" href="#record-history--h-and---record-history">Record History: <code>-h</code> and <code>--record-history</code></a></h4>
<p>The <strong>-h</strong> or <code>--record-history** flag enables/disables command history logging. Syntax: </code>bspc wm -h on|off`.</p>
<h4 id="get-status--g-and---get-status"><a class="header" href="#get-status--g-and---get-status">Get Status: <code>-g</code> and <code>--get-status</code></a></h4>
<p>The <strong>-g</strong> or <code>--get-status</code> flag outputs the current status.</p>
<h4 id="restart--r-and---restart"><a class="header" href="#restart--r-and---restart">Restart: <code>-r</code> and <code>--restart</code></a></h4>
<p>The <strong>-r</strong> or `–restart** flag restarts BSPWM while preserving windows. This is useful during configuration updates.</p>
<h2 id="window-states-and-flags"><a class="header" href="#window-states-and-flags">Window States and Flags</a></h2>
<h3 id="window-states"><a class="header" href="#window-states">Window States</a></h3>
<p>Each window maintains exactly one state at any time:</p>
<h4 id="tiled"><a class="header" href="#tiled">Tiled</a></h4>
<p><strong>Tiled</strong> state means the window fills its assigned tiling space without overlapping others. Windows are arranged according to the binary tree structure. This is the default state for new windows.</p>
<h4 id="pseudo-tiled"><a class="header" href="#pseudo-tiled">Pseudo-Tiled</a></h4>
<p><strong>Pseudo-tiled</strong> windows respect ICCCM size hints while being centered within their tiling space. They can be resized but maintain their centered position.</p>
<h4 id="floating"><a class="header" href="#floating">Floating</a></h4>
<p><strong>Floating</strong> windows can be positioned and resized freely anywhere on the desktop. They don’t participate in automatic tiling but remain part of the node tree.</p>
<h4 id="fullscreen"><a class="header" href="#fullscreen">Fullscreen</a></h4>
<p><strong>Fullscreen</strong> windows occupy their monitor’s entire rectangle with no borders. They’re placed above other content. When a fullscreen window is present and a new floating window is created, BSPWM must change the fullscreen window to tiled to display the floating window on top, unless the floating window is placed on the above layer.</p>
<h3 id="window-flags"><a class="header" href="#window-flags">Window Flags</a></h3>
<p>Flags are independent states that can be combined:</p>
<h4 id="hidden"><a class="header" href="#hidden">Hidden</a></h4>
<p><strong>Hidden</strong> windows don’t occupy tiling space and aren’t visible. They’re useful for implementing scratchpads and minimization-like functionality.</p>
<h4 id="sticky"><a class="header" href="#sticky">Sticky</a></h4>
<p><strong>Sticky</strong> windows follow the focused desktop on their monitor. When switching desktops, sticky windows appear on the new desktop.</p>
<h4 id="private"><a class="header" href="#private">Private</a></h4>
<p><strong>Private</strong> windows resist movement and resizing during automatic insertion. When inserting new windows into automatic mode, private nodes maintain their position and size rather than being split.</p>
<h4 id="locked"><a class="header" href="#locked">Locked</a></h4>
<p><strong>Locked</strong> windows ignore the close message sent by <code>bspc node -c</code>. They require forceful termination with <code>bspc node -k</code>.</p>
<h4 id="marked"><a class="header" href="#marked">Marked</a></h4>
<p><strong>Marked</strong> is an arbitrary flag useful for custom operations. It’s particularly valuable in conjunction with preselection to implement deferred window movement. Marked nodes automatically become unmarked when sent to a preselected node.</p>
<h4 id="urgent"><a class="header" href="#urgent">Urgent</a></h4>
<p><strong>Urgent</strong> indicates a window requiring attention. It’s typically set externally by applications (e.g., when incoming messages arrive). BSPWM uses this flag for window selection.</p>
<h2 id="stacking-layers"><a class="header" href="#stacking-layers">Stacking Layers</a></h2>
<p>BSPWM implements three independent stacking layers:</p>
<ol>
<li><strong>below</strong>: Lowest layer</li>
<li><strong>normal</strong>: Middle layer (default)</li>
<li><strong>above</strong>: Top layer</li>
</ol>
<p>Within each layer, the window order follows: tiled &amp; pseudo_tiled &lt; floating &lt; fullscreen. This means a floating window on the “below” layer appears above tiled windows on that layer but below all windows on the “normal” layer.</p>
<h2 id="advanced-configuration-patterns-and-techniques"><a class="header" href="#advanced-configuration-patterns-and-techniques">Advanced Configuration Patterns and Techniques</a></h2>
<h3 id="monitor-setup-and-multi-monitor-configuration"><a class="header" href="#monitor-setup-and-multi-monitor-configuration">Monitor Setup and Multi-Monitor Configuration</a></h3>
<p>Setting up monitors requires careful use of the monitor domain commands:</p>
<pre><code class="language-bash">#!/bin/bash
# Example multi-monitor setup

# External monitor setup
bspc monitor eDP1 -d I II III IV V
bspc monitor HDMI1 -d VI VII VIII IX X

# Alternative: Conditional setup
if xrandr | grep -q "HDMI1 connected"; then
    xrandr --output HDMI1 --right-of eDP1 --auto
    bspc monitor eDP1 -d I II III IV
    bspc monitor HDMI1 -d V VI VII VIII
fi
</code></pre>
<h3 id="floating-desktop-configuration"><a class="header" href="#floating-desktop-configuration">Floating Desktop Configuration</a></h3>
<p>Creating desktops where all windows float by default:</p>
<pre><code class="language-bash">bspc rule -a "*" -o desktop=floating_desktop state=floating
bspc desktop floating_desktop -l tiled  # or any layout
</code></pre>
<h3 id="scratchpaddropdown-terminal-implementation"><a class="header" href="#scratchpaddropdown-terminal-implementation">Scratchpad/Dropdown Terminal Implementation</a></h3>
<p>Using hidden sticky windows to create dropdown terminal functionality:</p>
<pre><code class="language-bash"># Create dropdown terminal rule
bspc rule -a dropdown -o sticky=on state=floating hidden=on rectangle=800x600+560+240

# Launch dropdown terminal
alacritty --class dropdown -e zsh &amp;

# Toggle script
bspc node any.hidden.sticky -g hidden -f
</code></pre>
<h3 id="receptacle-based-manual-layouts"><a class="header" href="#receptacle-based-manual-layouts">Receptacle-Based Manual Layouts</a></h3>
<p>Using receptacles to build predefined layouts:</p>
<pre><code class="language-bash"># Create three-pane layout with receptacles
bspc node -i
bspc node -p west -o 0.5
bspc node -i
bspc node -p south
bspc node -i

# Fill receptacles with windows - they automatically slot into place
</code></pre>
<h3 id="external-rules-for-complex-logic"><a class="header" href="#external-rules-for-complex-logic">External Rules for Complex Logic</a></h3>
<p>When built-in rules aren’t sufficient, external rule scripts provide unlimited flexibility:</p>
<pre><code class="language-bash">#!/bin/bash
# /home/user/.config/bspwm/external_rules

wid=$1
class=$2
instance=$3

case "$class" in
    Firefox)
        if [ "$instance" = "firefox" ]; then
            echo "desktop=^1 follow=on"
        else
            echo "desktop=^2"  # Private browsing to different desktop
        fi
        ;;
    Blender)
        echo "state=floating rectangle=1920x1080+0+0"
        ;;
    *)
        # Default behavior
        ;;
esac
</code></pre>
<h3 id="event-driven-automatic-layouts"><a class="header" href="#event-driven-automatic-layouts">Event-Driven Automatic Layouts</a></h3>
<p>Using subscribe to dynamically adapt behavior:</p>
<pre><code class="language-bash"># Automatically switch to monocle in fullscreen windows
bspc subscribe node_state | while read -a msg; do
    if [ "${msg[^1_8]}" = "fullscreen" ] &amp;&amp; [ "${msg[^1_9]}" = "on" ]; then
        desk_id=$(echo "${msg[^1_1]}" | cut -d':' -f2)
        bspc desktop "$desk_id" -l monocle
    fi
done &amp;
</code></pre>
<h3 id="node-id-tracking-and-manipulation"><a class="header" href="#node-id-tracking-and-manipulation">Node ID Tracking and Manipulation</a></h3>
<p>Storing and using node IDs for complex operations:</p>
<pre><code class="language-bash"># Store node ID and move it later
id=$(bspc query -N -n)
# ... perform other operations ...
bspc node "$id" -d '^2'  # Move stored node to desktop 2
</code></pre>
<h3 id="custom-layouts-with-master-stack"><a class="header" href="#custom-layouts-with-master-stack">Custom Layouts with Master Stack</a></h3>
<p>While BSPWM provides only tiled and monocle, external scripts enable layouts like master-stack:</p>
<pre><code class="language-bash"># Balance 3-pane layout
bspc node @/ -B
bspc node @/1 -r 0.66  # Make left side 66% of space
</code></pre>
<h3 id="pointer-action-configuration"><a class="header" href="#pointer-action-configuration">Pointer Action Configuration</a></h3>
<p>Setting up mouse controls for floating window manipulation:</p>
<pre><code class="language-bash"># Configure pointer modifier and actions
bspc config pointer_modifier mod1          # Use Alt key
bspc config pointer_action1 move           # Alt+Button1 moves
bspc config pointer_action2 resize_side    # Alt+Button2 resizes edge
bspc config pointer_action3 resize_corner  # Alt+Button3 resizes corner
</code></pre>
<h3 id="query-based-window-selection"><a class="header" href="#query-based-window-selection">Query-Based Window Selection</a></h3>
<p>Complex window selection using query syntax:</p>
<pre><code class="language-bash"># Find biggest window on current desktop and close it
biggest=$(bspc query -N -n biggest.local.!fullscreen.window)
bspc node "$biggest" -c

# Focus all windows of same class
class=$(bspc query -N -n | xargs -I {} xprop -id {} WM_CLASS | cut -d'"' -f2 | head -1)
bspc node ".same_class" -f
</code></pre>
<h3 id="tree-manipulation-example"><a class="header" href="#tree-manipulation-example">Tree Manipulation Example</a></h3>
<p>Using rotate, flip, and balance for dynamic layouts:</p>
<pre><code class="language-bash"># Rotate current desktop tree 90 degrees
bspc node @/ -R 90

# Flip tree horizontally
bspc node @/ -F horizontal

# Balance all split ratios for equal window sizes
bspc node @/ -B

# Equal spacing (reset all ratios)
bspc node @/ -E
</code></pre>
<h3 id="comprehensive-configuration-template"><a class="header" href="#comprehensive-configuration-template">Comprehensive Configuration Template</a></h3>
<p>A sophisticated bspwmrc demonstrating multiple techniques:</p>
<pre><code class="language-bash">#!/bin/bash
# ~/.config/bspwm/bspwmrc

# Start sxhkd for keybindings
sxhkd &amp;

# Monitor setup
if xrandr | grep -q "HDMI1 connected"; then
    xrandr --output HDMI1 --right-of eDP1 --auto
    bspc monitor eDP1 -d 1 2 3 4 5
    bspc monitor HDMI1 -d 6 7 8 9 10
else
    bspc monitor -d 1 2 3 4 5 6 7 8 9 10
fi

# Global settings
bspc config window_gap 12
bspc config border_width 2
bspc config top_padding 0
bspc config bottom_padding 0
bspc config left_padding 0
bspc config right_padding 0

# Colors
bspc config normal_border_color "#3c3836"
bspc config focused_border_color "#b8bb26"
bspc config active_border_color "#a89984"

# Layout and splitting
bspc config split_ratio 0.5
bspc config automatic_scheme longest_side
bspc config initial_polarity second_child

# Pointer
bspc config pointer_modifier mod1
bspc config pointer_action1 move
bspc config pointer_action2 resize_side
bspc config pointer_action3 resize_corner

# EWMH
bspc config ignore_ewmh_focus true
bspc config ignore_ewmh_struts true

# Focus behavior
bspc config focus_follows_pointer false

# Rules
bspc rule -r '*'  # Clear existing rules

bspc rule -a Firefox desktop='^1'
bspc rule -a Thunderbird desktop='^2'
bspc rule -a Slack desktop='^9'
bspc rule -a feh state=floating
bspc rule -a Gimp state=floating follow=on
bspc rule -a St state=floating rectangle=800x600+560+240

# External rules script
bspc config external_rules_command ~/.config/bspwm/external_rules

# Start status bar
polybar main &amp;

# Launch background apps
nm-applet &amp;
</code></pre>
<h2 id="so-far"><a class="header" href="#so-far">So Far</a></h2>
<ul>
<li>
<p>BSPWM represents a paradigm shift in window manager configuration philosophy. Rather than implementing every feature directly within the window manager, BSPWM provides a powerful, scriptable interface through <strong>bspc</strong> that enables users to build sophisticated configurations entirely from shell scripts. This approach offers unprecedented flexibility and transparency—users can see exactly what commands are being executed and modify them without learning specialized syntax.</p>
</li>
<li>
<p>The comprehensive command set across six domains (node, desktop, monitor, query, rule, wm) combined with powerful selector syntax enables precise control over every aspect of window management. Advanced features like event subscription, external rule scripts, and tree manipulation operations provide the foundation for highly customized window management workflows.</p>
</li>
<li>
<p>Mastering BSPWM configuration requires understanding the hierarchical structure of selectors, the binary tree model of window arrangement, and how to combine simple commands into complex behaviors. The sophisticated user can leverage all documented flags and options to create configurations that adapt dynamically to their workflow, automating complex window management scenarios through scripting and event handling.</p>
</li>
<li>
<p>This documentation provides the authoritative reference for every flag, option, and configuration technique available in BSPWM, extracted from official sources and community expertise, enabling users to build the most sophisticated window management configurations possible.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="configuration-gallery"><a href="#configuration-gallery" class="header">Configuration gallery</a></h1>
<h2 id="the-config-ref"><a class="header" href="#the-config-ref">The Config-Ref</a></h2>
<p>Below given is a curated list of awesome bspwm configs for ready reference, cloning and experimentation. <strong>We do not advice you to blindly copy configs</strong>, instead read them and try writing them by your own. But it is up to you whether to <strong>use bspwm</strong> or <strong>build upon bspwm</strong>.</p>
<p>These are some nice configurations that beginners should try learning and configuring.</p>
<blockquote class="blockquote-tag blockquote-tag-warning">
<p class="blockquote-tag-title"><svg viewbox="0 0 16 16" width="18" height="18"><path d="M6.457 1.047c.659-1.234 2.427-1.234 3.086 0l6.082 11.378A1.75 1.75 0 0 1 14.082 15H1.918a1.75 1.75 0 0 1-1.543-2.575Zm1.763.707a.25.25 0 0 0-.44 0L1.698 13.132a.25.25 0 0 0 .22.368h12.164a.25.25 0 0 0 .22-.368Zm.53 3.996v2.5a.75.75 0 0 1-1.5 0v-2.5a.75.75 0 0 1 1.5 0ZM9 11a1 1 0 1 1-2 0 1 1 0 0 1 2 0Z"></path></svg>Warning</p>
<p>These configs are configured by various people as per their system requirements. You may run into issues if some scripts are not compactible or optimised for your system, or if you are missing some dependencies. bspwm-wiki does not rank based on popularity, it is alphabetical order. No offense.</p>
</blockquote>
<h2 id="recommended-configurations-for-reference"><a class="header" href="#recommended-configurations-for-reference">Recommended Configurations for Reference</a></h2>
<h3 id="1-archcraft-bspwm"><a class="header" href="#1-archcraft-bspwm">1) Archcraft-Bspwm</a></h3>
<p><a href="https://github.com/archcraft-os/archcraft-bspwm.git"><strong>Visit</strong></a></p>
<p><strong>Desc :</strong> This is a very asthetic and beautiful bspwm configuration hand crafted personally for Archcraft OS by <a href="https://github.com/adi1090x">adi1090x</a>. Has rich polybar and rofi ecosystem.</p>
<p><strong>Gallery :</strong></p>
<p><img src="assets/archcraft/01.png" alt="Preview"></p>
<br>
<h3 id="2-gh0stzk-dotfiles"><a class="header" href="#2-gh0stzk-dotfiles">2) Gh0stzk-Dotfiles</a></h3>
<p><a href="https://github.com/gh0stzk/dotfiles.git"><strong>Visit</strong></a></p>
<p><strong>Desc :</strong> These dotfiles are designed with the goal of providing a bspwm environment that is lightweight, efficient, and functional, tailored for any use. Has rich theming system, about 18 prebuilt themes. [This is original text] from <a href="https://github.com/gh0stzk">gh0stzk</a>.</p>
<p><strong>Gallery :</strong></p>
<p><img src="assets/gh0stzk/01.webp" alt="Preview"></p>
<br>
<h3 id="3-martian-dotfiles"><a class="header" href="#3-martian-dotfiles">3) Martian Dotfiles</a></h3>
<p><a href="https://github.com/zalosspace/martian_dotfiles.git"><strong>Visit</strong></a></p>
<p><strong>Desc :</strong> An asthetically refined arch linux bspwm rice. It has a well documented installation guide and explanations for it’s configs. If you are just beginning, this could be a good starting place for you. Uses a forked version of picom which gives you nice blur effects. Specifically tailored for bspwm by <a href="https://github.com/zalosspace">zalosspace</a>.</p>
<p><strong>Gallery :</strong></p>
<p><img src="assets/martian/01.png" alt="Preview"></p>
<br>
<h2 id="how-to-get-yours-here"><a class="header" href="#how-to-get-yours-here">How to get yours here</a></h2>
<p>Make a pull request to the repository linking your bspwm dotfile repository with description. If you have a very good documentation and configuration for bspwm with a nice asthetic, your bspwm configuration can mean a lot to others. It will be added to the list.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="bspwm1---------------------------------bspwm-manual---------------------------------bspwm1"><a class="header" href="#bspwm1---------------------------------bspwm-manual---------------------------------bspwm1">BSPWM(1)                                 Bspwm Manual                                 BSPWM(1)</a></h1>
<p>NAME
bspwm - Binary space partitioning window manager</p>
<p>SYNOPSIS
bspwm [-h|-v|-c CONFIG_PATH]</p>
<pre><code>   bspc --print-socket-path

   bspc DOMAIN [SELECTOR] COMMANDS

   bspc COMMAND [OPTIONS] [ARGUMENTS]
DESCRIPTION
</code></pre>
<p>bspwm is a tiling window manager that represents windows as the leaves of a full binary
tree.</p>
<pre><code>   It is controlled and configured via bspc.
OPTIONS
</code></pre>
<p>-h
Print the synopsis and exit.</p>
<pre><code>   -v
       Print the version and exit.

   -c CONFIG_PATH
       Use the given configuration file.

   --print-socket-path
       Print the bspwm socket path and exit.
COMMON DEFINITIONS
</code></pre>
<p>DIR         := north | west | south | east
CYCLE_DIR   := next | prev</p>
<p>SELECTORS
Selectors are used to select a target node, desktop, or monitor. A selector can either
describe the target relatively or name it globally.</p>
<pre><code>   Selectors consist of an optional reference, a descriptor and any number of
   non-conflicting modifiers as follows:

       [REFERENCE#]DESCRIPTOR(.MODIFIER)*

   The relative targets are computed in relation to the given reference (the default
   reference value is focused).

   An exclamation mark can be prepended to any modifier in order to reverse its meaning.

   The following characters cannot be used in monitor or desktop names: #, :, ..

   The special selector %&lt;name&gt; can be used to select a monitor or a desktop with an
   invalid name.
Node
</code></pre>
<p>Select a node.</p>
<pre><code>       NODE_SEL := [NODE_SEL#](DIR|CYCLE_DIR|PATH|any|first_ancestor|last|newest|
                               older|newer|focused|pointed|biggest|smallest|
                               &lt;node_id&gt;)[.[!]focused][.[!]active][.[!]automatic][.[!]local]
                                         [.[!]leaf][.[!]window][.[!]STATE][.[!]FLAG][.[!]LAYER][.[!]SPLIT_TYPE]
                                         [.[!]same_class][.[!]descendant_of][.[!]ancestor_of]

       STATE := tiled|pseudo_tiled|floating|fullscreen

       FLAG := hidden|sticky|private|locked|marked|urgent

       LAYER := below|normal|above

       SPLIT_TYPE := horizontal|vertical

       PATH := @[DESKTOP_SEL:][[/]JUMP](/JUMP)*

       JUMP := first|1|second|2|brother|parent|DIR

   Descriptors

       DIR
           Selects the window in the given (spacial) direction relative to the reference
           node.

       CYCLE_DIR
           Selects the node in the given (cyclic) direction relative to the reference node
           within a depth-first in-order traversal of the tree.

       PATH
           Selects the node at the given path.

       any
           Selects the first node that matches the given selectors.

       first_ancestor
           Selects the first ancestor of the reference node that matches the given
           selectors.

       last
           Selects the previously focused node relative to the reference node.

       newest
           Selects the newest node in the history of the focused node.

       older
           Selects the node older than the reference node in the history.

       newer
           Selects the node newer than the reference node in the history.

       focused
           Selects the currently focused node.

       pointed
           Selects the leaf under the pointer.

       biggest
           Selects the biggest leaf.

       smallest
           Selects the smallest leaf.

       &lt;node_id&gt;
           Selects the node with the given ID.

   Path Jumps

       The initial node is the focused node (or the root if the path starts with /) of the
       reference desktop (or the selected desktop if the path has a DESKTOP_SEL prefix).

       1|first
           Jumps to the first child.

       2|second
           Jumps to the second child.

       brother
           Jumps to the brother node.

       parent
           Jumps to the parent node.

       DIR
           Jumps to the node holding the edge in the given direction.

   Modifiers

       [!]focused
           Only consider the focused node.

       [!]active
           Only consider nodes that are the focused node of their desktop.

       [!]automatic
           Only consider nodes in automatic insertion mode. See also --presel-dir under
           Node in the DOMAINS section below.

       [!]local
           Only consider nodes in the reference desktop.

       [!]leaf
           Only consider leaf nodes.

       [!]window
           Only consider nodes that hold a window.

       [!](tiled|pseudo_tiled|floating|fullscreen)
           Only consider windows in the given state.

       [!]same_class
           Only consider windows that have the same class as the reference window.

       [!]descendant_of
           Only consider nodes that are descendants of the reference node.

       [!]ancestor_of
           Only consider nodes that are ancestors of the reference node.

       [!](hidden|sticky|private|locked|marked|urgent)
           Only consider windows that have the given flag set.

       [!](below|normal|above)
           Only consider windows in the given layer.

       [!](horizontal|vertical)
           Only consider nodes with the given split type.
Desktop
</code></pre>
<p>Select a desktop.</p>
<pre><code>       DESKTOP_SEL := [DESKTOP_SEL#](CYCLE_DIR|any|last|newest|older|newer|
                                     [MONITOR_SEL:](focused|^&lt;n&gt;)|
                                     &lt;desktop_id&gt;|&lt;desktop_name&gt;)[.[!]focused][.[!]active]
                                                                 [.[!]occupied][.[!]urgent][.[!]local]
                                                                 [.[!]LAYOUT][.[!]user_LAYOUT]

       LAYOUT := tiled|monocle

   Descriptors

       CYCLE_DIR
           Selects the desktop in the given direction relative to the reference desktop.

       any
           Selects the first desktop that matches the given selectors.

       last
           Selects the previously focused desktop relative to the reference desktop.

       newest
           Selects the newest desktop in the history of the focused desktops.

       older
           Selects the desktop older than the reference desktop in the history.

       newer
           Selects the desktop newer than the reference desktop in the history.

       focused
           Selects the currently focused desktop.

       ^&lt;n&gt;
           Selects the nth desktop. If MONITOR_SEL is given, selects the nth desktop on
           the selected monitor.

       &lt;desktop_id&gt;
           Selects the desktop with the given ID.

       &lt;desktop_name&gt;
           Selects the desktop with the given name.

   Modifiers

       [!]focused
           Only consider the focused desktop.

       [!]active
           Only consider desktops that are the focused desktop of their monitor.

       [!]occupied
           Only consider occupied desktops.

       [!]urgent
           Only consider urgent desktops.

       [!]local
           Only consider desktops inside the reference monitor.

       [!](tiled|monocle)
           Only consider desktops with the given layout.

       [!](user_tiled|user_monocle)
           Only consider desktops which have the given layout as userLayout.
Monitor
</code></pre>
<p>Select a monitor.</p>
<pre><code>       MONITOR_SEL := [MONITOR_SEL#](DIR|CYCLE_DIR|any|last|newest|older|newer|
                                     focused|pointed|primary|^&lt;n&gt;|
                                     &lt;monitor_id&gt;|&lt;monitor_name&gt;)[.[!]focused][.[!]occupied]

   Descriptors

       DIR
           Selects the monitor in the given (spacial) direction relative to the reference
           monitor.

       CYCLE_DIR
           Selects the monitor in the given (cyclic) direction relative to the reference
           monitor.

       any
           Selects the first monitor that matches the given selectors.

       last
           Selects the previously focused monitor relative to the reference monitor.

       newest
           Selects the newest monitor in the history of the focused monitors.

       older
           Selects the monitor older than the reference monitor in the history.

       newer
           Selects the monitor newer than the reference monitor in the history.

       focused
           Selects the currently focused monitor.

       pointed
           Selects the monitor under the pointer.

       primary
           Selects the primary monitor.

       ^&lt;n&gt;
           Selects the nth monitor.

       &lt;monitor_id&gt;
           Selects the monitor with the given ID.

       &lt;monitor_name&gt;
           Selects the monitor with the given name.

   Modifiers

       [!]focused
           Only consider the focused monitor.

       [!]occupied
           Only consider monitors where the focused desktop is occupied.
WINDOW STATES
</code></pre>
<p>tiled
Its size and position are determined by the window tree.</p>
<pre><code>   pseudo_tiled
       A tiled window that automatically shrinks but doesn’t stretch beyond its floating
       size.

   floating
       Can be moved/resized freely. Although it doesn’t use any tiling space, it is still
       part of the window tree.

   fullscreen
       Fills its monitor rectangle and has no borders.
NODE FLAGS
</code></pre>
<p>hidden
Is hidden and doesn’t occupy any tiling space.</p>
<pre><code>   sticky
       Stays in the focused desktop of its monitor.

   private
       Tries to keep the same tiling position/size.

   locked
       Ignores the node --close message.

   marked
       Is marked (useful for deferred actions). A marked node becomes unmarked after being
       sent on a preselected node.

   urgent
       Has its urgency hint set. This flag is set externally.
STACKING LAYERS
</code></pre>
<p>There’s three stacking layers: BELOW, NORMAL and ABOVE.</p>
<pre><code>   In each layer, the windows are orderered as follows: tiled &amp; pseudo-tiled &lt; floating &lt;
   fullscreen.
RECEPTACLES
</code></pre>
<p>A leaf node that doesn’t hold any window is called a receptacle. When a node is
inserted on a receptacle in automatic mode, it will replace the receptacle. A
receptacle can be inserted on a node, preselected and killed. Receptacles can therefore
be used to build a tree whose leaves are receptacles. Using the appropriate rules, one
can then send windows on the leaves of this tree. This feature is used in
examples/receptacles to store and recreate layouts.</p>
<p>DOMAINS
Node
General Syntax</p>
<pre><code>       node [NODE_SEL] COMMANDS

       If NODE_SEL is omitted, focused is assumed.

   Commands

       -f, --focus [NODE_SEL]
           Focus the selected or given node.

       -a, --activate [NODE_SEL]
           Activate the selected or given node.

       -d, --to-desktop DESKTOP_SEL [--follow]
           Send the selected node to the given desktop. If --follow is passed, the focused
           node will stay focused.

       -m, --to-monitor MONITOR_SEL [--follow]
           Send the selected node to the given monitor. If --follow is passed, the focused
           node will stay focused.

       -n, --to-node NODE_SEL [--follow]
           Send the selected node on the given node. If --follow is passed, the focused
           node will stay focused.

       -s, --swap NODE_SEL [--follow]
           Swap the selected node with the given node. If --follow is passed, the focused
           node will stay focused.

       -p, --presel-dir [~]DIR|cancel
           Preselect the splitting area of the selected node (or cancel the preselection).
           If ~ is prepended to DIR and the current preselection direction matches DIR,
           then the argument is interpreted as cancel. A node with a preselected area is
           said to be in "manual insertion mode".

       -o, --presel-ratio RATIO
           Set the splitting ratio of the preselection area.

       -v, --move dx dy
           Move the selected window by dx pixels horizontally and dy pixels vertically.

       -z, --resize top|left|bottom|right|top_left|top_right|bottom_right|bottom_left dx
       dy
           Resize the selected window by moving the given handle by dx pixels horizontally
           and dy pixels vertically.

       -y, --type CYCLE_DIR|horizontal|vertical
           Set or cycle the splitting type of the selected node.

       -r, --ratio RATIO|(+|-)(PIXELS|FRACTION)
           Set the splitting ratio of the selected node (0 &lt; RATIO &lt; 1).

       -R, --rotate 90|270|180
           Rotate the tree rooted at the selected node.

       -F, --flip horizontal|vertical
           Flip the tree rooted at selected node.

       -E, --equalize
           Reset the split ratios of the tree rooted at the selected node to their default
           value.

       -B, --balance
           Adjust the split ratios of the tree rooted at the selected node so that all
           windows occupy the same area.

       -C, --circulate forward|backward
           Circulate the windows of the tree rooted at the selected node.

       -t, --state ~|[~]STATE
           Set the state of the selected window. If ~ is present and the current state
           matches STATE, then the argument is interpreted as its last state. If the
           argument is just ~ with STATE omitted, then the state of the selected window is
           set to its last state.

       -g, --flag hidden|sticky|private|locked|marked[=on|off]
           Set or toggle the given flag for the selected node.

       -l, --layer below|normal|above
           Set the stacking layer of the selected window.

       -i, --insert-receptacle
           Insert a receptacle node at the selected node.

       -c, --close
           Close the windows rooted at the selected node.

       -k, --kill
           Kill the windows rooted at the selected node.
Desktop
</code></pre>
<p>General Syntax</p>
<pre><code>       desktop [DESKTOP_SEL] COMMANDS

       If DESKTOP_SEL is omitted, focused is assumed.

   COMMANDS

       -f, --focus [DESKTOP_SEL]
           Focus the selected or given desktop.

       -a, --activate [DESKTOP_SEL]
           Activate the selected or given desktop.

       -m, --to-monitor MONITOR_SEL [--follow]
           Send the selected desktop to the given monitor. If --follow is passed, the
           focused desktop will stay focused.

       -s, --swap DESKTOP_SEL [--follow]
           Swap the selected desktop with the given desktop. If --follow is passed, the
           focused desktop will stay focused.

       -l, --layout CYCLE_DIR|monocle|tiled
           Set or cycle the layout of the selected desktop.

       -n, --rename &lt;new_name&gt;
           Rename the selected desktop.

       -b, --bubble CYCLE_DIR
           Bubble the selected desktop in the given direction.

       -r, --remove
           Remove the selected desktop.
Monitor
</code></pre>
<p>General Syntax</p>
<pre><code>       monitor [MONITOR_SEL] COMMANDS

       If MONITOR_SEL is omitted, focused is assumed.

   Commands

       -f, --focus [MONITOR_SEL]
           Focus the selected or given monitor.

       -s, --swap MONITOR_SEL
           Swap the selected monitor with the given monitor.

       -a, --add-desktops &lt;name&gt;...
           Create desktops with the given names in the selected monitor.

       -o, --reorder-desktops &lt;name&gt;...
           Reorder the desktops of the selected monitor to match the given order.

       -d, --reset-desktops &lt;name&gt;...
           Rename, add or remove desktops depending on whether the number of given names
           is equal, superior or inferior to the number of existing desktops.

       -g, --rectangle WxH+X+Y
           Set the rectangle of the selected monitor.

       -n, --rename &lt;new_name&gt;
           Rename the selected monitor.

       -r, --remove
           Remove the selected monitor.
Query
</code></pre>
<p>General Syntax</p>
<pre><code>       query COMMANDS [OPTIONS]

   Commands

       The optional selectors are references.

       -N, --nodes [NODE_SEL]
           List the IDs of the matching nodes.

       -D, --desktops [DESKTOP_SEL]
           List the IDs (or names) of the matching desktops.

       -M, --monitors [MONITOR_SEL]
           List the IDs (or names) of the matching monitors.

       -T, --tree
           Print a JSON representation of the matching item.

   Options

       -m,--monitor [MONITOR_SEL|MONITOR_MODIFIERS], -d,--desktop
       [DESKTOP_SEL|DESKTOP_MODIFIERS], -n,--node [NODE_SEL|NODE_MODIFIERS]
           Constrain matches to the selected monitors, desktops or nodes.

       --names
           Print names instead of IDs. Can only be used with -M and -D.
Wm
</code></pre>
<p>General Syntax</p>
<pre><code>       wm COMMANDS

   Commands

       -d, --dump-state
           Dump the current world state on standard output.

       -l, --load-state &lt;file_path&gt;
           Load a world state from the given file. The path must be absolute.

       -a, --add-monitor &lt;name&gt; WxH+X+Y
           Add a monitor for the given name and rectangle.

       -O, --reorder-monitors &lt;name&gt;...
           Reorder the list of monitors to match the given order.

       -o, --adopt-orphans
           Manage all the unmanaged windows remaining from a previous session.

       -h, --record-history on|off
           Enable or disable the recording of node focus history.

       -g, --get-status
           Print the current status information.

       -r, --restart
           Restart the window manager
Rule
</code></pre>
<p>General Syntax</p>
<pre><code>       rule COMMANDS

   Commands

       -a, --add (&lt;class_name&gt;|*)[:(&lt;instance_name&gt;|*)[:(&lt;name&gt;|*)]] [-o|--one-shot]
       [monitor=MONITOR_SEL|desktop=DESKTOP_SEL|node=NODE_SEL] [state=STATE] [layer=LAYER]
       [honor_size_hints=(true|false|tiled|floating)] [split_dir=DIR] [split_ratio=RATIO]
       [(hidden|sticky|private|locked|marked|center|follow|manage|focus|border)=(on|off)]
       [rectangle=WxH+X+Y]
           Create a new rule. Colons in the instance_name, class_name, or name fields can
           be escaped with a backslash.

       -r, --remove ^&lt;n&gt;|head|tail|(&lt;class_name&gt;|*)[:(&lt;instance_name&gt;|*)[:(&lt;name&gt;|*)]]...
           Remove the given rules.

       -l, --list
           List the rules.
Config
</code></pre>
<p>General Syntax</p>
<pre><code>       config [-m MONITOR_SEL|-d DESKTOP_SEL|-n NODE_SEL] &lt;setting&gt; [&lt;value&gt;]
           Get or set the value of &lt;setting&gt;.
Subscribe
</code></pre>
<p>General Syntax</p>
<pre><code>       subscribe [OPTIONS] (all|report|monitor|desktop|node|...)*
           Continuously print events. See the EVENTS section for the description of each
           event.

   Options

       -f, --fifo
           Print a path to a FIFO from which events can be read and return.

       -c, --count COUNT
           Stop the corresponding bspc process after having received COUNT events.
Quit
</code></pre>
<p>General Syntax</p>
<pre><code>       quit [&lt;status&gt;]
           Quit with an optional exit status.
EXIT CODES
</code></pre>
<p>If the server can’t handle a message, bspc will return with a non-zero exit code.</p>
<p>SETTINGS
Colors are in the form #RRGGBB, booleans are true, on, false or off.</p>
<pre><code>   All the boolean settings are false by default unless stated otherwise.
Global Settings
</code></pre>
<p>normal_border_color
Color of the border of an unfocused window.</p>
<pre><code>   active_border_color
       Color of the border of a focused window of an unfocused monitor.

   focused_border_color
       Color of the border of a focused window of a focused monitor.

   presel_feedback_color
       Color of the node --presel-{dir,ratio} message feedback area.

   split_ratio
       Default split ratio.

   status_prefix
       Prefix prepended to each of the status lines.

   external_rules_command
       Absolute path to the command used to retrieve rule consequences. The command will
       receive the following arguments: window ID, class name, instance name, and
       intermediate consequences. The output of that command must have the following
       format: key1=value1 key2=value2 ...  (the valid key/value pairs are given in the
       description of the rule command).

   automatic_scheme
       The insertion scheme used when the insertion point is in automatic mode. Accept the
       following values: longest_side, alternate, spiral.

   initial_polarity
       On which child should a new window be attached when adding a window on a single
       window tree in automatic mode. Accept the following values: first_child,
       second_child.

   directional_focus_tightness
       The tightness of the algorithm used to decide whether a window is on the DIR side
       of another window. Accept the following values: high, low.

   removal_adjustment
       Adjust the brother when unlinking a node from the tree in accordance with the
       automatic insertion scheme.

   presel_feedback
       Draw the preselection feedback area. Defaults to true.

   borderless_monocle
       Remove borders of tiled windows for the monocle desktop layout.

   gapless_monocle
       Remove gaps of tiled windows for the monocle desktop layout.

   top_monocle_padding, right_monocle_padding, bottom_monocle_padding,
   left_monocle_padding
       Padding space added at the sides of the screen for the monocle desktop layout.

   single_monocle
       Set the desktop layout to monocle if there’s only one tiled window in the tree.

   borderless_singleton
       Remove borders of the only window on the only monitor regardless its layout.

   pointer_motion_interval
       The minimum interval, in milliseconds, between two motion notify events.

   pointer_modifier
       Keyboard modifier used for moving or resizing windows. Accept the following values:
       shift, control, lock, mod1, mod2, mod3, mod4, mod5.

   pointer_action1, pointer_action2, pointer_action3
       Action performed when pressing pointer_modifier + button&lt;n&gt;. Accept the following
       values: move, resize_side, resize_corner, focus, none.

   click_to_focus
       Button used for focusing a window (or a monitor). The possible values are: button1,
       button2, button3, any, none. Defaults to button1.

   swallow_first_click
       Don’t replay the click that makes a window focused if click_to_focus isn’t none.

   focus_follows_pointer
       Focus the window under the pointer.

   pointer_follows_focus
       When focusing a window, put the pointer at its center.

   pointer_follows_monitor
       When focusing a monitor, put the pointer at its center.

   mapping_events_count
       Handle the next mapping_events_count mapping notify events. A negative value
       implies that every event needs to be handled.

   ignore_ewmh_focus
       Ignore EWMH focus requests coming from applications.

   ignore_ewmh_fullscreen
       Block the fullscreen state transitions that originate from an EWMH request. The
       possible values are: none, all, or a comma separated list of the following values:
       enter, exit.

   ignore_ewmh_struts
       Ignore strut hinting from clients requesting to reserve space (i.e. task bars).

   center_pseudo_tiled
       Center pseudo tiled windows into their tiling rectangles. Defaults to true.

   remove_disabled_monitors
       Consider disabled monitors as disconnected.

   remove_unplugged_monitors
       Remove unplugged monitors.

   merge_overlapping_monitors
       Merge overlapping monitors (the bigger remains).
Monitor and Desktop Settings
</code></pre>
<p>top_padding, right_padding, bottom_padding, left_padding
Padding space added at the sides of the monitor or desktop.</p>
<p>Desktop Settings
window_gap
Size of the gap that separates windows.</p>
<p>Node Settings
border_width
Window border width.</p>
<pre><code>   honor_size_hints
       If true, apply ICCCM window size hints to all windows. If floating, only apply them
       to floating and pseudo tiled windows. If tiled, only apply them to tiled windows.
       If false, don’t apply them. Defaults to false.
POINTER BINDINGS
</code></pre>
<p>click_to_focus
Focus the window (or the monitor) under the pointer if the value isn’t none.</p>
<pre><code>   pointer_modifier + button1
       Move the window under the pointer.

   pointer_modifier + button2
       Resize the window under the pointer by dragging the nearest side.

   pointer_modifier + button3
       Resize the window under the pointer by dragging the nearest corner.

   The behavior of pointer_modifier + button&lt;n&gt; can be modified through the
   pointer_action&lt;n&gt; setting.
EVENTS
</code></pre>
<p>report
See the next section for the description of the format.</p>
<pre><code>   monitor_add &lt;monitor_id&gt; &lt;monitor_name&gt; &lt;monitor_geometry&gt;
       A monitor is added.

   monitor_rename &lt;monitor_id&gt; &lt;old_name&gt; &lt;new_name&gt;
       A monitor is renamed.

   monitor_remove &lt;monitor_id&gt;
       A monitor is removed.

   monitor_swap &lt;src_monitor_id&gt; &lt;dst_monitor_id&gt;
       A monitor is swapped.

   monitor_focus &lt;monitor_id&gt;
       A monitor is focused.

   monitor_geometry &lt;monitor_id&gt; &lt;monitor_geometry&gt;
       The geometry of a monitor changed.

   desktop_add &lt;monitor_id&gt; &lt;desktop_id&gt; &lt;desktop_name&gt;
       A desktop is added.

   desktop_rename &lt;monitor_id&gt; &lt;desktop_id&gt; &lt;old_name&gt; &lt;new_name&gt;
       A desktop is renamed.

   desktop_remove &lt;monitor_id&gt; &lt;desktop_id&gt;
       A desktop is removed.

   desktop_swap &lt;src_monitor_id&gt; &lt;src_desktop_id&gt; &lt;dst_monitor_id&gt; &lt;dst_desktop_id&gt;
       A desktop is swapped.

   desktop_transfer &lt;src_monitor_id&gt; &lt;src_desktop_id&gt; &lt;dst_monitor_id&gt;
       A desktop is transferred.

   desktop_focus &lt;monitor_id&gt; &lt;desktop_id&gt;
       A desktop is focused.

   desktop_activate &lt;monitor_id&gt; &lt;desktop_id&gt;
       A desktop is activated.

   desktop_layout &lt;monitor_id&gt; &lt;desktop_id&gt; tiled|monocle
       The layout of a desktop changed.

   node_add &lt;monitor_id&gt; &lt;desktop_id&gt; &lt;ip_id&gt; &lt;node_id&gt;
       A node is added.

   node_remove &lt;monitor_id&gt; &lt;desktop_id&gt; &lt;node_id&gt;
       A node is removed.

   node_swap &lt;src_monitor_id&gt; &lt;src_desktop_id&gt; &lt;src_node_id&gt; &lt;dst_monitor_id&gt;
   &lt;dst_desktop_id&gt; &lt;dst_node_id&gt;
       A node is swapped.

   node_transfer &lt;src_monitor_id&gt; &lt;src_desktop_id&gt; &lt;src_node_id&gt; &lt;dst_monitor_id&gt;
   &lt;dst_desktop_id&gt; &lt;dst_node_id&gt;
       A node is transferred.

   node_focus &lt;monitor_id&gt; &lt;desktop_id&gt; &lt;node_id&gt;
       A node is focused.

   node_activate &lt;monitor_id&gt; &lt;desktop_id&gt; &lt;node_id&gt;
       A node is activated.

   node_presel &lt;monitor_id&gt; &lt;desktop_id&gt; &lt;node_id&gt; (dir DIR|ratio RATIO|cancel)
       A node is preselected.

   node_stack &lt;node_id_1&gt; below|above &lt;node_id_2&gt;
       A node is stacked below or above another node.

   node_geometry &lt;monitor_id&gt; &lt;desktop_id&gt; &lt;node_id&gt; &lt;node_geometry&gt;
       The geometry of a window changed.

   node_state &lt;monitor_id&gt; &lt;desktop_id&gt; &lt;node_id&gt; tiled|pseudo_tiled|floating|fullscreen
   on|off
       The state of a window changed.

   node_flag &lt;monitor_id&gt; &lt;desktop_id&gt; &lt;node_id&gt;
   hidden|sticky|private|locked|marked|urgent on|off
       One of the flags of a node changed.

   node_layer &lt;monitor_id&gt; &lt;desktop_id&gt; &lt;node_id&gt; below|normal|above
       The layer of a window changed.

   pointer_action &lt;monitor_id&gt; &lt;desktop_id&gt; &lt;node_id&gt; move|resize_corner|resize_side
   begin|end
       A pointer action occurred.

   Please note that bspwm initializes monitors before it reads messages on its socket,
   therefore the initial monitor events can’t be received.
REPORT FORMAT
</code></pre>
<p>Each report event message is composed of items separated by colons.</p>
<pre><code>   Each item has the form &lt;type&gt;&lt;value&gt; where &lt;type&gt; is the first character of the item.

   M&lt;monitor_name&gt;
       Focused monitor.

   m&lt;monitor_name&gt;
       Unfocused monitor.

   O&lt;desktop_name&gt;
       Occupied focused desktop.

   o&lt;desktop_name&gt;
       Occupied unfocused desktop.

   F&lt;desktop_name&gt;
       Free focused desktop.

   f&lt;desktop_name&gt;
       Free unfocused desktop.

   U&lt;desktop_name&gt;
       Urgent focused desktop.

   u&lt;desktop_name&gt;
       Urgent unfocused desktop.

   L(T|M)
       Layout of the focused desktop of a monitor.

   T(T|P|F|=|@)
       State of the focused node of a focused desktop.

   G(S?P?L?M?)
       Active flags of the focused node of a focused desktop.
ENVIRONMENT VARIABLES
</code></pre>
<p>BSPWM_SOCKET
The path of the socket used for the communication between bspc and bspwm. If it
isn’t defined, then the following path is used:
/tmp/bspwm&lt;host_name&gt;<em>&lt;display_number&gt;</em>&lt;screen_number&gt;-socket.</p>
<p>CONTRIBUTORS
•   Steven Allen : steven at stebalien.com</p>
<pre><code>   •   Thomas Adam &lt;thomas at xteddy.org&gt;

   •   Ivan Kanakarakis &lt;ivan.kanak at gmail.com&gt;
AUTHOR
</code></pre>
<p>Bastien Dejean : nihilhill at gmail.com</p>
<p>Bspwm 0.9.12                              10/08/2025                                  BSPWM(1)</p>
<p>Deeply explain all off these in seperate subheadings how to what to and with example  each of the feature in bspwm in 40000 words</p>
<p>Perfect! Now I have comprehensive information. Let me create a detailed, in-depth guide about bspwm. I’ll now generate the comprehensive answer.</p>
<h1 id="a-comprehensive-in-depth-guide-to-bspwm-the-binary-space-partitioning-window-manager"><a class="header" href="#a-comprehensive-in-depth-guide-to-bspwm-the-binary-space-partitioning-window-manager">A Comprehensive In-Depth Guide to BSPWM: The Binary Space Partitioning Window Manager</a></h1>
<p>This comprehensive guide provides an exhaustive explanation of BSPWM (Binary Space Partitioning Window Manager), covering all major features, domains, commands, and configurations with detailed examples and practical applications. BSPWM is a sophisticated tiling window manager that organizes windows using binary space partitioning algorithms, represented as leaves in a full binary tree structure. Unlike traditional window managers that require mouse interactions for window management, BSPWM operates through a client-server socket architecture where the <code>bspc</code> command client communicates with the <code>bspwm</code> server daemon, allowing keyboard-driven, highly customizable window management.</p>
<h2 id="i-introduction-to-bspwm-architecture-and-core-concepts"><a class="header" href="#i-introduction-to-bspwm-architecture-and-core-concepts">I. Introduction to BSPWM Architecture and Core Concepts</a></h2>
<h3 id="a-what-is-binary-space-partitioning-bsp"><a class="header" href="#a-what-is-binary-space-partitioning-bsp">A. What is Binary Space Partitioning (BSP)?</a></h3>
<p><strong>Binary Space Partitioning</strong> is a mathematical technique originally developed for three-dimensional computer graphics that recursively divides a rectangular space by splitting it along axis-aligned lines. In the context of BSPWM, this algorithm is applied to monitor screen rectangles, creating a hierarchical binary tree structure where each internal node represents a split (either horizontal or vertical) and each leaf node represents a window or empty receptacle.</p>
<p>The fundamental principle behind BSP in BSPWM is elegant: every node in the tree either has exactly zero children (leaf nodes) or exactly two children (internal nodes). Each internal node manages a rectangular area and decides how to split it between its two child nodes using two parameters: the split type (horizontal or vertical) and the split ratio (a value between 0 and 1, where 0.5 means equal distribution). This mathematical approach ensures that every pixel on the screen is always accounted for and that the layout remains perfectly tiled without gaps or overlaps, except for borders and user-configured gaps.</p>
<p><strong>Example of BSP in Action:</strong>
When you start with a single window filling the entire monitor (node 1), and open a second window (node 2), BSPWM creates an internal node (node b) that splits the screen according to the automatic insertion scheme. If the split is vertical with a ratio of 0.5, the first window gets 50% of the width on the left and the second window gets 50% on the right. Opening a third window (node 3) causes the tree to reorganize, with one of the existing nodes being displaced to create space for the new window.</p>
<h3 id="b-architecture-client-server-socket-model"><a class="header" href="#b-architecture-client-server-socket-model">B. Architecture: Client-Server Socket Model</a></h3>
<p>BSPWM operates using a three-component architecture where the window manager itself (the <code>bspwm</code> daemon) is separate from its control program (<code>bspc</code>) and keyboard binding manager (<code>sxhkd</code>). This separation of concerns provides several advantages:</p>
<pre><code>1. **bspwm daemon**: Runs in the background listening on a Unix domain socket (`/tmp/bspwm&lt;hostname&gt;_&lt;display&gt;_&lt;screen&gt;-socket`), managing all window operations and desktop state
</code></pre>
<ol start="2">
<li><strong>bspc client</strong>: Sends commands to the bspwm socket to manage windows, desktops, monitors, and query the window tree</li>
<li><strong>sxhkd daemon</strong>: A separate process that intercepts X11 keyboard and pointer events and translates them into <code>bspc</code> commands</li>
</ol>
<p>This architecture means BSPWM doesn’t handle any keyboard input directly—it only responds to socket messages. This makes BSPWM completely independent of any particular key binding system and allows the same window manager to be used with different hotkey daemons.</p>
<h3 id="c-fundamental-concepts-monitors-desktops-and-nodes"><a class="header" href="#c-fundamental-concepts-monitors-desktops-and-nodes">C. Fundamental Concepts: Monitors, Desktops, and Nodes</a></h3>
<p><strong>Monitors</strong> are physical displays or virtual output devices (detected via RandR or Xinerama protocols) that act as containers holding rectangular regions. Each monitor displays one focused desktop at a time. When you have multiple monitors, each can show a different desktop.</p>
<p><strong>Desktops</strong> (also called workspaces or virtual desktops) are independent tree structures that contain windows. A monitor shows one desktop at a time, but can switch between them. Each desktop has its own layout (tiled or monocle) and contains its own hierarchy of windows.</p>
<p><strong>Nodes</strong> are the abstract tree nodes—either internal nodes (which define splits) or leaf nodes (which hold windows or are empty receptacles). Every window in BSPWM is represented as a leaf node in the binary tree. Empty leaf nodes without windows are called <strong>receptacles</strong> and serve as placeholders for future window insertions.</p>
<p><strong>Example Monitor/Desktop/Node Hierarchy:</strong></p>
<pre><code>Monitor 1 (1920x1080)
├── Desktop 1 (focused) - containing Tree T1
│   ├── Node 1 (window: Firefox)
│   ├── Node 2 (window: Terminal)
│   └── Node 3 (receptacle)
├── Desktop 2 - containing Tree T2
│   └── Node 1 (window: Editor)
└── Desktop 3 - containing Tree T3
    └── (empty)

Monitor 2 (1920x1080)
└── Desktop 4 - containing Tree T4
    └── Node 1 (window: Media Player)
</code></pre>
<h2 id="ii-selectors-the-foundation-of-bspwm-control"><a class="header" href="#ii-selectors-the-foundation-of-bspwm-control">II. Selectors: The Foundation of BSPWM Control</a></h2>
<p>Selectors are the core mechanism through which you target windows, desktops, or monitors for operations. Understanding selectors is absolutely essential because almost every <code>bspc</code> command uses them to specify which object to operate on.</p>
<h3 id="a-selector-syntax-and-structure"><a class="header" href="#a-selector-syntax-and-structure">A. Selector Syntax and Structure</a></h3>
<p>The general syntax for a selector is:</p>
<pre><code>[REFERENCE#]DESCRIPTOR(.MODIFIER)*
</code></pre>
<p>This breaks down as:</p>
<ul>
<li><strong>REFERENCE</strong>: An optional reference node/desktop/monitor (defaults to focused)</li>
<li><strong>DESCRIPTOR</strong>: The primary selection method (direction, cycling, ID, etc.)</li>
<li><strong>MODIFIERS</strong>: Zero or more filtering conditions, each can be negated with <code>!</code></li>
</ul>
<p>For example: <code>node east.!floating.window</code> means “select the node to the east that is not floating and has a window in it”.</p>
<h3 id="b-node-selectors-in-depth"><a class="header" href="#b-node-selectors-in-depth">B. Node Selectors in Depth</a></h3>
<p><strong>Node Selectors</strong> target specific windows/nodes in the tree. The complete syntax is:</p>
<pre><code>NODE_SEL := [NODE_SEL#](DIR|CYCLE_DIR|PATH|any|first_ancestor|last|newest|older|newer|focused|pointed|biggest|smallest|&lt;node_id&gt;)[.[!]focused][.[!]active][.[!]automatic][.[!]local][.[!]leaf][.[!]window][.[!]STATE][.[!]FLAG][.[!]LAYER][.[!]SPLIT_TYPE][.[!]same_class][.[!]descendant_of][.[!]ancestor_of]
</code></pre>
<p><strong>Node Selector Descriptors</strong> (primary selection methods):</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th style="text-align: left">Descriptor</th><th style="text-align: left">Behavior</th><th style="text-align: left">Example</th></tr>
</thead>
<tbody>
<tr><td style="text-align: left"><code>north|south|east|west</code> (DIR)</td><td style="text-align: left">Select window spatially in given direction</td><td style="text-align: left"><code>bspc node west -f</code></td></tr>
<tr><td style="text-align: left"><code>next|prev</code> (CYCLE_DIR)</td><td style="text-align: left">Cycle within tree traversal order</td><td style="text-align: left"><code>bspc node next -f</code></td></tr>
<tr><td style="text-align: left"><code>any</code></td><td style="text-align: left">Select first matching node</td><td style="text-align: left"><code>bspc node any.floating -f</code></td></tr>
<tr><td style="text-align: left"><code>focused</code></td><td style="text-align: left">Currently focused node</td><td style="text-align: left"><code>bspc node focused -t floating</code></td></tr>
<tr><td style="text-align: left"><code>pointed</code></td><td style="text-align: left">Node under mouse pointer</td><td style="text-align: left"><code>bspc node pointed -c</code></td></tr>
<tr><td style="text-align: left"><code>biggest|smallest</code></td><td style="text-align: left">Largest or smallest leaf</td><td style="text-align: left"><code>bspc node biggest -s focused</code></td></tr>
<tr><td style="text-align: left"><code>last</code></td><td style="text-align: left">Previously focused node</td><td style="text-align: left"><code>bspc node last -f</code></td></tr>
<tr><td style="text-align: left"><code>newest|older|newer</code></td><td style="text-align: left">History-based selection</td><td style="text-align: left"><code>bspc node newest -n @^1</code></td></tr>
<tr><td style="text-align: left"><code>&lt;node_id&gt;</code></td><td style="text-align: left">Specific node by ID</td><td style="text-align: left"><code>bspc node 0x00800001 -t floating</code></td></tr>
<tr><td style="text-align: left"><code>@PATH</code></td><td style="text-align: left">Path-based navigation</td><td style="text-align: left"><code>bspc node @/first/brother -f</code></td></tr>
</tbody>
</table>
</div>
<p><strong>Node Selector Modifiers</strong> (filtering conditions):</p>
<pre><code># States
.tiled              - Only tiled windows
.pseudo_tiled       - Only pseudo-tiled windows
.floating           - Only floating windows
.fullscreen         - Only fullscreen windows

# Flags
.hidden             - Hidden (not displayed)
.sticky             - Stays on focused desktop
.private            - Resists movement/resize
.locked             - Can't be closed
.marked             - Custom marking
.urgent             - Has urgency hint

# Layers
.below              - Below normal layer
.normal             - Normal stacking layer
.above              - Above normal layer

# Tree structure
.leaf               - Leaf nodes only
.window             - Nodes with windows only
.same_class         - Windows of same application class
.descendant_of      - All descendants
.ancestor_of        - All ancestors
</code></pre>
<p><strong>Practical Node Selector Examples:</strong></p>
<pre><code class="language-bash"># Focus the window to the east
bspc node east -f

# Focus the largest window that's not fullscreen
bspc node biggest.!fullscreen -f

# Select first tiled window on current desktop
bspc node .local.tiled -f

# Move focused window to the second child position
bspc node -n @/second -f

# Select all windows of Firefox class
bspc node .same_class -t floating
</code></pre>
<h3 id="c-desktop-selectors"><a class="header" href="#c-desktop-selectors">C. Desktop Selectors</a></h3>
<p><strong>Desktop Selectors</strong> target specific workspaces and have the syntax:</p>
<pre><code>DESKTOP_SEL := [DESKTOP_SEL#](CYCLE_DIR|any|last|newest|older|newer|[MONITOR_SEL:](focused|^&lt;n&gt;)|&lt;desktop_id&gt;|&lt;desktop_name&gt;)[.[!]focused][.[!]active][.[!]occupied][.[!]urgent][.[!]local][.[!]LAYOUT][.[!]user_LAYOUT]
</code></pre>
<p><strong>Desktop Selector Descriptors:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th style="text-align: left">Descriptor</th><th style="text-align: left">Behavior</th></tr>
</thead>
<tbody>
<tr><td style="text-align: left"><code>next|prev</code></td><td style="text-align: left">Cycle to next/previous desktop</td></tr>
<tr><td style="text-align: left"><code>focused</code></td><td style="text-align: left">Currently active desktop</td></tr>
<tr><td style="text-align: left"><code>^&lt;n&gt;</code></td><td style="text-align: left">Nth desktop (^1 = first)</td></tr>
<tr><td style="text-align: left"><code>^1|^2|^3...</code></td><td style="text-align: left">Numbered desktops</td></tr>
<tr><td style="text-align: left"><code>&lt;desktop_name&gt;</code></td><td style="text-align: left">Desktop by name</td></tr>
<tr><td style="text-align: left"><code>occupied</code></td><td style="text-align: left">Desktops with windows</td></tr>
<tr><td style="text-align: left"><code>urgent</code></td><td style="text-align: left">Desktops with urgent windows</td></tr>
</tbody>
</table>
</div>
<p><strong>Practical Desktop Selector Examples:</strong></p>
<pre><code class="language-bash"># Focus the second desktop
bspc desktop ^2 -f

# Send window to desktop named "work" and follow
bspc node -d work --follow

# Focus an occupied desktop
bspc desktop .occupied -f

# List all unoccupied desktops
bspc query -D -d .!occupied
</code></pre>
<h3 id="d-monitor-selectors"><a class="header" href="#d-monitor-selectors">D. Monitor Selectors</a></h3>
<p><strong>Monitor Selectors</strong> target specific physical displays:</p>
<pre><code>MONITOR_SEL := [MONITOR_SEL#](DIR|CYCLE_DIR|any|last|newest|older|newer|focused|pointed|primary|^&lt;n&gt;|&lt;monitor_id&gt;|&lt;monitor_name&gt;)[.[!]focused][.[!]occupied]
</code></pre>
<p><strong>Practical Monitor Selector Examples:</strong></p>
<pre><code class="language-bash"># Focus the monitor to the right
bspc monitor east -f

# Focus the primary monitor
bspc monitor primary -f

# List all monitors
bspc query -M --names

# Send desktop to second monitor
bspc desktop -m ^2 --follow
</code></pre>
<h3 id="e-path-selectors-advanced-tree-navigation"><a class="header" href="#e-path-selectors-advanced-tree-navigation">E. Path Selectors: Advanced Tree Navigation</a></h3>
<p>Path selectors allow you to navigate the tree structure directly using spatial relationships:</p>
<pre><code>PATH := @[DESKTOP_SEL:][[/]JUMP](/JUMP)*
JUMP := first|1|second|2|brother|parent|DIR
</code></pre>
<p><strong>Path Navigation Examples:</strong></p>
<pre><code class="language-bash"># Focus first child of focused node
bspc node @/first -f

# Focus the second child
bspc node @/second -f

# Focus parent of focused node
bspc node @/parent -f

# Focus brother (sibling) of focused node
bspc node @/brother -f

# Navigate using directions within path
bspc node @/first/east -f

# Cross-desktop path navigation
bspc node @^2:/first -f  # First child of desktop 2
</code></pre>
<h2 id="iii-window-states-how-bspwm-manages-window-modes"><a class="header" href="#iii-window-states-how-bspwm-manages-window-modes">III. Window States: How BSPWM Manages Window Modes</a></h2>
<p>BSPWM provides four distinct window states that determine how windows are positioned and rendered. Understanding these states is crucial for effective window management.</p>
<h3 id="a-tiled-state"><a class="header" href="#a-tiled-state">A. Tiled State</a></h3>
<p><strong>Tiled</strong> windows are fully managed by the BSPWM tiling algorithm. Their size and position are entirely determined by their position in the binary tree and the tree’s split ratios. Windows in this state cannot overlap, and the entire monitor space is divided among them.</p>
<p><strong>Characteristics of Tiled Windows:</strong></p>
<ul>
<li>Respects and fills the rectangular region allocated by the tree</li>
<li>Cannot overlap other tiled or pseudo-tiled windows</li>
<li>Automatically resizes when the tree structure changes</li>
<li>Follows the configured border width and gaps</li>
<li>Cannot be freely moved or resized by the user (only through tree operations)</li>
</ul>
<p><strong>Example Configuration:</strong></p>
<pre><code class="language-bash"># Set focused window to tiled
bspc node focused -t tiled

# Set all windows of Firefox to tiled
bspc node .same_class -t tiled

# Create rule for specific application
bspc rule -a libroffice -t tiled
</code></pre>
<h3 id="b-pseudo-tiled-state"><a class="header" href="#b-pseudo-tiled-state">B. Pseudo-Tiled State</a></h3>
<p><strong>Pseudo-tiled</strong> (also called sticky floating or “forced”) windows are a hybrid between tiled and floating. They are positioned and sized according to the tree structure like tiled windows, but they automatically shrink to respect the application’s size hints (if enabled) and don’t stretch beyond their requested size.</p>
<p><strong>Characteristics of Pseudo-Tiled Windows:</strong></p>
<ul>
<li>Positioned like tiled windows (respects tree allocation)</li>
<li>Can shrink to respect window size hints</li>
<li>Won’t stretch beyond application’s preferred size</li>
<li>Useful for dialog windows, floating applications that you want managed by the tree</li>
<li>Still participate in the binary tree layout</li>
</ul>
<p><strong>Example Use Cases:</strong></p>
<pre><code class="language-bash"># Set to pseudo-tiled (good for dialogs)
bspc node focused -t pseudo_tiled

# Rule for GIMP tools palette (prefers fixed size)
bspc rule -a Gimp -t pseudo_tiled

# This window takes its tree space but respects its size hints
</code></pre>
<h3 id="c-floating-state"><a class="header" href="#c-floating-state">C. Floating State</a></h3>
<p><strong>Floating</strong> windows are completely freed from the tiling tree structure. They can be positioned and resized freely anywhere on the monitor, overlapping other windows. However, floating windows are still part of the tree structure (just not as visible participants) and still have a position in the tree hierarchy.</p>
<p><strong>Characteristics of Floating Windows:</strong></p>
<ul>
<li>Can be moved and resized freely with keyboard or mouse</li>
<li>Can overlap other windows</li>
<li>Still counted in the tree but don’t participate in tiling</li>
<li>Can be moved to different desktops</li>
<li>Useful for temporary windows, dialogs, notifications</li>
</ul>
<p><strong>Example Operations:</strong></p>
<pre><code class="language-bash"># Set focused window to floating
bspc node focused -t floating

# Move floating window by pixels
bspc node focused -v -20 0    # Move left 20 pixels
bspc node focused -v 0 20     # Move down 20 pixels

# Resize floating window
bspc node focused -z bottom 0 20  # Expand bottom side

# Focus floating windows only
bspc node .floating -f
</code></pre>
<h3 id="d-fullscreen-state"><a class="header" href="#d-fullscreen-state">D. Fullscreen State</a></h3>
<p><strong>Fullscreen</strong> windows fill the entire monitor rectangle with no borders or gaps. Fullscreen windows are always on top (in the NORMAL stacking layer by default) and completely hide other windows beneath them. Important: BSPWM uses different stacking layers which affect fullscreen behavior.</p>
<p><strong>Characteristics of Fullscreen Windows:</strong></p>
<ul>
<li>Fills entire monitor dimensions</li>
<li>No borders, gaps, or padding applied</li>
<li>Appears above all other windows</li>
<li>Can be overridden by ABOVE-layer windows</li>
<li>Useful for games, presentations, full-screen applications</li>
</ul>
<p><strong>Example Operations:</strong></p>
<pre><code class="language-bash"># Toggle current window fullscreen
bspc node focused -t fullscreen

# Set specific application to fullscreen
bspc rule -a mpv -t fullscreen

# Make fullscreen window exit
bspc node focused -t tiled  # Return to tiled

# Focus under fullscreen window (requires switching states)
bspc node focused.fullscreen -t floating
</code></pre>
<h3 id="e-state-toggling-and-dynamic-switching"><a class="header" href="#e-state-toggling-and-dynamic-switching">E. State Toggling and Dynamic Switching</a></h3>
<p>BSPWM supports elegant state toggling using the tilde <code>~</code> character, which switches between the current state and the previous state:</p>
<pre><code class="language-bash"># Toggle between current and previous state
bspc node focused -t ~

# Toggle to specific state (if currently in that state, revert)
bspc node focused -t ~floating  # If floating, goes back; if not, becomes floating

# Create sxhkd binding for cycling through states
super + {t,s,f}
    bspc node -t {tiled,pseudo_tiled,floating}
    
# Or with toggling
super + shift + {t,s,f}
    bspc node -t {~tiled,~pseudo_tiled,~floating}
</code></pre>
<h2 id="iv-node-flags-behavioral-modifiers-for-windows"><a class="header" href="#iv-node-flags-behavioral-modifiers-for-windows">IV. Node Flags: Behavioral Modifiers for Windows</a></h2>
<p>Node flags are boolean properties that modify how BSPWM treats a particular window beyond just its state. These flags enable powerful window management patterns and advanced configurations.</p>
<h3 id="a-hidden-flag"><a class="header" href="#a-hidden-flag">A. Hidden Flag</a></h3>
<p><strong>Hidden</strong> windows are completely removed from the layout and hidden from view. They don’t occupy any tiling space and can be toggled to reappear later.</p>
<p><strong>Usage Examples:</strong></p>
<pre><code class="language-bash"># Hide focused window
bspc node focused -g hidden

# Show all hidden windows on current desktop
bspc node .hidden -g hidden=off

# Toggle hidden state
bspc node focused -g hidden=toggle

# Script to create scratchpad functionality
#!/bin/bash
if bspc node focused -g | grep hidden; then
    bspc node focused -g hidden=off -f
else
    bspc node focused -g hidden=on
fi
</code></pre>
<h3 id="b-sticky-flag"><a class="header" href="#b-sticky-flag">B. Sticky Flag</a></h3>
<p><strong>Sticky</strong> windows automatically follow the focused desktop of their monitor. This means if you switch desktops on a monitor, the sticky window moves with you, remaining visible on every desktop you visit.</p>
<p><strong>Use Cases:</strong></p>
<ul>
<li>Always-visible status windows</li>
<li>Quick-reference applications</li>
<li>Floating notes or widgets</li>
<li>Monitor-persistent applications</li>
</ul>
<p><strong>Configuration:</strong></p>
<pre><code class="language-bash"># Make focused window sticky
bspc node focused -g sticky

# Rule for always-visible terminal
bspc rule -a sticky_terminal -g sticky=on -t floating

# Create sticky note/dashboard window
st -n sticky_widget &amp;  # Custom class
bspc rule -a sticky_widget -g sticky=on state=floating

# Sxhkd binding
super + shift + s
    bspc node focused -g sticky
</code></pre>
<h3 id="c-private-flag"><a class="header" href="#c-private-flag">C. Private Flag</a></h3>
<p><strong>Private</strong> windows attempt to maintain their tiling position and size even when other windows are added or removed from the tree. This prevents automatic resizing when the tree structure changes.</p>
<p><strong>Behavior:</strong></p>
<ul>
<li>Resists repositioning when tree changes</li>
<li>Useful for preventing windows from being moved around</li>
<li>Maintains size hints more strictly</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-bash"># Make a media player private so it stays in place
bspc node id:0x00800001 -g private

# Rule for video players
bspc rule -a vlc -g private=on

# Practical use: video window that shouldn't move when opening other windows
</code></pre>
<h3 id="d-locked-flag"><a class="header" href="#d-locked-flag">D. Locked Flag</a></h3>
<p><strong>Locked</strong> windows ignore the <code>node -c</code> (close) command, preventing accidental closure through keyboard shortcuts. They can only be closed using <code>node -k</code> (kill) or through the application’s own UI.</p>
<p><strong>Usage:</strong></p>
<pre><code class="language-bash"># Lock focused window against closure
bspc node focused -g locked

# Lock specific application
bspc rule -a firefox -g locked=on

# Toggle lock state
bspc node focused -g locked=toggle

# In sxhkd, you might have:
super + shift + l
    bspc node focused -g locked
    
# And then close uses -c which is ignored for locked nodes
super + shift + w
    bspc node focused -c  # Silently fails for locked windows
</code></pre>
<h3 id="e-marked-flag"><a class="header" href="#e-marked-flag">E. Marked Flag</a></h3>
<p><strong>Marked</strong> nodes are flagged with an arbitrary marker that serves as a building block for custom scripting. A marked node automatically becomes unmarked after being sent to a preselected node.</p>
<p><strong>Key Characteristics:</strong></p>
<ul>
<li>Completely arbitrary—doesn’t change behavior by itself</li>
<li>Used for deferred operations (mark now, operate later)</li>
<li>Automatically unmarks after preselection</li>
<li>Enables powerful multi-step workflows</li>
</ul>
<p><strong>Practical Examples:</strong></p>
<pre><code class="language-bash"># Mark a node for later operation
bspc node focused -g marked

# Move all marked nodes to preselected location
bspc node newest.marked.local -n newest.!automatic.local

# Sxhkd workflow example:
# Step 1: Mark windows
super + m
    bspc node focused -g marked

# Step 2: Navigate and preselect area
super + p; {h,j,k,l}
    bspc node -p {west,south,north,east}

# Step 3: Move marked nodes to preselection
super + y
    bspc node newest.marked.local -n newest.!automatic.local

# Practical workflow: mark multiple windows, define their layout with
# preselections, then move them all at once
</code></pre>
<h3 id="f-urgent-flag"><a class="header" href="#f-urgent-flag">F. Urgent Flag</a></h3>
<p><strong>Urgent</strong> windows have their urgency hint set externally (usually by applications requesting attention—like chat notifications). This flag indicates that a window requires user attention.</p>
<p><strong>BSPWM Behavior with Urgent:</strong></p>
<ul>
<li>Desktop containing urgent window can be highlighted differently</li>
<li>Can be used to style borders in unique colors</li>
<li>Can drive notifications to user</li>
</ul>
<p><strong>Configuration:</strong></p>
<pre><code class="language-bash"># Style urgent windows differently
bspc config urgent_border_color "#FF0000"

# Focus urgent windows
bspc node .urgent -f

# Clear urgency (focus the window)
bspc node focused -f
</code></pre>
<h3 id="g-managing-multiple-flags-simultaneously"><a class="header" href="#g-managing-multiple-flags-simultaneously">G. Managing Multiple Flags Simultaneously</a></h3>
<p>Flags can be combined and managed together:</p>
<pre><code class="language-bash"># Set multiple flags at once
bspc node focused -g hidden=on -g sticky=on -g locked=on

# Toggle specific flag
bspc node focused -g marked=toggle

# Create comprehensive window configuration
bspc rule -a myapp \
    -g hidden=off \
    -g sticky=on \
    -g private=on \
    state=floating
</code></pre>
<h2 id="v-stacking-layers-window-z-order-management"><a class="header" href="#v-stacking-layers-window-z-order-management">V. Stacking Layers: Window Z-Order Management</a></h2>
<p>BSPWM implements three stacking layers that determine the Z-order (depth) in which windows are rendered. This provides fine control over which windows appear on top.</p>
<h3 id="a-layer-overview"><a class="header" href="#a-layer-overview">A. Layer Overview</a></h3>
<pre><code>ABOVE ────────── (highest Z-order)
  ├── Fullscreen &gt; Floating &gt; Tiled
NORMAL ────────── (default)
  ├── Fullscreen &gt; Floating &gt; Tiled
BELOW ────────── (lowest Z-order)
  ├── Fullscreen &gt; Floating &gt; Tiled
</code></pre>
<p>Within each layer, windows follow a consistent drawing order: fullscreen windows appear above floating windows, which appear above tiled/pseudo-tiled windows.</p>
<h3 id="b-setting-and-managing-layers"><a class="header" href="#b-setting-and-managing-layers">B. Setting and Managing Layers</a></h3>
<p><strong>The ABOVE Layer:</strong>
Used for permanently visible windows that should never be hidden:</p>
<pre><code class="language-bash"># Make window appear above everything
bspc node focused -l above

# Typical use: notification windows, always-on-top utilities
bspc rule -a notification -l above

# Floating panel that should stay visible
</code></pre>
<p><strong>The NORMAL Layer:</strong>
The default layer for most windows:</p>
<pre><code class="language-bash"># Return to normal layer
bspc node focused -l normal

# Most windows stay here
</code></pre>
<p><strong>The BELOW Layer:</strong>
For background windows:</p>
<pre><code class="language-bash"># Place window below everything
bspc node focused -l below

# Use case: background wallpaper application, monitor display
bspc rule -a wallpaper_app -l below
</code></pre>
<h3 id="c-practical-layer-usage"><a class="header" href="#c-practical-layer-usage">C. Practical Layer Usage</a></h3>
<pre><code class="language-bash"># Create an always-on-top floating window
bspc node floating_app -l above

# Desktop setup: wallpaper below, then tiled windows, then floating on top
bspc node .wallpaper -l below
bspc node .tiled -l normal
bspc node .floating -l above

# Advanced: fullscreen overlay
# When you want a fullscreen window but something above it
bspc rule -a overlay_app -t floating -l above -r

# Solve fullscreen problems: put floating windows on above layer
bspc config external_rules_command ~/.config/bspwm/external_rules

# In external_rules script:
[[ "$(xdotool getactivewindow getwindowname)" == *"Overlay"* ]] &amp;&amp; \
    echo "layer=above"
</code></pre>
<h2 id="vi-receptacles-the-empty-node-concept"><a class="header" href="#vi-receptacles-the-empty-node-concept">VI. Receptacles: The Empty Node Concept</a></h2>
<p><strong>Receptacles</strong> are leaf nodes in the tree that don’t hold any window. They serve as placeholders for future window placements and enable powerful tree-building patterns.</p>
<h3 id="a-understanding-receptacles"><a class="header" href="#a-understanding-receptacles">A. Understanding Receptacles</a></h3>
<p>When you insert a receptacle at a node’s location, it becomes an empty leaf in the tree. When a new window is opened and directed to a receptacle (in automatic mode), the receptacle is replaced by the window node. This allows you to pre-build the entire tree structure before opening windows.</p>
<p><strong>Receptacle Key Properties:</strong></p>
<ul>
<li>Leaf nodes without windows</li>
<li>Can be inserted explicitly at any location</li>
<li>Automatically replaced when window inserted in automatic mode</li>
<li>Can be preselected and killed manually</li>
<li>Useful for creating fixed layouts</li>
</ul>
<h3 id="b-creating-and-managing-receptacles"><a class="header" href="#b-creating-and-managing-receptacles">B. Creating and Managing Receptacles</a></h3>
<pre><code class="language-bash"># Insert receptacle at focused node
bspc node focused -i

# Insert receptacle on specific location
bspc node -n @/first -i

# Kill a receptacle
bspc node receptacle_id -k

# Query all receptacles on desktop
bspc query -N -n .leaf.!window

# List receptacle IDs
bspc query -N -n .receptacle
</code></pre>
<h3 id="c-receptacle-based-layout-system"><a class="header" href="#c-receptacle-based-layout-system">C. Receptacle-Based Layout System</a></h3>
<p>Receptacles enable a sophisticated layout system using dump/load:</p>
<pre><code class="language-bash">#!/bin/bash
# Build layout with receptacles
bspc desktop ^1 -l monocle

# Create tree structure using receptacles
bspc node -i           # Receptacle 1
bspc node -i           # Receptacle 2
bspc node -i           # Receptacle 3

# Now when you open windows, they fill these receptacles in order
# Window 1 goes to receptacle 1
# Window 2 goes to receptacle 2
# Window 3 goes to receptacle 3

# Dump this state
bspc wm -d &gt; ~/.config/bspwm/layouts/my_layout.json

# Later, restore with:
bspc wm -l ~/.config/bspwm/layouts/my_layout.json
</code></pre>
<h3 id="d-receptacle-vs-preselection-comparison"><a class="header" href="#d-receptacle-vs-preselection-comparison">D. Receptacle vs. Preselection Comparison</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th style="text-align: left">Aspect</th><th style="text-align: left">Receptacle</th><th style="text-align: left">Preselection</th></tr>
</thead>
<tbody>
<tr><td style="text-align: left">Visual Feedback</td><td style="text-align: left">None</td><td style="text-align: left">Colored preview area</td></tr>
<tr><td style="text-align: left">Automatic Replacement</td><td style="text-align: left">Yes, in auto mode</td><td style="text-align: left">No, requires manual action</td></tr>
<tr><td style="text-align: left">Multiple Instances</td><td style="text-align: left">Yes, can have many</td><td style="text-align: left">Yes, one per node</td></tr>
<tr><td style="text-align: left">Persistence</td><td style="text-align: left">Until window inserted</td><td style="text-align: left">Canceled on split</td></tr>
<tr><td style="text-align: left">Use Case</td><td style="text-align: left">Pre-build layouts</td><td style="text-align: left">Interactive splitting</td></tr>
</tbody>
</table>
</div>
<pre><code class="language-bash"># Using receptacles for fixed layout
bspc node -i; bspc node -i; bspc node -i  # 3 receptacles
# Open windows - they fill the receptacles

# Using preselection for interactive layout
bspc node -p west      # Next window splits to west
# Open window - it appears to the west
</code></pre>
<h2 id="vii-insertion-modes-automatic-vs-manual-window-placement"><a class="header" href="#vii-insertion-modes-automatic-vs-manual-window-placement">VII. Insertion Modes: Automatic vs. Manual Window Placement</a></h2>
<p>BSPWM provides two insertion modes that determine how new windows are positioned in the tree: automatic and manual modes.</p>
<h3 id="a-automatic-insertion-mode-default"><a class="header" href="#a-automatic-insertion-mode-default">A. Automatic Insertion Mode (Default)</a></h3>
<p>In <strong>automatic</strong> mode, new windows are inserted according to one of three schemes that automatically determine where they should go:</p>
<p><strong>How Automatic Mode Works:</strong>
When in automatic insertion mode at node N, a new window takes the space of N, and N is displaced into a new branch. The tree automatically reorganizes to accommodate the new window.</p>
<p><strong>The Three Automatic Schemes:</strong></p>
<p><strong>1. Spiral Scheme (Default: “alternate”)</strong>
The spiral scheme creates a rotating pattern where windows are arranged in a spiral from outside inward (or inside outward, depending on <code>initial_polarity</code>). This is the most common and visually appealing default:</p>
<pre><code class="language-bash"># Enable spiral (alternate) scheme
bspc config automatic_scheme alternate

# How it works visually:
# With 4 windows:
#   ┌─────────────────┐
#   │       1         │
#   │  ┌────────┐     │
#   │  │   2    │  4  │
#   │  │ ┌──┐   │     │
#   │  │ │3 │   │     │
#   │  │ └──┘   │     │
#   │  └────────┘     │
#   └─────────────────┘

# Sxhkd binding to switch schemes
super + shift + a
    bspc config automatic_scheme alternate &amp;&amp; \
    notify-send "Spiral mode"
</code></pre>
<p><strong>2. Longest Side Scheme</strong>
The longest_side scheme always splits the longest side of the available rectangle, creating a more balanced layout:</p>
<pre><code class="language-bash"># Enable longest side scheme
bspc config automatic_scheme longest_side

# How it works: always splits the longest rectangle edge
# Tends to create more balanced, square-ish windows

# Practical comparison:
# Spiral creates:     │ Longest_side creates:
#    │ │ │ │ │         │  │  │
#    ├─┼─┼─┼─┤         ├──┼──┤
#    │ │ │ │ │         │  │  │
#    ├─┴─┴─┴─┤         └──┴──┘

super + shift + l
    bspc config automatic_scheme longest_side &amp;&amp; \
    notify-send "Longest side mode"
</code></pre>
<p><strong>3. Alternate Scheme</strong>
Alternates between horizontal and vertical splits in a consistent pattern:</p>
<pre><code class="language-bash"># Note: Recent versions use "alternate" for spiral
# Check documentation for your version
bspc config automatic_scheme spiral  # May be labeled "spiral" in newer versions
</code></pre>
<h3 id="b-manual-insertion-mode-preselection"><a class="header" href="#b-manual-insertion-mode-preselection">B. Manual Insertion Mode (Preselection)</a></h3>
<p>In <strong>manual</strong> mode, you explicitly specify where the next window should be placed using preselection. This allows precise control over window placement:</p>
<p><strong>How Manual Mode Works:</strong></p>
<ol>
<li>Select a node</li>
<li>Preselect a direction (north, south, east, west)</li>
<li>When a new window opens, it automatically appears in the preselected direction</li>
<li>The preselection is consumed and automatic mode resumes</li>
</ol>
<pre><code class="language-bash"># Enable preselection on focused node
bspc node -p west       # Next window splits to the west (left)
bspc node -p north      # Next window splits to the north (top)
bspc node -p south      # Next window splits to the south (bottom)
bspc node -p east       # Next window splits to the east (right)

# Cancel preselection
bspc node -p cancel

# Adjust preselection ratio (default 0.5)
bspc node -o 0.3        # Next window gets 30%, current gets 70%
bspc node -o 0.7        # Next window gets 70%, current gets 30%

# Example workflow:
# 1. Preselect split direction
bspc node -p west
# 2. Open new window (e.g., Alt+Enter in sxhkd)
# 3. New window appears to the west
# 4. Preselection is consumed, back to automatic mode
</code></pre>
<h3 id="c-configuration-options-for-insertion"><a class="header" href="#c-configuration-options-for-insertion">C. Configuration Options for Insertion</a></h3>
<pre><code class="language-bash"># Set automatic scheme
bspc config automatic_scheme {alternate|longest_side|spiral}

# Set initial polarity (where to attach on single-node tree)
bspc config initial_polarity first_child   # Attach as first child
bspc config initial_polarity second_child  # Attach as second child

# Set directional focus tightness (affects directional selection)
bspc config directional_focus_tightness high   # Strict direction matching
bspc config directional_focus_tightness low    # Loose direction matching

# Enable/disable removal adjustment
bspc config removal_adjustment true   # Adjust tree when removing windows
</code></pre>
<h3 id="d-practical-insertion-mode-usage"><a class="header" href="#d-practical-insertion-mode-usage">D. Practical Insertion Mode Usage</a></h3>
<pre><code class="language-bash"># Sxhkd complete example:
# Focus node and cycle insertion schemes
super + shift + {a,l,s}
    bspc config automatic_scheme {alternate,longest_side,spiral} &amp;&amp; \
    notify-send "Scheme: $(bspc config automatic_scheme)"

# Preselection workflow
super + ctrl + {h,j,k,l}
    bspc node -p {west,south,north,east}

# Clear preselection
super + ctrl + space
    bspc node -p cancel

# Adjust preselection ratio
super + {minus,equal}
    RATIO=$(bspc config split_ratio); \
    bspc config split_ratio $(bc &lt;&lt;&lt; "scale=2; $RATIO - 0.05") || \
    bspc config split_ratio $(bc &lt;&lt;&lt; "scale=2; $RATIO + 0.05")

# Open window (in preselection, goes to preselected location)
super + Return
    terminal
</code></pre>
<h2 id="viii-node-operations-commands-for-window-management"><a class="header" href="#viii-node-operations-commands-for-window-management">VIII. Node Operations: Commands for Window Management</a></h2>
<p>The <code>node</code> domain contains the most frequently used commands for managing individual windows.</p>
<h3 id="a-focus-operations"><a class="header" href="#a-focus-operations">A. Focus Operations</a></h3>
<p><strong>Focus</strong> moves keyboard and mouse input to a specific window:</p>
<pre><code class="language-bash"># Focus specific selector
bspc node SELECTOR -f

# Focus east window
bspc node east -f

# Focus the biggest window
bspc node biggest -f

# Focus floating windows
bspc node .floating -f

# Focus window by ID
bspc node 0x00800001 -f

# Focus and follow (for multi-monitor):
bspc node NODE_SEL -f --follow

# Sxhkd focus example:
super + {h,j,k,l}
    bspc node -f {west,south,north,east}

super + {comma,period}
    bspc node -f {prev,next}.local.!hidden.window

super + bracket{left,right}
    bspc desktop -f {prev,next}.local
</code></pre>
<h3 id="b-activation-operations"><a class="header" href="#b-activation-operations">B. Activation Operations</a></h3>
<p><strong>Activate</strong> sets a node as the active node of its desktop (for multi-monitor awareness):</p>
<pre><code class="language-bash"># Activate focused node
bspc node focused -a

# This differs from focus in multi-monitor setups
# Focus changes which window receives input
# Activate sets which is "most recent" on that desktop
</code></pre>
<h3 id="c-moving-windows-between-desktops"><a class="header" href="#c-moving-windows-between-desktops">C. Moving Windows Between Desktops</a></h3>
<p><strong>Send to Desktop</strong> moves a window to a different workspace:</p>
<pre><code class="language-bash"># Send to specific desktop
bspc node -d DESKTOP_SEL

# Send to desktop 2
bspc node -d ^2

# Send to named desktop
bspc node -d "work"

# Send and follow (keep focus on window)
bspc node -d ^2 --follow

# Sxhkd example:
super + shift + {1-9,0}
    bspc node -d '^{1-9,10}' --follow

# Move to next desktop
super + shift + bracket{left,right}
    bspc node -d {prev,next}.local --follow
</code></pre>
<h3 id="d-moving-windows-between-monitors"><a class="header" href="#d-moving-windows-between-monitors">D. Moving Windows Between Monitors</a></h3>
<p><strong>Send to Monitor</strong> moves windows to different physical displays:</p>
<pre><code class="language-bash"># Send to specific monitor
bspc node -m MONITOR_SEL

# Send to east monitor
bspc node -m east --follow

# Send to primary monitor
bspc node -m primary --follow

# Sxhkd example:
super + shift + m
    bspc node -m next --follow

# Send to specific monitor and follow
super + shift + {Left,Right}
    bspc node -m {west,east} --follow
</code></pre>
<h3 id="e-swapping-nodes"><a class="header" href="#e-swapping-nodes">E. Swapping Nodes</a></h3>
<p><strong>Swap</strong> exchanges the position of two nodes in the tree:</p>
<pre><code class="language-bash"># Swap with another node
bspc node -s NODE_SEL

# Swap with brother (sibling)
bspc node -s @brother

# Swap with previous window
bspc node -s prev

# Swap and follow (focus stays on window being swapped)
bspc node -s NODE_SEL --follow

# Practical example:
# Swap with biggest window
super + g
    bspc node -s biggest.window

# Swap with last focused
super + shift + g
    bspc node -s last
</code></pre>
<h3 id="f-resizing-and-adjusting-windows"><a class="header" href="#f-resizing-and-adjusting-windows">F. Resizing and Adjusting Windows</a></h3>
<p><strong>Move</strong> repositions floating windows:</p>
<pre><code class="language-bash"># Move floating window by pixels
bspc node -v dx dy

# Move left 20 pixels
bspc node -v -20 0

# Move down 20 pixels
bspc node -v 0 20

# Sxhkd example for floating window movement:
super + shift + {Left,Down,Up,Right}
    bspc node -v {-20 0,0 20,0 -20,20 0}
</code></pre>
<p><strong>Resize</strong> changes window dimensions:</p>
<pre><code class="language-bash"># Resize by moving a specific edge
bspc node -z EDGE dx dy

# EDGE options: top, left, bottom, right, top_left, top_right, bottom_left, bottom_right

# Expand bottom edge by 20 pixels
bspc node -z bottom 0 20

# Contract left edge by 20 pixels
bspc node -z left 20 0

# Sxhkd resizing mode:
super + alt + {h,j,k,l}
    bspc node -z {left -20 0,bottom 0 20,top 0 -20,right 20 0}

# Or contract:
super + alt + shift + {h,j,k,l}
    bspc node -z {left 20 0,bottom 0 -20,top 0 20,right -20 0}

# Continuous resize mode (like vim motions):
super + r : {h,j,k,l}
    bspc node -z {left -20 0,bottom 0 20,top 0 -20,right 20 0}
</code></pre>
<h3 id="g-managing-split-ratios-tiled-windows"><a class="header" href="#g-managing-split-ratios-tiled-windows">G. Managing Split Ratios (tiled windows)</a></h3>
<p><strong>Ratio</strong> adjusts how space is divided between windows:</p>
<pre><code class="language-bash"># Set specific ratio (0 &lt; ratio &lt; 1)
bspc node -r RATIO

# Set to 0.6 (60/40 split)
bspc node -r 0.6

# Adjust by relative amount
bspc node -r +0.05    # Increase ratio by 5%
bspc node -r -0.05    # Decrease ratio by 5%

# Change by pixel amount
bspc node -r +10px    # Increase by 10 pixels
bspc node -r -10px    # Decrease by 10 pixels

# Sxhkd ratio adjustment:
super + shift + {minus,equal}
    bspc node -r {-0.05,+0.05}

# Balance splits
super + b
    bspc node @focused -B
</code></pre>
<h3 id="h-tree-manipulation-operations"><a class="header" href="#h-tree-manipulation-operations">H. Tree Manipulation Operations</a></h3>
<p><strong>Rotate</strong> spins the tree structure at a node:</p>
<pre><code class="language-bash"># Rotate 90 degrees clockwise
bspc node -R 90

# Rotate 180 degrees
bspc node -R 180

# Rotate 270 degrees (or -90)
bspc node -R 270

# Sxhkd binding:
super + {comma,period}
    bspc node @focused -R {90,-90}
</code></pre>
<p><strong>Flip</strong> mirrors the tree:</p>
<pre><code class="language-bash"># Flip horizontally (left-right)
bspc node -F horizontal

# Flip vertically (top-bottom)
bspc node -F vertical

# Sxhkd bindings:
super + {slash,backslash}
    bspc node @focused -F {horizontal,vertical}
</code></pre>
<p><strong>Circulate</strong> rotates windows in the tree:</p>
<pre><code class="language-bash"># Circulate windows forward (clockwise)
bspc node -C forward

# Circulate windows backward (counter-clockwise)
bspc node -C backward

# Practical use: rotate order of windows without changing layout
super + shift + c
    bspc node -C forward

# This moves: window1 -&gt; window2 -&gt; window3 -&gt; window1
</code></pre>
<p><strong>Equalize</strong> resets all split ratios to default (0.5):</p>
<pre><code class="language-bash"># Reset all ratios in tree
bspc node -E

# Useful when tree becomes unbalanced
super + shift + e
    bspc node -E

# Undo manual resizing
</code></pre>
<p><strong>Balance</strong> adjusts ratios so all leaves occupy equal area:</p>
<pre><code class="language-bash"># Balance the tree
bspc node -B

# After resizing, rebalance:
super + shift + b
    bspc node -B

# Different from equalize:
# Equalize: all ratios = 0.5
# Balance: adjusts all ratios so leaf areas are equal
</code></pre>
<h3 id="i-window-state-and-flag-management"><a class="header" href="#i-window-state-and-flag-management">I. Window State and Flag Management</a></h3>
<p><strong>State</strong> changes window state:</p>
<pre><code class="language-bash"># Set specific state
bspc node -t STATE

# States: tiled, pseudo_tiled, floating, fullscreen

# Toggle to previous state
bspc node -t ~

# Toggle to specific state (if already in state, revert)
bspc node -t ~floating  # floating &lt;-&gt; previous state

# Sxhkd state cycling:
super + {t,shift+t,s,f}
    bspc node -t {tiled,pseudo_tiled,floating,fullscreen}

# Individual toggles:
super + shift + t
    bspc node -t floating
super + shift + f
    bspc node -t fullscreen
</code></pre>
<p><strong>Flag</strong> manages node flags:</p>
<pre><code class="language-bash"># Set flag on/off
bspc node -g FLAG={on|off}

# Toggle flag
bspc node -g FLAG

# Flags: hidden, sticky, private, locked, marked, urgent

# Examples:
bspc node -g hidden=on       # Hide window
bspc node -g locked=toggle   # Toggle lock
bspc node -g marked          # Mark (toggle)

# Sxhkd bindings:
super + ctrl + {m,x,y,z}
    bspc node -g {marked,locked,sticky,private}

# Sticky window:
super + shift + s
    bspc node -g sticky=toggle
</code></pre>
<p><strong>Layer</strong> sets stacking layer:</p>
<pre><code class="language-bash"># Set layer
bspc node -l LAYER

# Layers: below, normal, above

bspc node -l above    # Always on top
bspc node -l normal   # Standard (default)
bspc node -l below    # Background

# Sxhkd binding:
super + {comma,period}
    bspc node -l {below,above}
</code></pre>
<h3 id="j-closing-and-killing-windows"><a class="header" href="#j-closing-and-killing-windows">J. Closing and Killing Windows</a></h3>
<p><strong>Close</strong> sends a close signal to the window:</p>
<pre><code class="language-bash"># Close focused window (gracefully)
bspc node -c

# Close window by selector
bspc node NODE_SEL -c

# Sxhkd:
super + shift + w
    bspc node -c
</code></pre>
<p><strong>Kill</strong> forcefully terminates the window:</p>
<pre><code class="language-bash"># Kill focused window
bspc node -k

# Kill all windows on desktop
bspc node -k

# Use kill when close doesn't work
super + shift + q
    bspc node -k
</code></pre>
<h3 id="k-inserting-and-managing-receptacles"><a class="header" href="#k-inserting-and-managing-receptacles">K. Inserting and Managing Receptacles</a></h3>
<p><strong>Insert Receptacle</strong> creates empty placeholder nodes:</p>
<pre><code class="language-bash"># Insert receptacle at focused node location
bspc node -i

# Build layout with receptacles before opening windows
bspc node -i; bspc node -i; bspc node -i

# Then open windows and they fill receptacles

# Script to create grid layout:
#!/bin/bash
# Create 2x2 grid of receptacles
bspc desktop -l tiled
for i in {1..3}; do bspc node -i; done
</code></pre>
<h2 id="ix-desktop-operations-workspace-management"><a class="header" href="#ix-desktop-operations-workspace-management">IX. Desktop Operations: Workspace Management</a></h2>
<p>The <code>desktop</code> domain manages virtual desktops/workspaces.</p>
<h3 id="a-creating-and-managing-desktops"><a class="header" href="#a-creating-and-managing-desktops">A. Creating and Managing Desktops</a></h3>
<p><strong>Add Desktops</strong> to a monitor:</p>
<pre><code class="language-bash"># Create desktops
bspc monitor -a NAMES

# Add desktops to current monitor
bspc monitor -a I II III IV V

# Multiple desktops at once:
bspc monitor -a I II III IV V VI VII VIII IX X

# Sxhkd configuration (in bspwmrc):
bspc monitor -a 1 2 3 4 5 6 7 8 9 10
</code></pre>
<p><strong>Reset Desktops</strong> to match a list:</p>
<pre><code class="language-bash"># Replace desktop list
bspc monitor -d NAMES

# Removes, adds, or renames desktops to match list
bspc monitor -d one two three
</code></pre>
<p><strong>Rename Desktop:</strong></p>
<pre><code class="language-bash"># Rename desktop
bspc desktop -n NAME

# Example:
bspc desktop -n "work"
bspc desktop ^2 -n "media"
</code></pre>
<p><strong>Remove Desktop:</strong></p>
<pre><code class="language-bash"># Remove empty desktop
bspc desktop -r

# Remove desktop 5
bspc desktop ^5 -r
</code></pre>
<h3 id="b-focusing-desktops"><a class="header" href="#b-focusing-desktops">B. Focusing Desktops</a></h3>
<p><strong>Focus Desktop:</strong></p>
<pre><code class="language-bash"># Focus specific desktop
bspc desktop SELECTOR -f

# Focus desktop 2
bspc desktop ^2 -f

# Focus next desktop
bspc desktop next -f

# Focus previous
bspc desktop prev -f

# Focus by name
bspc desktop "work" -f

# Sxhkd bindings:
super + {1-9,0}
    bspc desktop -f '^{1-9,10}'

# Cycle through desktops
super + {Right,Left}
    bspc desktop -f {next,prev}.local
</code></pre>
<h3 id="c-desktop-layout"><a class="header" href="#c-desktop-layout">C. Desktop Layout</a></h3>
<p><strong>Layout</strong> switches between tiling modes:</p>
<pre><code class="language-bash"># Switch layout
bspc desktop -l LAYOUT

# Layouts: tiled (default), monocle

# Set to monocle (one window fullscreen)
bspc desktop -l monocle

# Cycle layout
bspc desktop -l next

# Sxhkd:
super + m
    bspc desktop -l next

# Or explicit:
super + {t,f}
    bspc desktop -l {tiled,monocle}
</code></pre>
<p><strong>Monocle Layout Options:</strong></p>
<pre><code class="language-bash"># Borderless monocle (no window borders)
bspc config borderless_monocle true

# Gapless monocle (no gaps)
bspc config gapless_monocle true

# Padding in monocle
bspc config top_monocle_padding 20
bspc config left_monocle_padding 20
bspc config right_monocle_padding 20
bspc config bottom_monocle_padding 20

# Single window uses monocle
bspc config single_monocle true
</code></pre>
<h3 id="d-moving-and-swapping-desktops"><a class="header" href="#d-moving-and-swapping-desktops">D. Moving and Swapping Desktops</a></h3>
<p><strong>Send Node to Desktop:</strong></p>
<pre><code class="language-bash"># Send focused window to desktop
bspc node -d DESKTOP_SEL

# Send to desktop 2
bspc node -d ^2

# Send and follow (keep focus on window)
bspc node -d ^2 --follow

# Send to named desktop
bspc node -d "work" --follow

# Sxhkd example:
super + shift + {1-9,0}
    bspc node -d '^{1-9,10}' --follow
</code></pre>
<p><strong>Swap Desktops:</strong></p>
<pre><code class="language-bash"># Swap position of two desktops
bspc desktop -s DESKTOP_SEL

# Swap focused with desktop 2
bspc desktop -s ^2

# Sxhkd:
super + shift + {Left,Right}
    bspc desktop -s {prev,next}.local
</code></pre>
<p><strong>Move Desktop to Monitor:</strong></p>
<pre><code class="language-bash"># Move desktop to different monitor
bspc desktop -m MONITOR_SEL

# Move desktop to east monitor
bspc desktop -m east

# Sxhkd:
super + alt + {Left,Right}
    bspc desktop -m {west,east}
</code></pre>
<h3 id="e-bubble-and-reorder-desktops"><a class="header" href="#e-bubble-and-reorder-desktops">E. Bubble and Reorder Desktops</a></h3>
<p><strong>Bubble</strong> moves desktop in focus order:</p>
<pre><code class="language-bash"># Bubble left (move before previous)
bspc desktop -b prev

# Bubble right (move after next)
bspc desktop -b next

# Sxhkd:
super + shift + {comma,period}
    bspc desktop -b {prev,next}
</code></pre>
<h2 id="x-monitor-operations-multi-display-management"><a class="header" href="#x-monitor-operations-multi-display-management">X. Monitor Operations: Multi-Display Management</a></h2>
<p>Monitor operations manage physical displays or virtual outputs.</p>
<h3 id="a-monitor-configuration"><a class="header" href="#a-monitor-configuration">A. Monitor Configuration</a></h3>
<p><strong>Add Monitor:</strong></p>
<pre><code class="language-bash"># Add virtual monitor
bspc wm -a NAME WIDTHxHEIGHT+X+Y

# Example: virtual 1920x1080 at position 0,0
bspc wm -a virtual_monitor 1920x1080+0+0
</code></pre>
<p><strong>Reset Monitor Rectangle:</strong></p>
<pre><code class="language-bash"># Set monitor dimensions and position
bspc monitor -g WIDTHxHEIGHT+X+Y

# Set to 1920x1080 at 0,0
bspc monitor -g 1920x1080+0+0

# Get current monitor dimensions
bspc query -M -m focused -T | jq '.rectangle'
</code></pre>
<p><strong>Rename Monitor:</strong></p>
<pre><code class="language-bash"># Rename monitor
bspc monitor -n NAME

# Rename primary monitor
bspc monitor primary -n "Main"
</code></pre>
<p><strong>Remove Monitor:</strong></p>
<pre><code class="language-bash"># Remove monitor
bspc monitor -r

# Must be empty or desktops transferred first
</code></pre>
<h3 id="b-focus-and-swap"><a class="header" href="#b-focus-and-swap">B. Focus and Swap</a></h3>
<p><strong>Focus Monitor:</strong></p>
<pre><code class="language-bash"># Focus specific monitor
bspc monitor SELECTOR -f

# Focus east monitor
bspc monitor east -f

# Focus primary
bspc monitor primary -f

# Focus next monitor
bspc monitor next -f

# Sxhkd:
super + shift + {h,j,k,l}
    bspc monitor -f {west,south,north,east}
</code></pre>
<p><strong>Swap Monitors:</strong></p>
<pre><code class="language-bash"># Swap positions of monitors
bspc monitor -s MONITOR_SEL

# Swap with east monitor
bspc monitor -s east

# Sxhkd:
super + shift + m
    bspc monitor -s next
</code></pre>
<h3 id="c-monitor-specific-configuration"><a class="header" href="#c-monitor-specific-configuration">C. Monitor-Specific Configuration</a></h3>
<pre><code class="language-bash"># Set padding per monitor
bspc config -m MONITOR top_padding 20

# Set for specific monitor
bspc config -m primary top_padding 20

# Window gap per monitor
bspc config -m eDP1 window_gap 10
</code></pre>
<h2 id="xi-query-operations-inspecting-the-window-tree"><a class="header" href="#xi-query-operations-inspecting-the-window-tree">XI. Query Operations: Inspecting the Window Tree</a></h2>
<p>The <code>query</code> domain allows you to inspect and extract information about the window tree.</p>
<h3 id="a-querying-nodes"><a class="header" href="#a-querying-nodes">A. Querying Nodes</a></h3>
<p><strong>Query Nodes:</strong></p>
<pre><code class="language-bash"># List node IDs matching selector
bspc query -N -n SELECTOR

# Get focused window ID
bspc query -N -n focused

# Get all tiled windows
bspc query -N -n .tiled

# Get all windows on current desktop
bspc query -N -d focused

# Use in scripts:
FOCUSED_ID=$(bspc query -N -n focused)
echo "Focused window ID: $FOCUSED_ID"

# Get multiple nodes:
for node in $(bspc query -N -n .floating); do
    echo "Floating window: $node"
done
</code></pre>
<h3 id="b-querying-desktops"><a class="header" href="#b-querying-desktops">B. Querying Desktops</a></h3>
<p><strong>Query Desktops:</strong></p>
<pre><code class="language-bash"># List desktop names
bspc query -D --names

# List desktop IDs
bspc query -D

# Get occupied desktops
bspc query -D -d .occupied

# Get empty desktops
bspc query -D -d .!occupied

# Get urgent desktops
bspc query -D -d .urgent

# Script example:
EMPTY_DESK=$(bspc query -D -d .!occupied | head -1)
echo "First empty desktop: $EMPTY_DESK"
</code></pre>
<h3 id="c-querying-monitors"><a class="header" href="#c-querying-monitors">C. Querying Monitors</a></h3>
<p><strong>Query Monitors:</strong></p>
<pre><code class="language-bash"># List monitor names
bspc query -M --names

# List monitor IDs
bspc query -M

# Get focused monitor
bspc query -M -m focused --names

# Get all monitors
for monitor in $(bspc query -M); do
    echo "Monitor: $monitor"
done
</code></pre>
<h3 id="d-tree-visualization"><a class="header" href="#d-tree-visualization">D. Tree Visualization</a></h3>
<p><strong>Query Tree:</strong></p>
<pre><code class="language-bash"># Print entire tree as JSON
bspc query -T

# Query desktop tree
bspc query -T -d focused

# Query node subtree
bspc query -T -n focused

# Pretty print with jq:
bspc query -T -d focused | jq .

# Extract specific info:
bspc query -T | jq '..[].id'  # All node IDs
bspc query -T | jq '..[].client.class'  # All window classes
</code></pre>
<h2 id="xii-window-rules-automatic-window-configuration"><a class="header" href="#xii-window-rules-automatic-window-configuration">XII. Window Rules: Automatic Window Configuration</a></h2>
<p>Rules apply automatic configurations to windows based on matching criteria.</p>
<h3 id="a-built-in-rules"><a class="header" href="#a-built-in-rules">A. Built-in Rules</a></h3>
<p><strong>Basic Rule Syntax:</strong></p>
<pre><code class="language-bash">bspc rule -a CLASS[:INSTANCE[:NAME]] [options]

# Options:
# State: state=STATE (tiled|pseudo_tiled|floating|fullscreen)
# Desktop: desktop=DESKTOP_SEL
# Monitor: monitor=MONITOR_SEL
# Flags: hidden=on|off, sticky=on|off, private=on|off, locked=on|off, marked=on|off
# Layer: layer=LAYER (below|normal|above)
# Splitting: split_dir=DIR, split_ratio=RATIO
# Size hints: honor_size_hints=true|false|tiled|floating
# Layout: rectangle=WxH+X+Y (for floating windows)
# Other: center=on|off, follow=on|off, manage=on|off, focus=on|off, border=on|off

# One-shot: -o|--one-shot (applies only once)
</code></pre>
<h3 id="b-creating-rules"><a class="header" href="#b-creating-rules">B. Creating Rules</a></h3>
<p><strong>Common Rule Examples:</strong></p>
<pre><code class="language-bash"># Firefox always opens on desktop 2
bspc rule -a Firefox desktop=^2

# GIMP tools floating, sticky
bspc rule -a Gimp -t floating -g sticky=on

# Media player fullscreen
bspc rule -a vlc -t fullscreen

# Dialog windows floating
bspc rule -a '*' -t floating -o  # One-shot for unmatched dialogs

# Locked terminal
bspc rule -a Termite -g locked=on

# Application on specific monitor
bspc rule -a Firefox monitor=HDMI-1

# Combination rule
bspc rule -a libreoffice \
    -t pseudo_tiled \
    desktop=^3 \
    -g sticky=on \
    split_ratio=0.7

# Multiple class selectors
bspc rule -a {Firefox,Chrome} desktop=^2
</code></pre>
<h3 id="c-matching-patterns"><a class="header" href="#c-matching-patterns">C. Matching Patterns</a></h3>
<p><strong>Class Matching:</strong></p>
<pre><code class="language-bash"># Exact class match
bspc rule -a Firefox state=floating

# Class and instance
bspc rule -a Firefox:Preferences state=floating

# Class, instance, and name
bspc rule -a "VLC:vlc::*" state=floating

# Wildcard patterns
bspc rule -a "*" state=floating -o  # Fallback rule
bspc rule -a "* notification*" state=floating layer=above

# Negation
bspc rule -a Firefox -r  # Remove Firefox rules
</code></pre>
<h3 id="d-list-and-manage-rules"><a class="header" href="#d-list-and-manage-rules">D. List and Manage Rules</a></h3>
<p><strong>Rule Management:</strong></p>
<pre><code class="language-bash"># List all rules
bspc rule -l

# List rules numbered
bspc rule -l | cat -n

# Remove rule by pattern
bspc rule -r Firefox

# Remove rule by number
bspc rule -r ^3

# Remove all rules
bspc rule -r '*'

# Remove specific rules
bspc rule -r Firefox Chromium
</code></pre>
<h3 id="e-external-rules-command"><a class="header" href="#e-external-rules-command">E. External Rules Command</a></h3>
<p>For more complex rules, use an external script:</p>
<pre><code class="language-bash"># Configure external rules
bspc config external_rules_command ~/.config/bspwm/external_rules

# Script receives: WID CLASS INSTANCE [INTERMEDIATE_RULES]
# Output format: key1=value1 key2=value2 ...

# Example external_rules script:
#!/bin/bash

wid=$1
class=$2
instance=$3

# Get window geometry with xdotool
geometry=$(xdotool getwindowgeometry "$wid" | awk '/Geometry/ {print $2}')

# Custom logic
if [[ "$class" == "Firefox" ]]; then
    echo "desktop=^2"
elif [[ "$geometry" == "1920x1080"* ]]; then
    # Large window - make floating
    echo "state=floating"
fi

# Can be very complex:
if xdotool getwindowname "$wid" | grep -q "Settings"; then
    echo "state=floating layer=above center=on"
fi

# Make executable:
chmod +x ~/.config/bspwm/external_rules
</code></pre>
<h2 id="xiii-events-and-subscriptions-reactive-programming-with-bspwm"><a class="header" href="#xiii-events-and-subscriptions-reactive-programming-with-bspwm">XIII. Events and Subscriptions: Reactive Programming with BSPWM</a></h2>
<p>BSPWM generates comprehensive events for every state change, enabling real-time monitoring and scripting.</p>
<h3 id="a-event-types"><a class="header" href="#a-event-types">A. Event Types</a></h3>
<p><strong>Available Events:</strong></p>
<pre><code>Monitor Events:
- monitor_add &lt;monitor_id&gt; &lt;name&gt; &lt;geometry&gt;
- monitor_remove &lt;monitor_id&gt;
- monitor_swap &lt;src_monitor_id&gt; &lt;dst_monitor_id&gt;
- monitor_focus &lt;monitor_id&gt;
- monitor_geometry &lt;monitor_id&gt; &lt;geometry&gt;
- monitor_rename &lt;monitor_id&gt; &lt;old_name&gt; &lt;new_name&gt;

Desktop Events:
- desktop_add &lt;monitor_id&gt; &lt;desktop_id&gt; &lt;name&gt;
- desktop_remove &lt;monitor_id&gt; &lt;desktop_id&gt;
- desktop_swap &lt;src_monitor_id&gt; &lt;src_desktop_id&gt; &lt;dst_monitor_id&gt; &lt;dst_desktop_id&gt;
- desktop_transfer &lt;src_monitor_id&gt; &lt;src_desktop_id&gt; &lt;dst_monitor_id&gt;
- desktop_focus &lt;monitor_id&gt; &lt;desktop_id&gt;
- desktop_activate &lt;monitor_id&gt; &lt;desktop_id&gt;
- desktop_layout &lt;monitor_id&gt; &lt;desktop_id&gt; &lt;layout&gt;
- desktop_rename &lt;monitor_id&gt; &lt;desktop_id&gt; &lt;old_name&gt; &lt;new_name&gt;

Node Events:
- node_add &lt;monitor_id&gt; &lt;desktop_id&gt; &lt;ip_id&gt; &lt;node_id&gt;
- node_remove &lt;monitor_id&gt; &lt;desktop_id&gt; &lt;node_id&gt;
- node_swap &lt;src_monitor_id&gt; &lt;src_desktop_id&gt; &lt;src_node_id&gt; &lt;dst_monitor_id&gt; &lt;dst_desktop_id&gt; &lt;dst_node_id&gt;
- node_transfer &lt;src_monitor_id&gt; &lt;src_desktop_id&gt; &lt;src_node_id&gt; &lt;dst_monitor_id&gt; &lt;dst_desktop_id&gt; &lt;dst_node_id&gt;
- node_focus &lt;monitor_id&gt; &lt;desktop_id&gt; &lt;node_id&gt;
- node_activate &lt;monitor_id&gt; &lt;desktop_id&gt; &lt;node_id&gt;
- node_presel &lt;monitor_id&gt; &lt;desktop_id&gt; &lt;node_id&gt; (dir DIR|ratio RATIO|cancel)
- node_stack &lt;node_id_1&gt; (below|above) &lt;node_id_2&gt;
- node_geometry &lt;monitor_id&gt; &lt;desktop_id&gt; &lt;node_id&gt; &lt;geometry&gt;
- node_state &lt;monitor_id&gt; &lt;desktop_id&gt; &lt;node_id&gt; &lt;state&gt; (on|off)
- node_flag &lt;monitor_id&gt; &lt;desktop_id&gt; &lt;node_id&gt; &lt;flag&gt; (on|off)
- node_layer &lt;monitor_id&gt; &lt;desktop_id&gt; &lt;node_id&gt; &lt;layer&gt;
- pointer_action &lt;monitor_id&gt; &lt;desktop_id&gt; &lt;node_id&gt; &lt;action&gt; (begin|end)
</code></pre>
<h3 id="b-subscribing-to-events"><a class="header" href="#b-subscribing-to-events">B. Subscribing to Events</a></h3>
<p><strong>Basic Subscribe:</strong></p>
<pre><code class="language-bash"># Subscribe to specific event type
bspc subscribe node_add | while read -a msg; do
    # msg array contains: monitor_id desktop_id ip_id node_id
    node_id="${msg[^1_4]}"
    echo "New node added: $node_id"
    # Perform action
done

# Subscribe to multiple event types
bspc subscribe node_add node_remove | while read -a msg; do
    event_type="${msg[^1_0]}"
    case "$event_type" in
        node_add)
            echo "Node added"
            ;;
        node_remove)
            echo "Node removed"
            ;;
    esac
done

# Subscribe to all events
bspc subscribe all | while read line; do
    echo "$line"
done
</code></pre>
<h3 id="c-practical-event-scripts"><a class="header" href="#c-practical-event-scripts">C. Practical Event Scripts</a></h3>
<p><strong>Example 1: Auto-fullscreen New Windows:</strong></p>
<pre><code class="language-bash">#!/bin/bash
# Make every new window fullscreen automatically

bspc subscribe node_add | while read -a msg; do
    monitor_id="${msg[^1_1]}"
    desktop_id="${msg[^1_2]}"
    node_id="${msg[^1_4]}"
    
    # Auto-fullscreen
    bspc node "$node_id" -t fullscreen
done
</code></pre>
<p><strong>Example 2: Auto-floating by Window Class:</strong></p>
<pre><code class="language-bash">#!/bin/bash
# Make certain applications floating automatically

FLOATING_APPS=("mpv" "VLC" "Zathura")

bspc subscribe node_add | while read -a msg; do
    node_id="${msg[^1_4]}"
    
    # Get window class (requires extra lookup)
    class=$(xdotool getactivewindow getwindowname 2&gt;/dev/null || echo "")
    
    for app in "${FLOATING_APPS[@]}"; do
        if [[ "$class" == *"$app"* ]]; then
            bspc node "$node_id" -t floating
            break
        fi
    done
done
</code></pre>
<p><strong>Example 3: Status Bar Integration:</strong></p>
<pre><code class="language-bash">#!/bin/bash
# Update polybar on window events

bspc subscribe node_focus desktop_focus | while read -a msg; do
    # Update status bar
    pkill -SIGUSR1 polybar
    
    # Or update custom status
    echo "$(date): $(bspc query -N -n focused)" &gt; /tmp/bspwm_status
done
</code></pre>
<p><strong>Example 4: Sticky Window Management:</strong></p>
<pre><code class="language-bash">#!/bin/bash
# Automatically make certain windows sticky

bspc subscribe node_add node_focus | while read -a msg; do
    node_id="${msg[^1_4]}"
    
    # Make all floating windows sticky automatically
    state=$(bspc query -N -n "$node_id" -T | jq -r '.client.state')
    
    if [[ "$state" == "floating" ]]; then
        bspc node "$node_id" -g sticky=on
    fi
done
</code></pre>
<h3 id="d-using-fifo-for-event-processing"><a class="header" href="#d-using-fifo-for-event-processing">D. Using FIFO for Event Processing</a></h3>
<p>Alternative method using named pipes:</p>
<pre><code class="language-bash"># Get FIFO path
FIFO_PATH=$(bspc --print-socket-path)

# Create monitoring script
#!/bin/bash
bspc subscribe -f | nc -l localhost 5000 &amp;

# In another terminal, connect:
nc localhost 5000 | while read event; do
    echo "$event"
done
</code></pre>
<h2 id="xiv-configuration-settings-customizing-bspwm-behavior"><a class="header" href="#xiv-configuration-settings-customizing-bspwm-behavior">XIV. Configuration Settings: Customizing BSPWM Behavior</a></h2>
<p>BSPWM provides numerous settings to customize appearance and behavior.</p>
<h3 id="a-global-settings"><a class="header" href="#a-global-settings">A. Global Settings</a></h3>
<p><strong>Color Settings:</strong></p>
<pre><code class="language-bash"># Set border colors (in hex #RRGGBB)
bspc config normal_border_color "#484848"           # Unfocused, unfocused monitor
bspc config focused_border_color "#1F8999"          # Focused, focused monitor
bspc config active_border_color "#CCCCCC"           # Focused, unfocused monitor
bspc config presel_feedback_color "#7C7C7C"         # Preselection area

# Practical configuration:
bspc config normal_border_color "#3c3836"
bspc config focused_border_color "#d79921"
bspc config active_border_color "#a89984"
bspc config presel_feedback_color "#458588"

# Test colors in terminal:
bspc config normal_border_color "#FF0000"  # Test red
# Changes apply immediately to new windows
</code></pre>
<p><strong>Dimension Settings:</strong></p>
<pre><code class="language-bash"># Border width
bspc config border_width 2              # 0-10 pixels

# Window gap (space between windows)
bspc config window_gap 10               # Default: 12

# Padding (space from screen edge)
bspc config top_padding 20
bspc config bottom_padding 0
bspc config left_padding 0
bspc config right_padding 0

# Combined padding:
for side in top right bottom left; do
    bspc config "${side}_padding" 20
done

# Per-monitor padding:
bspc config -m HDMI-1 top_padding 30
</code></pre>
<p><strong>Insertion and Splitting:</strong></p>
<pre><code class="language-bash"># Default split ratio
bspc config split_ratio 0.5            # 0 &lt; ratio &lt; 1

# Automatic insertion scheme
bspc config automatic_scheme alternate  # or longest_side

# Initial attachment direction
bspc config initial_polarity first_child  # or second_child

# Directional focus strictness
bspc config directional_focus_tightness high  # or low

# Removal behavior
bspc config removal_adjustment true
</code></pre>
<p><strong>Layout Options:</strong></p>
<pre><code class="language-bash"># Monocle-specific settings
bspc config borderless_monocle true     # Remove borders in monocle
bspc config gapless_monocle true        # Remove gaps in monocle

# Monocle padding
bspc config top_monocle_padding 20
bspc config bottom_monocle_padding 0
bspc config left_monocle_padding 0
bspc config right_monocle_padding 0

# Single window behavior
bspc config single_monocle false        # Switch to monocle with 1 window

# Singleton settings
bspc config borderless_singleton true   # Remove border on single window
</code></pre>
<h3 id="b-focus-and-click-behavior"><a class="header" href="#b-focus-and-click-behavior">B. Focus and Click Behavior</a></h3>
<pre><code class="language-bash"># Focus follows mouse pointer
bspc config focus_follows_pointer true

# Mouse moves to focused window
bspc config pointer_follows_focus false

# Mouse moves when focus changes to different monitor
bspc config pointer_follows_monitor false

# Click button to focus
bspc config click_to_focus button1     # button1, button2, button3, any, none

# Don't replay click that gave focus
bspc config swallow_first_click true
</code></pre>
<h3 id="c-pointer-and-mouse-settings"><a class="header" href="#c-pointer-and-mouse-settings">C. Pointer and Mouse Settings</a></h3>
<pre><code class="language-bash"># Pointer movement interval (milliseconds)
bspc config pointer_motion_interval 10  # Minimum between motion events

# Modifier key for pointer actions (Alt=mod1, Super=mod4, etc.)
bspc config pointer_modifier mod4

# Pointer actions (button 1, 2, 3)
bspc config pointer_action1 move        # Super+button1: move window
bspc config pointer_action2 resize_side # Super+button2: resize side
bspc config pointer_action3 resize_corner  # Super+button3: resize corner

# Possible values: move, resize_side, resize_corner, focus, none

# Example for alternative bindings:
bspc config pointer_modifier mod1       # Alt instead of Super
bspc config pointer_action1 focus       # Just focus, don't move
bspc config pointer_action2 move
bspc config pointer_action3 resize_corner
</code></pre>
<h3 id="d-ewmh-and-compatibility-settings"><a class="header" href="#d-ewmh-and-compatibility-settings">D. EWMH and Compatibility Settings</a></h3>
<pre><code class="language-bash"># Ignore EWMH focus requests from applications
bspc config ignore_ewmh_focus true

# Ignore EWMH fullscreen requests
bspc config ignore_ewmh_fullscreen none    # none, all, or: enter,exit

# Ignore window struts (panel reservations)
bspc config ignore_ewmh_struts false

# Example: allow fullscreen but not fullscreen changes
bspc config ignore_ewmh_fullscreen "exit"  # Ignore exit, allow enter

# Pseudo-tiled centering
bspc config center_pseudo_tiled true
</code></pre>
<h3 id="e-monitor-management"><a class="header" href="#e-monitor-management">E. Monitor Management</a></h3>
<pre><code class="language-bash"># Remove disabled monitors
bspc config remove_disabled_monitors false

# Remove unplugged monitors
bspc config remove_unplugged_monitors true

# Merge overlapping monitors
bspc config merge_overlapping_monitors true

# Mapping events to handle
bspc config mapping_events_count -1     # -1 = all events
</code></pre>
<h3 id="f-history-recording"><a class="header" href="#f-history-recording">F. History Recording</a></h3>
<pre><code class="language-bash"># Record focus history
bspc config record_history true

# Use in scripts:
bspc wm -h on    # Enable history recording
bspc node older -f  # Focus previously focused
bspc wm -h off   # Disable history
</code></pre>
<h3 id="g-size-hints"><a class="header" href="#g-size-hints">G. Size Hints</a></h3>
<pre><code class="language-bash"># Honor window size hints (ICCCM hints)
bspc config honor_size_hints false

# Options:
# false: ignore all hints
# true: apply to all windows
# tiled: apply only to tiled windows
# floating: apply only to floating windows
# floating|tiled: apply to both

# Example:
bspc config honor_size_hints floating   # Dialogs respect requested size
</code></pre>
<h3 id="h-practical-configuration-file-example"><a class="header" href="#h-practical-configuration-file-example">H. Practical Configuration File Example</a></h3>
<pre><code class="language-bash">#!/bin/bash
# ~/.config/bspwm/bspwmrc

# Monitor setup
bspc monitor -d I II III IV V VI VII VIII IX X

# Appearance
bspc config border_width 2
bspc config window_gap 10
bspc config split_ratio 0.5

bspc config normal_border_color "#3c3836"
bspc config focused_border_color "#d79921"
bspc config active_border_color "#a89984"

# Layout
bspc config borderless_monocle false
bspc config gapless_monocle false

# Behavior
bspc config automatic_scheme alternate
bspc config split_ratio 0.5
bspc config focus_follows_pointer true

# Rules
bspc rule -a Firefox desktop=^2
bspc rule -a Gimp state=floating sticky=on
bspc rule -a mpv state=floating

# Start additional daemons
sxhkd &amp;
polybar main &amp;
</code></pre>
<h2 id="xv-query-and-world-state-management"><a class="header" href="#xv-query-and-world-state-management">XV. Query and World State Management</a></h2>
<p>Advanced commands for inspecting and managing BSPWM’s global state.</p>
<h3 id="a-dumping-and-loading-state"><a class="header" href="#a-dumping-and-loading-state">A. Dumping and Loading State</a></h3>
<p><strong>Dump State:</strong></p>
<pre><code class="language-bash"># Get current state as JSON
bspc wm -d &gt; state.json

# This includes:
# - Monitor configuration
# - Desktop hierarchy
# - Window tree structure
# - Focus history
# - All settings

# Inspect structure:
bspc wm -d | jq '.' | less
</code></pre>
<p><strong>Load State:</strong></p>
<pre><code class="language-bash"># Restore state from file
bspc wm -l /path/to/state.json

# Requires absolute path
bspc wm -l ~/.config/bspwm/layouts/default.json

# Used internally for restart:
bspc wm -r  # Dumps state, restarts, loads state
</code></pre>
<h3 id="b-report-format"><a class="header" href="#b-report-format">B. Report Format</a></h3>
<p><strong>Status Messages:</strong></p>
<pre><code class="language-bash"># Get current status
bspc wm -g

# Returns format: M&lt;name&gt;:O&lt;name&gt;:F&lt;name&gt;:...

# Report format codes:
# M&lt;name&gt;    - Focused monitor
# m&lt;name&gt;    - Unfocused monitor
# O&lt;name&gt;    - Occupied focused desktop
# o&lt;name&gt;    - Occupied unfocused desktop
# F&lt;name&gt;    - Free focused desktop
# f&lt;name&gt;    - Free unfocused desktop
# U&lt;name&gt;    - Urgent focused desktop
# u&lt;name&gt;    - Urgent unfocused desktop
# L&lt;T|M&gt;     - Layout (T=tiled, M=monocle)
# T&lt;T|P|F|=|@&gt;  - Node state (T=tiled, P=pseudo-tiled, F=floating, ==fullscreen, @=manual)
# G&lt;flags&gt;   - Flags

# Example script to parse:
#!/bin/bash
bspc wm -g | while IFS=: read -ra items; do
    for item in "${items[@]}"; do
        type="${item:0:1}"
        value="${item:1}"
        
        case "$type" in
            M) echo "Focused monitor: $value" ;;
            O) echo "Occupied desktop: $value" ;;
            L) echo "Layout: $value" ;;
        esac
    done
done
</code></pre>
<h3 id="c-world-state-operations"><a class="header" href="#c-world-state-operations">C. World State Operations</a></h3>
<p><strong>Restart BSPWM:</strong></p>
<pre><code class="language-bash"># Restart, preserving all state
bspc wm -r

# Equivalent to:
# 1. Dump state
# 2. Kill bspwm
# 3. Restart bspwm
# 4. Load state

# Sxhkd binding:
super + alt + r
    bspc wm -r
</code></pre>
<p><strong>Adopt Orphans:</strong></p>
<pre><code class="language-bash"># Manage windows from previous session
bspc wm -o

# If X session crashed, windows still exist
# This command brings them under BSPWM management
</code></pre>
<h2 id="xvi-practical-sxhkd-configuration-for-bspwm"><a class="header" href="#xvi-practical-sxhkd-configuration-for-bspwm">XVI. Practical Sxhkd Configuration for BSPWM</a></h2>
<p>A complete, real-world sxhkd configuration demonstrating all major bindings.</p>
<h3 id="a-complete-sxhkd-configuration-example"><a class="header" href="#a-complete-sxhkd-configuration-example">A. Complete Sxhkd Configuration Example</a></h3>
<pre><code class="language-bash">#!/bin/bash
# ~/.config/sxhkd/sxhkdrc

# Application launching
super + Return
    kitty

super + d
    rofi -show drun

super + slash
    sxhkd-help

# WM control
super + alt + {q,r}
    bspc {quit,wm -r}

# Window state
super + {t,shift+t,s,f}
    bspc node -t {tiled,pseudo_tiled,floating,fullscreen}

# Window flags
super + ctrl + {m,x,y,z}
    bspc node -g {marked,locked,sticky,private}

# Focus operations
super + {h,j,k,l}
    bspc node -f {west,south,north,east}

super + {comma,period}
    bspc node -f {prev,next}.local.!hidden.window

super + shift + {h,j,k,l}
    bspc node -s {west,south,north,east}

super + g
    bspc node -s biggest.window

# Desktop navigation
super + {1-9,0}
    bspc desktop -f '^{1-9,10}'

super + bracket{left,right}
    bspc desktop -f {prev,next}.local

super + shift + {1-9,0}
    bspc node -d '^{1-9,10}' --follow

# Preselection (manual splitting)
super + ctrl + {h,j,k,l}
    bspc node -p {west,south,north,east}

super + ctrl + space
    bspc node -p cancel

super + ctrl + {minus,equal}
    bspc config split_ratio $(bspc config split_ratio){-,+}$(echo 0.05)

# Floating window management
super + shift + {Left,Down,Up,Right}
    bspc node -v {-20 0,0 20,0 -20,20 0}

super + alt + {h,j,k,l}
    bspc node -z {left -20 0,bottom 0 20,top 0 -20,right 20 0}

# Tree manipulation
super + {comma,period}
    bspc node @focused -R {90,-90}

super + {slash,backslash}
    bspc node @focused -F {horizontal,vertical}

super + shift + c
    bspc node -C forward

super + shift + e
    bspc node -E

super + b
    bspc node @focused -B

# Closing windows
super + shift + w
    bspc node -c

super + shift + q
    bspc node -k

# Monitor operations
super + shift + m
    bspc node -m next --follow

super + shift + {Left,Right}
    bspc monitor -f {west,east}

# Layout control
super + m
    bspc desktop -l next

# Scratchpad/hidden window
super + shift + space
    bash ~/.config/bspwm/toggle_scratchpad.sh
</code></pre>
<h3 id="b-advanced-sxhkd-patterns"><a class="header" href="#b-advanced-sxhkd-patterns">B. Advanced Sxhkd Patterns</a></h3>
<p><strong>Resize Mode:</strong></p>
<pre><code class="language-bash"># Enter resize mode with Super+E, then use hjkl
super + e : {h,j,k,l}
    bspc node -z {left -20 0,bottom 0 20,top 0 -20,right 20 0}

super + e : shift + {h,j,k,l}
    bspc node -z {right -20 0,top 0 20,bottom 0 -20,left 20 0}

# Exit with Escape key (default)
</code></pre>
<p><strong>Multi-key Sequences:</strong></p>
<pre><code class="language-bash"># Super+P enters preselect mode
super + p : {h,j,k,l}
    bspc node -p {west,south,north,east}

super + p : shift + {h,j,k,l}
    bspc node -p {east,north,south,west}

super + p : c
    bspc node -p cancel

super + p : space
    bspc node -p cancel
</code></pre>
<p><strong>Workspace Management:</strong></p>
<pre><code class="language-bash"># Super+W enters workspace mode
super + w : {1-9,0}
    bspc desktop -f '^{1-9,10}'

super + w : shift + {1-9,0}
    bspc node -d '^{1-9,10}' --follow

super + w : {Left,Right}
    bspc desktop -f {prev,next}.local
</code></pre>
<h2 id="xvii-real-world-usage-scenarios"><a class="header" href="#xvii-real-world-usage-scenarios">XVII. Real-World Usage Scenarios</a></h2>
<h3 id="a-setting-up-a-developer-workflow"><a class="header" href="#a-setting-up-a-developer-workflow">A. Setting Up a Developer Workflow</a></h3>
<pre><code class="language-bash">#!/bin/bash
# ~/.config/bspwm/setup_dev.sh

# Create desktop setup
bspc desktop ^1 -n code
bspc desktop ^2 -n terminal
bspc desktop ^3 -n browser
bspc desktop ^4 -n reference

# Rule for always-open applications
bspc rule -a Zathura desktop=^4 state=floating

# Code desktop layout (2 columns)
bspc desktop code -l tiled
bspc config -d code window_gap 15

# Terminal desktop (single window)
bspc desktop terminal -l monocle
bspc config -d terminal borderless_monocle true

# Browser floating on specific desktop
bspc rule -a Firefox desktop=^3 --follow

# Always open terminal on terminal desktop
bspc rule -a kitty desktop=^2
</code></pre>
<h3 id="b-multi-monitor-setup"><a class="header" href="#b-multi-monitor-setup">B. Multi-Monitor Setup</a></h3>
<pre><code class="language-bash">#!/bin/bash
# ~/.config/bspwm/bspwmrc

# Get monitor names
PRIMARY=$(xrandr -q | grep " connected" | head -1 | awk '{print $1}')
SECONDARY=$(xrandr -q | grep " connected" | tail -1 | awk '{print $1}')

# Configure primary monitor
bspc monitor "$PRIMARY" -d I II III IV V

# Configure secondary monitor
if [[ -n "$SECONDARY" ]]; then
    bspc monitor "$SECONDARY" -d VI VII VIII IX X
fi

# Set padding per monitor
bspc config -m "$PRIMARY" top_padding 30
bspc config -m "$SECONDARY" top_padding 30

# Move specific apps to secondary
bspc rule -a "VLC" -m "$SECONDARY"
</code></pre>
<h3 id="c-gaming-setup"><a class="header" href="#c-gaming-setup">C. Gaming Setup</a></h3>
<pre><code class="language-bash">#!/bin/bash
# Create gaming desktop

# Separate desktop for games
bspc desktop ^9 -n gaming

# Games go fullscreen on dedicated desktop
bspc rule -a "Steam" desktop=^9 state=floating follow=on
bspc rule -a "wine" desktop=^9 state=fullscreen
bspc rule -a ".*Game.*" state=fullscreen

# Disable window gaps for games
bspc config -d gaming window_gap 0

# Disable borders for games
bspc config -d gaming border_width 0

# Sxhkd binding to switch to gaming desktop
super + alt + g
    bspc desktop -f ^9
</code></pre>
<h3 id="d-productivity-mode"><a class="header" href="#d-productivity-mode">D. Productivity Mode</a></h3>
<pre><code class="language-bash">#!/bin/bash
# Simplified, distraction-free setup

# Single application per desktop
bspc config focus_follows_pointer false
bspc config split_ratio 0.5

# Balanced window gaps
bspc config window_gap 8
bspc config border_width 1

# Monocle for focus
bspc rule -a "Writer" desktop=^1 state=monocle
bspc rule -a "code-oss" desktop=^2 state=monocle
bspc rule -a "Firefox" desktop=^3 state=monocle

# Sxhkd bind to toggle distraction-free mode
super + alt + f
    bash ~/.config/bspwm/toggle_focus_mode.sh
</code></pre>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<ul>
<li>
<p>BSPWM represents a paradigm shift in window management philosophy, moving from direct graphical manipulation to declarative, keyboard-driven tree manipulation. Its strength lies in the separation of concerns: the window manager handles the tree logic, <code>bspc</code> provides the control interface, and <code>sxhkd</code> handles keyboard bindings. This architecture enables extraordinary flexibility and customization.</p>
</li>
<li>
<p>The binary space partitioning algorithm ensures that screen real estate is always optimally allocated, with no wasted space or overlapping windows in tiled mode. The rich selector syntax allows targeting any window configuration with surgical precision. Advanced features like receptacles, preselection, flags, and event subscriptions enable sophisticated window management workflows that would be difficult or impossible in traditional window managers.</p>
</li>
<li>
<p>Whether you’re a developer seeking efficient workspace management, a power user who wants complete control over your desktop environment, or someone simply tired of mouse-driven window management, BSPWM provides the tools and flexibility to create a window management system tailored exactly to your needs. The learning curve is steep, but the rewards in productivity and customization justify the investment.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="how-to-contribute-to-bspwm-wiki"><a class="header" href="#how-to-contribute-to-bspwm-wiki">How to Contribute to bspwm-wiki</a></h1>
<p>bspwm-wiki exists to make <strong>bspwm understandable</strong>, not just configurable. Contributions that improve clarity, correctness, and learning are always welcome.
You <strong>don’t need to be an expert</strong> to contribute - even small improvements help.</p>
<h2 id="what-you-can-contribute"><a class="header" href="#what-you-can-contribute">What You Can Contribute</a></h2>
<p>You can help bspwm-wiki in many ways:</p>
<ul>
<li>Fix typeos or unclear explanations</li>
<li>Improve wording for beginners</li>
<li>Add examples that explain <em>why</em>, not just <em>how</em></li>
<li>Expand existing sections with missing details</li>
<li>Suggest new sections or topics</li>
<li>Share debugging tips or common pitfalls
If something confused you while learning bspwm, that’s probably worth documenting.</li>
</ul>
<h3 id="what-bspwm-wiki-values"><a class="header" href="#what-bspwm-wiki-values">What bspwm-wiki Values</a></h3>
<p>Before contributing, keep these principles in mind:</p>
<ol>
<li>Explain concepts, not just commands</li>
<li>Prefer reasoning over copy-paste solutions</li>
<li>Assume the reader is curious, not careless</li>
<li>Keep a neutral, respectful tone</li>
<li>Make sure that your content has clarity</li>
</ol>
<blockquote class="blockquote-tag blockquote-tag-warning">
<p class="blockquote-tag-title"><svg viewbox="0 0 16 16" width="18" height="18"><path d="M6.457 1.047c.659-1.234 2.427-1.234 3.086 0l6.082 11.378A1.75 1.75 0 0 1 14.082 15H1.918a1.75 1.75 0 0 1-1.543-2.575Zm1.763.707a.25.25 0 0 0-.44 0L1.698 13.132a.25.25 0 0 0 .22.368h12.164a.25.25 0 0 0 .22-.368Zm.53 3.996v2.5a.75.75 0 0 1-1.5 0v-2.5a.75.75 0 0 1 1.5 0ZM9 11a1 1 0 1 1-2 0 1 1 0 0 1 2 0Z"></path></svg>Warning</p>
<p>bspwm-wiki aims to <strong>reduce blind config copying</strong>, not encourage it. But this documentation shall include some configuration files and references purely for learning purposes.</p>
</blockquote>
<h3 id="how-to-contribute"><a class="header" href="#how-to-contribute">How to contribute</a></h3>
<ol>
<li>Fork the repository from github : <a href="https://github.com/rdbhvr-001/bspwm-wiki.git">rdbhvr-001/bspwm-wiki</a></li>
<li>Create a new branch for your change in that forked repository</li>
<li>Install <code>rust mdbook</code> for documentation by the following commands</li>
</ol>
<pre><code class="language-bash"># Make sure that you have cargo and rust installed. A simple surf in web can help you install them.
# Install mdbook via cargo

cargo install mdbook

# Make sure to add cargo to your PATH

</code></pre>
<ol start="4">
<li>Learn how to use <a href="https://rust-lang.github.io/mdBook/">mdbook</a>.</li>
<li>In the forked repository, you will find <code>SUMMARY.md</code> file and other md files inside src directory, which is basically the index and source for bspwm-wiki, follow the instructions given in step 4.</li>
<li>After editting the markdown files or adding new ones, you can use the following command to generate the book from the project root dir.</li>
</ol>
<pre><code class="language-bash"># To test it in your friendly local browser test with
mdbook serve

# To build the book, in the terminal typeos
mdbook build

# The book is compiled to html and is in `./book` directory.
</code></pre>
<ol start="7">
<li>Rename the <code>./book</code> to <code>./docs</code></li>
<li>Open up a pull request after testing the book locally in browser</li>
</ol>
<blockquote class="blockquote-tag blockquote-tag-tip">
<p class="blockquote-tag-title"><svg viewbox="0 0 16 16" width="18" height="18"><path d="M8 1.5c-2.363 0-4 1.69-4 3.75 0 .984.424 1.625.984 2.304l.214.253c.223.264.47.556.673.848.284.411.537.896.621 1.49a.75.75 0 0 1-1.484.211c-.04-.282-.163-.547-.37-.847a8.456 8.456 0 0 0-.542-.68c-.084-.1-.173-.205-.268-.32C3.201 7.75 2.5 6.766 2.5 5.25 2.5 2.31 4.863 0 8 0s5.5 2.31 5.5 5.25c0 1.516-.701 2.5-1.328 3.259-.095.115-.184.22-.268.319-.207.245-.383.453-.541.681-.208.3-.33.565-.37.847a.751.751 0 0 1-1.485-.212c.084-.593.337-1.078.621-1.489.203-.292.45-.584.673-.848.075-.088.147-.173.213-.253.561-.679.985-1.32.985-2.304 0-2.06-1.637-3.75-4-3.75ZM5.75 12h4.5a.75.75 0 0 1 0 1.5h-4.5a.75.75 0 0 1 0-1.5ZM6 15.25a.75.75 0 0 1 .75-.75h2.5a.75.75 0 0 1 0 1.5h-2.5a.75.75 0 0 1-.75-.75Z"></path></svg>Tip</p>
<p><strong>An Easier Way to Contribute :</strong> You can click that edit source button on the navbar near print button to directly edit the source, make a pull request and make changes.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="changelog"><a class="header" href="#changelog">Changelog</a></h1>
<p>All notable changes to <strong>bspwm-wiki</strong> will be documented in this file.</p>
<p>This project follows a documentation-first workflow; updates may include new topics, clarifications, restructuring, or references.</p>
<hr>
<h2 id="unreleased"><a class="header" href="#unreleased">[Unreleased]</a></h2>
<h3 id="added"><a class="header" href="#added">Added</a></h3>
<ul>
<li>Community-maintained bspwm documentation structure</li>
<li>Concept-focused explanations beyond configuration examples</li>
<li>References to real-world bspwm configurations</li>
<li>Contribution guidelines and roadmap</li>
<li>Code of Conduct</li>
<li>Security policy</li>
<li>Governance document aligned with the bspwm community</li>
</ul>
<h3 id="changed"><a class="header" href="#changed">Changed</a></h3>
<ul>
<li>Improved navigation and topic organization</li>
<li>Added admonishment support for documentation</li>
<li>Renamed from Doc741 to bspwm-wiki</li>
</ul>
<h3 id="fixed"><a class="header" href="#fixed">Fixed</a></h3>
<ul>
<li>Broken links and minor documentation errors</li>
<li>External css files will be loaded from ./assets/css/ directory</li>
<li>Optimised readme.md</li>
</ul>
<h2 id="011--sub-initial-release"><a class="header" href="#011--sub-initial-release">[0.1.1] – Sub Initial Release</a></h2>
<h3 id="added-1"><a class="header" href="#added-1">Added</a></h3>
<ul>
<li>Initial bspwm-wiki documentation site</li>
<li>Core bspwm concepts and usage explanations</li>
<li>Live deployment using mdBook</li>
</ul>
<h2 id="012---initial-release"><a class="header" href="#012---initial-release">[0.1.2] - Initial Release</a></h2>
<h3 id="added-2"><a class="header" href="#added-2">Added</a></h3>
<ul>
<li>Martian dotfiles for references</li>
<li>Gitignore support for author only directories</li>
</ul>
<h3 id="changed-1"><a class="header" href="#changed-1">Changed</a></h3>
<ul>
<li>Optimised naming for navigation and SEO searches</li>
<li>Aligned bullets in <code>How to master bspwm</code></li>
</ul>
<h3 id="fixed-1"><a class="header" href="#fixed-1">Fixed</a></h3>
<ul>
<li>Added native admonishments</li>
<li>Enhanced code snippets</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <template id=fa-eye><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M288 32c-80.8 0-145.5 36.8-192.6 80.6C48.6 156 17.3 208 2.5 243.7c-3.3 7.9-3.3 16.7 0 24.6C17.3 304 48.6 356 95.4 399.4C142.5 443.2 207.2 480 288 480s145.5-36.8 192.6-80.6c46.8-43.5 78.1-95.4 93-131.1c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C433.5 68.8 368.8 32 288 32zM432 256c0 79.5-64.5 144-144 144s-144-64.5-144-144s64.5-144 144-144s144 64.5 144 144zM288 192c0 35.3-28.7 64-64 64c-11.5 0-22.3-3-31.6-8.4c-.2 2.8-.4 5.5-.4 8.4c0 53 43 96 96 96s96-43 96-96s-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6z"/></svg></span></template>
        <template id=fa-eye-slash><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M38.8 5.1C28.4-3.1 13.3-1.2 5.1 9.2S-1.2 34.7 9.2 42.9l592 464c10.4 8.2 25.5 6.3 33.7-4.1s6.3-25.5-4.1-33.7L525.6 386.7c39.6-40.6 66.4-86.1 79.9-118.4c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C465.5 68.8 400.8 32 320 32c-68.2 0-125 26.3-169.3 60.8L38.8 5.1zM223.1 149.5C248.6 126.2 282.7 112 320 112c79.5 0 144 64.5 144 144c0 24.9-6.3 48.3-17.4 68.7L408 294.5c5.2-11.8 8-24.8 8-38.5c0-53-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6c0 10.2-2.4 19.8-6.6 28.3l-90.3-70.8zm223.1 298L373 389.9c-16.4 6.5-34.3 10.1-53 10.1c-79.5 0-144-64.5-144-144c0-6.9 .5-13.6 1.4-20.2L83.1 161.5C60.3 191.2 44 220.8 34.5 243.7c-3.3 7.9-3.3 16.7 0 24.6c14.9 35.7 46.2 87.7 93 131.1C174.5 443.2 239.2 480 320 480c47.8 0 89.9-12.9 126.2-32.5z"/></svg></span></template>
        <template id=fa-copy><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M502.6 70.63l-61.25-61.25C435.4 3.371 427.2 0 418.7 0H255.1c-35.35 0-64 28.66-64 64l.0195 256C192 355.4 220.7 384 256 384h192c35.2 0 64-28.8 64-64V93.25C512 84.77 508.6 76.63 502.6 70.63zM464 320c0 8.836-7.164 16-16 16H255.1c-8.838 0-16-7.164-16-16L239.1 64.13c0-8.836 7.164-16 16-16h128L384 96c0 17.67 14.33 32 32 32h47.1V320zM272 448c0 8.836-7.164 16-16 16H63.1c-8.838 0-16-7.164-16-16L47.98 192.1c0-8.836 7.164-16 16-16H160V128H63.99c-35.35 0-64 28.65-64 64l.0098 256C.002 483.3 28.66 512 64 512h192c35.2 0 64-28.8 64-64v-32h-47.1L272 448z"/></svg></span></template>
        <template id=fa-play><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M73 39c-14.8-9.1-33.4-9.4-48.5-.9S0 62.6 0 80V432c0 17.4 9.4 33.4 24.5 41.9s33.7 8.1 48.5-.9L361 297c14.3-8.7 23-24.2 23-41s-8.7-32.2-23-41L73 39z"/></svg></span></template>
        <template id=fa-clock-rotate-left><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M75 75L41 41C25.9 25.9 0 36.6 0 57.9V168c0 13.3 10.7 24 24 24H134.1c21.4 0 32.1-25.9 17-41l-30.8-30.8C155 85.5 203 64 256 64c106 0 192 86 192 192s-86 192-192 192c-40.8 0-78.6-12.7-109.7-34.4c-14.5-10.1-34.4-6.6-44.6 7.9s-6.6 34.4 7.9 44.6C151.2 495 201.7 512 256 512c141.4 0 256-114.6 256-256S397.4 0 256 0C185.3 0 121.3 28.7 75 75zm181 53c-13.3 0-24 10.7-24 24V256c0 6.4 2.5 12.5 7 17l72 72c9.4 9.4 24.6 9.4 33.9 0s9.4-24.6 0-33.9l-65-65V152c0-13.3-10.7-24-24-24z"/></svg></span></template>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>


        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr-ef4e11c1.min.js"></script>
        <script src="mark-09e88c2c.min.js"></script>
        <script src="searcher-c2a407aa.js"></script>

        <script src="clipboard-1626706a.min.js"></script>
        <script src="highlight-abc7f01d.js"></script>
        <script src="book-a0b12cfe.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
