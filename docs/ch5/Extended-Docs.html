<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Extended Docs - The Doc741</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon-de23e50b.svg">
        <link rel="shortcut icon" href="../favicon-8114d1fc.png">
        <link rel="stylesheet" href="../css/variables-8adf115d.css">
        <link rel="stylesheet" href="../css/general-2459343d.css">
        <link rel="stylesheet" href="../css/chrome-ae938929.css">
        <link rel="stylesheet" href="../css/print-9e4910d8.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../fonts/fonts-9644e21d.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="mdbook-highlight-css" href="../highlight-493f70e1.css">
        <link rel="stylesheet" id="mdbook-tomorrow-night-css" href="../tomorrow-night-4c0ae647.css">
        <link rel="stylesheet" id="mdbook-ayu-highlight-css" href="../ayu-highlight-3fdfc3ac.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "../searchindex-4018648d.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc-0fa95834.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="mdbook-body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="mdbook-sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("mdbook-sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="mdbook-sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="mdbook-sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="mdbook-page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="mdbook-menu-bar-hover-placeholder"></div>
                <div id="mdbook-menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="mdbook-sidebar-toggle" class="icon-button" for="mdbook-sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="mdbook-sidebar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M0 96C0 78.3 14.3 64 32 64H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H416c17.7 0 32 14.3 32 32z"/></svg></span>
                        </label>
                        <button id="mdbook-theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="mdbook-theme-list">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M371.3 367.1c27.3-3.9 51.9-19.4 67.2-42.9L600.2 74.1c12.6-19.5 9.4-45.3-7.6-61.2S549.7-4.4 531.1 9.6L294.4 187.2c-24 18-38.2 46.1-38.4 76.1L371.3 367.1zm-19.6 25.4l-116-104.4C175.9 290.3 128 339.6 128 400c0 3.9 .2 7.8 .6 11.6c1.8 17.5-10.2 36.4-27.8 36.4H96c-17.7 0-32 14.3-32 32s14.3 32 32 32H240c61.9 0 112-50.1 112-112c0-2.5-.1-5-.2-7.5z"/></svg></span>
                        </button>
                        <ul id="mdbook-theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-ayu">Ayu</button></li>
                        </ul>
                        <button id="mdbook-search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="mdbook-searchbar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9 0 208S93.1 0 208 0S416 93.1 416 208zM208 352c79.5 0 144-64.5 144-144s-64.5-144-144-144S64 128.5 64 208s64.5 144 144 144z"/></svg></span>
                        </button>
                    </div>

                    <h1 class="menu-title">The Doc741</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <span class=fa-svg id="print-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M128 0C92.7 0 64 28.7 64 64v96h64V64H354.7L384 93.3V160h64V93.3c0-17-6.7-33.3-18.7-45.3L400 18.7C388 6.7 371.7 0 354.7 0H128zM384 352v32 64H128V384 368 352H384zm64 32h32c17.7 0 32-14.3 32-32V256c0-35.3-28.7-64-64-64H64c-35.3 0-64 28.7-64 64v96c0 17.7 14.3 32 32 32H64v64c0 35.3 28.7 64 64 64H384c35.3 0 64-28.7 64-64V384zm-16-88c-13.3 0-24-10.7-24-24s10.7-24 24-24s24 10.7 24 24s-10.7 24-24 24z"/></svg></span>
                        </a>

                    </div>
                </div>

                <div id="mdbook-search-wrapper" class="hidden">
                    <form id="mdbook-searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="mdbook-searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="mdbook-searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <span class=fa-svg id="fa-spin"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M304 48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zm0 416c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM48 304c26.5 0 48-21.5 48-48s-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48zm464-48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM142.9 437c18.7-18.7 18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zm0-294.2c18.7-18.7 18.7-49.1 0-67.9S93.7 56.2 75 75s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zM369.1 437c18.7 18.7 49.1 18.7 67.9 0s18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9z"/></svg></span>
                            </div>
                        </div>
                    </form>
                    <div id="mdbook-searchresults-outer" class="searchresults-outer hidden">
                        <div id="mdbook-searchresults-header" class="searchresults-header"></div>
                        <ul id="mdbook-searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('mdbook-sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('mdbook-sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#mdbook-sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="mdbook-content" class="content">
                    <main>
                        <h1 id="bspwm1---------------------------------bspwm-manual---------------------------------bspwm1"><a class="header" href="#bspwm1---------------------------------bspwm-manual---------------------------------bspwm1">BSPWM(1)                                 Bspwm Manual                                 BSPWM(1)</a></h1>
<p>NAME
bspwm - Binary space partitioning window manager</p>
<p>SYNOPSIS
bspwm [-h|-v|-c CONFIG_PATH]</p>
<pre><code>   bspc --print-socket-path

   bspc DOMAIN [SELECTOR] COMMANDS

   bspc COMMAND [OPTIONS] [ARGUMENTS]
DESCRIPTION
</code></pre>
<p>bspwm is a tiling window manager that represents windows as the leaves of a full binary
tree.</p>
<pre><code>   It is controlled and configured via bspc.
OPTIONS
</code></pre>
<p>-h
Print the synopsis and exit.</p>
<pre><code>   -v
       Print the version and exit.

   -c CONFIG_PATH
       Use the given configuration file.

   --print-socket-path
       Print the bspwm socket path and exit.
COMMON DEFINITIONS
</code></pre>
<p>DIR         := north | west | south | east
CYCLE_DIR   := next | prev</p>
<p>SELECTORS
Selectors are used to select a target node, desktop, or monitor. A selector can either
describe the target relatively or name it globally.</p>
<pre><code>   Selectors consist of an optional reference, a descriptor and any number of
   non-conflicting modifiers as follows:

       [REFERENCE#]DESCRIPTOR(.MODIFIER)*

   The relative targets are computed in relation to the given reference (the default
   reference value is focused).

   An exclamation mark can be prepended to any modifier in order to reverse its meaning.

   The following characters cannot be used in monitor or desktop names: #, :, ..

   The special selector %&lt;name&gt; can be used to select a monitor or a desktop with an
   invalid name.
Node
</code></pre>
<p>Select a node.</p>
<pre><code>       NODE_SEL := [NODE_SEL#](DIR|CYCLE_DIR|PATH|any|first_ancestor|last|newest|
                               older|newer|focused|pointed|biggest|smallest|
                               &lt;node_id&gt;)[.[!]focused][.[!]active][.[!]automatic][.[!]local]
                                         [.[!]leaf][.[!]window][.[!]STATE][.[!]FLAG][.[!]LAYER][.[!]SPLIT_TYPE]
                                         [.[!]same_class][.[!]descendant_of][.[!]ancestor_of]

       STATE := tiled|pseudo_tiled|floating|fullscreen

       FLAG := hidden|sticky|private|locked|marked|urgent

       LAYER := below|normal|above

       SPLIT_TYPE := horizontal|vertical

       PATH := @[DESKTOP_SEL:][[/]JUMP](/JUMP)*

       JUMP := first|1|second|2|brother|parent|DIR

   Descriptors

       DIR
           Selects the window in the given (spacial) direction relative to the reference
           node.

       CYCLE_DIR
           Selects the node in the given (cyclic) direction relative to the reference node
           within a depth-first in-order traversal of the tree.

       PATH
           Selects the node at the given path.

       any
           Selects the first node that matches the given selectors.

       first_ancestor
           Selects the first ancestor of the reference node that matches the given
           selectors.

       last
           Selects the previously focused node relative to the reference node.

       newest
           Selects the newest node in the history of the focused node.

       older
           Selects the node older than the reference node in the history.

       newer
           Selects the node newer than the reference node in the history.

       focused
           Selects the currently focused node.

       pointed
           Selects the leaf under the pointer.

       biggest
           Selects the biggest leaf.

       smallest
           Selects the smallest leaf.

       &lt;node_id&gt;
           Selects the node with the given ID.

   Path Jumps

       The initial node is the focused node (or the root if the path starts with /) of the
       reference desktop (or the selected desktop if the path has a DESKTOP_SEL prefix).

       1|first
           Jumps to the first child.

       2|second
           Jumps to the second child.

       brother
           Jumps to the brother node.

       parent
           Jumps to the parent node.

       DIR
           Jumps to the node holding the edge in the given direction.

   Modifiers

       [!]focused
           Only consider the focused node.

       [!]active
           Only consider nodes that are the focused node of their desktop.

       [!]automatic
           Only consider nodes in automatic insertion mode. See also --presel-dir under
           Node in the DOMAINS section below.

       [!]local
           Only consider nodes in the reference desktop.

       [!]leaf
           Only consider leaf nodes.

       [!]window
           Only consider nodes that hold a window.

       [!](tiled|pseudo_tiled|floating|fullscreen)
           Only consider windows in the given state.

       [!]same_class
           Only consider windows that have the same class as the reference window.

       [!]descendant_of
           Only consider nodes that are descendants of the reference node.

       [!]ancestor_of
           Only consider nodes that are ancestors of the reference node.

       [!](hidden|sticky|private|locked|marked|urgent)
           Only consider windows that have the given flag set.

       [!](below|normal|above)
           Only consider windows in the given layer.

       [!](horizontal|vertical)
           Only consider nodes with the given split type.
Desktop
</code></pre>
<p>Select a desktop.</p>
<pre><code>       DESKTOP_SEL := [DESKTOP_SEL#](CYCLE_DIR|any|last|newest|older|newer|
                                     [MONITOR_SEL:](focused|^&lt;n&gt;)|
                                     &lt;desktop_id&gt;|&lt;desktop_name&gt;)[.[!]focused][.[!]active]
                                                                 [.[!]occupied][.[!]urgent][.[!]local]
                                                                 [.[!]LAYOUT][.[!]user_LAYOUT]

       LAYOUT := tiled|monocle

   Descriptors

       CYCLE_DIR
           Selects the desktop in the given direction relative to the reference desktop.

       any
           Selects the first desktop that matches the given selectors.

       last
           Selects the previously focused desktop relative to the reference desktop.

       newest
           Selects the newest desktop in the history of the focused desktops.

       older
           Selects the desktop older than the reference desktop in the history.

       newer
           Selects the desktop newer than the reference desktop in the history.

       focused
           Selects the currently focused desktop.

       ^&lt;n&gt;
           Selects the nth desktop. If MONITOR_SEL is given, selects the nth desktop on
           the selected monitor.

       &lt;desktop_id&gt;
           Selects the desktop with the given ID.

       &lt;desktop_name&gt;
           Selects the desktop with the given name.

   Modifiers

       [!]focused
           Only consider the focused desktop.

       [!]active
           Only consider desktops that are the focused desktop of their monitor.

       [!]occupied
           Only consider occupied desktops.

       [!]urgent
           Only consider urgent desktops.

       [!]local
           Only consider desktops inside the reference monitor.

       [!](tiled|monocle)
           Only consider desktops with the given layout.

       [!](user_tiled|user_monocle)
           Only consider desktops which have the given layout as userLayout.
Monitor
</code></pre>
<p>Select a monitor.</p>
<pre><code>       MONITOR_SEL := [MONITOR_SEL#](DIR|CYCLE_DIR|any|last|newest|older|newer|
                                     focused|pointed|primary|^&lt;n&gt;|
                                     &lt;monitor_id&gt;|&lt;monitor_name&gt;)[.[!]focused][.[!]occupied]

   Descriptors

       DIR
           Selects the monitor in the given (spacial) direction relative to the reference
           monitor.

       CYCLE_DIR
           Selects the monitor in the given (cyclic) direction relative to the reference
           monitor.

       any
           Selects the first monitor that matches the given selectors.

       last
           Selects the previously focused monitor relative to the reference monitor.

       newest
           Selects the newest monitor in the history of the focused monitors.

       older
           Selects the monitor older than the reference monitor in the history.

       newer
           Selects the monitor newer than the reference monitor in the history.

       focused
           Selects the currently focused monitor.

       pointed
           Selects the monitor under the pointer.

       primary
           Selects the primary monitor.

       ^&lt;n&gt;
           Selects the nth monitor.

       &lt;monitor_id&gt;
           Selects the monitor with the given ID.

       &lt;monitor_name&gt;
           Selects the monitor with the given name.

   Modifiers

       [!]focused
           Only consider the focused monitor.

       [!]occupied
           Only consider monitors where the focused desktop is occupied.
WINDOW STATES
</code></pre>
<p>tiled
Its size and position are determined by the window tree.</p>
<pre><code>   pseudo_tiled
       A tiled window that automatically shrinks but doesn’t stretch beyond its floating
       size.

   floating
       Can be moved/resized freely. Although it doesn’t use any tiling space, it is still
       part of the window tree.

   fullscreen
       Fills its monitor rectangle and has no borders.
NODE FLAGS
</code></pre>
<p>hidden
Is hidden and doesn’t occupy any tiling space.</p>
<pre><code>   sticky
       Stays in the focused desktop of its monitor.

   private
       Tries to keep the same tiling position/size.

   locked
       Ignores the node --close message.

   marked
       Is marked (useful for deferred actions). A marked node becomes unmarked after being
       sent on a preselected node.

   urgent
       Has its urgency hint set. This flag is set externally.
STACKING LAYERS
</code></pre>
<p>There’s three stacking layers: BELOW, NORMAL and ABOVE.</p>
<pre><code>   In each layer, the windows are orderered as follows: tiled &amp; pseudo-tiled &lt; floating &lt;
   fullscreen.
RECEPTACLES
</code></pre>
<p>A leaf node that doesn’t hold any window is called a receptacle. When a node is
inserted on a receptacle in automatic mode, it will replace the receptacle. A
receptacle can be inserted on a node, preselected and killed. Receptacles can therefore
be used to build a tree whose leaves are receptacles. Using the appropriate rules, one
can then send windows on the leaves of this tree. This feature is used in
examples/receptacles to store and recreate layouts.</p>
<p>DOMAINS
Node
General Syntax</p>
<pre><code>       node [NODE_SEL] COMMANDS

       If NODE_SEL is omitted, focused is assumed.

   Commands

       -f, --focus [NODE_SEL]
           Focus the selected or given node.

       -a, --activate [NODE_SEL]
           Activate the selected or given node.

       -d, --to-desktop DESKTOP_SEL [--follow]
           Send the selected node to the given desktop. If --follow is passed, the focused
           node will stay focused.

       -m, --to-monitor MONITOR_SEL [--follow]
           Send the selected node to the given monitor. If --follow is passed, the focused
           node will stay focused.

       -n, --to-node NODE_SEL [--follow]
           Send the selected node on the given node. If --follow is passed, the focused
           node will stay focused.

       -s, --swap NODE_SEL [--follow]
           Swap the selected node with the given node. If --follow is passed, the focused
           node will stay focused.

       -p, --presel-dir [~]DIR|cancel
           Preselect the splitting area of the selected node (or cancel the preselection).
           If ~ is prepended to DIR and the current preselection direction matches DIR,
           then the argument is interpreted as cancel. A node with a preselected area is
           said to be in "manual insertion mode".

       -o, --presel-ratio RATIO
           Set the splitting ratio of the preselection area.

       -v, --move dx dy
           Move the selected window by dx pixels horizontally and dy pixels vertically.

       -z, --resize top|left|bottom|right|top_left|top_right|bottom_right|bottom_left dx
       dy
           Resize the selected window by moving the given handle by dx pixels horizontally
           and dy pixels vertically.

       -y, --type CYCLE_DIR|horizontal|vertical
           Set or cycle the splitting type of the selected node.

       -r, --ratio RATIO|(+|-)(PIXELS|FRACTION)
           Set the splitting ratio of the selected node (0 &lt; RATIO &lt; 1).

       -R, --rotate 90|270|180
           Rotate the tree rooted at the selected node.

       -F, --flip horizontal|vertical
           Flip the tree rooted at selected node.

       -E, --equalize
           Reset the split ratios of the tree rooted at the selected node to their default
           value.

       -B, --balance
           Adjust the split ratios of the tree rooted at the selected node so that all
           windows occupy the same area.

       -C, --circulate forward|backward
           Circulate the windows of the tree rooted at the selected node.

       -t, --state ~|[~]STATE
           Set the state of the selected window. If ~ is present and the current state
           matches STATE, then the argument is interpreted as its last state. If the
           argument is just ~ with STATE omitted, then the state of the selected window is
           set to its last state.

       -g, --flag hidden|sticky|private|locked|marked[=on|off]
           Set or toggle the given flag for the selected node.

       -l, --layer below|normal|above
           Set the stacking layer of the selected window.

       -i, --insert-receptacle
           Insert a receptacle node at the selected node.

       -c, --close
           Close the windows rooted at the selected node.

       -k, --kill
           Kill the windows rooted at the selected node.
Desktop
</code></pre>
<p>General Syntax</p>
<pre><code>       desktop [DESKTOP_SEL] COMMANDS

       If DESKTOP_SEL is omitted, focused is assumed.

   COMMANDS

       -f, --focus [DESKTOP_SEL]
           Focus the selected or given desktop.

       -a, --activate [DESKTOP_SEL]
           Activate the selected or given desktop.

       -m, --to-monitor MONITOR_SEL [--follow]
           Send the selected desktop to the given monitor. If --follow is passed, the
           focused desktop will stay focused.

       -s, --swap DESKTOP_SEL [--follow]
           Swap the selected desktop with the given desktop. If --follow is passed, the
           focused desktop will stay focused.

       -l, --layout CYCLE_DIR|monocle|tiled
           Set or cycle the layout of the selected desktop.

       -n, --rename &lt;new_name&gt;
           Rename the selected desktop.

       -b, --bubble CYCLE_DIR
           Bubble the selected desktop in the given direction.

       -r, --remove
           Remove the selected desktop.
Monitor
</code></pre>
<p>General Syntax</p>
<pre><code>       monitor [MONITOR_SEL] COMMANDS

       If MONITOR_SEL is omitted, focused is assumed.

   Commands

       -f, --focus [MONITOR_SEL]
           Focus the selected or given monitor.

       -s, --swap MONITOR_SEL
           Swap the selected monitor with the given monitor.

       -a, --add-desktops &lt;name&gt;...
           Create desktops with the given names in the selected monitor.

       -o, --reorder-desktops &lt;name&gt;...
           Reorder the desktops of the selected monitor to match the given order.

       -d, --reset-desktops &lt;name&gt;...
           Rename, add or remove desktops depending on whether the number of given names
           is equal, superior or inferior to the number of existing desktops.

       -g, --rectangle WxH+X+Y
           Set the rectangle of the selected monitor.

       -n, --rename &lt;new_name&gt;
           Rename the selected monitor.

       -r, --remove
           Remove the selected monitor.
Query
</code></pre>
<p>General Syntax</p>
<pre><code>       query COMMANDS [OPTIONS]

   Commands

       The optional selectors are references.

       -N, --nodes [NODE_SEL]
           List the IDs of the matching nodes.

       -D, --desktops [DESKTOP_SEL]
           List the IDs (or names) of the matching desktops.

       -M, --monitors [MONITOR_SEL]
           List the IDs (or names) of the matching monitors.

       -T, --tree
           Print a JSON representation of the matching item.

   Options

       -m,--monitor [MONITOR_SEL|MONITOR_MODIFIERS], -d,--desktop
       [DESKTOP_SEL|DESKTOP_MODIFIERS], -n,--node [NODE_SEL|NODE_MODIFIERS]
           Constrain matches to the selected monitors, desktops or nodes.

       --names
           Print names instead of IDs. Can only be used with -M and -D.
Wm
</code></pre>
<p>General Syntax</p>
<pre><code>       wm COMMANDS

   Commands

       -d, --dump-state
           Dump the current world state on standard output.

       -l, --load-state &lt;file_path&gt;
           Load a world state from the given file. The path must be absolute.

       -a, --add-monitor &lt;name&gt; WxH+X+Y
           Add a monitor for the given name and rectangle.

       -O, --reorder-monitors &lt;name&gt;...
           Reorder the list of monitors to match the given order.

       -o, --adopt-orphans
           Manage all the unmanaged windows remaining from a previous session.

       -h, --record-history on|off
           Enable or disable the recording of node focus history.

       -g, --get-status
           Print the current status information.

       -r, --restart
           Restart the window manager
Rule
</code></pre>
<p>General Syntax</p>
<pre><code>       rule COMMANDS

   Commands

       -a, --add (&lt;class_name&gt;|*)[:(&lt;instance_name&gt;|*)[:(&lt;name&gt;|*)]] [-o|--one-shot]
       [monitor=MONITOR_SEL|desktop=DESKTOP_SEL|node=NODE_SEL] [state=STATE] [layer=LAYER]
       [honor_size_hints=(true|false|tiled|floating)] [split_dir=DIR] [split_ratio=RATIO]
       [(hidden|sticky|private|locked|marked|center|follow|manage|focus|border)=(on|off)]
       [rectangle=WxH+X+Y]
           Create a new rule. Colons in the instance_name, class_name, or name fields can
           be escaped with a backslash.

       -r, --remove ^&lt;n&gt;|head|tail|(&lt;class_name&gt;|*)[:(&lt;instance_name&gt;|*)[:(&lt;name&gt;|*)]]...
           Remove the given rules.

       -l, --list
           List the rules.
Config
</code></pre>
<p>General Syntax</p>
<pre><code>       config [-m MONITOR_SEL|-d DESKTOP_SEL|-n NODE_SEL] &lt;setting&gt; [&lt;value&gt;]
           Get or set the value of &lt;setting&gt;.
Subscribe
</code></pre>
<p>General Syntax</p>
<pre><code>       subscribe [OPTIONS] (all|report|monitor|desktop|node|...)*
           Continuously print events. See the EVENTS section for the description of each
           event.

   Options

       -f, --fifo
           Print a path to a FIFO from which events can be read and return.

       -c, --count COUNT
           Stop the corresponding bspc process after having received COUNT events.
Quit
</code></pre>
<p>General Syntax</p>
<pre><code>       quit [&lt;status&gt;]
           Quit with an optional exit status.
EXIT CODES
</code></pre>
<p>If the server can’t handle a message, bspc will return with a non-zero exit code.</p>
<p>SETTINGS
Colors are in the form #RRGGBB, booleans are true, on, false or off.</p>
<pre><code>   All the boolean settings are false by default unless stated otherwise.
Global Settings
</code></pre>
<p>normal_border_color
Color of the border of an unfocused window.</p>
<pre><code>   active_border_color
       Color of the border of a focused window of an unfocused monitor.

   focused_border_color
       Color of the border of a focused window of a focused monitor.

   presel_feedback_color
       Color of the node --presel-{dir,ratio} message feedback area.

   split_ratio
       Default split ratio.

   status_prefix
       Prefix prepended to each of the status lines.

   external_rules_command
       Absolute path to the command used to retrieve rule consequences. The command will
       receive the following arguments: window ID, class name, instance name, and
       intermediate consequences. The output of that command must have the following
       format: key1=value1 key2=value2 ...  (the valid key/value pairs are given in the
       description of the rule command).

   automatic_scheme
       The insertion scheme used when the insertion point is in automatic mode. Accept the
       following values: longest_side, alternate, spiral.

   initial_polarity
       On which child should a new window be attached when adding a window on a single
       window tree in automatic mode. Accept the following values: first_child,
       second_child.

   directional_focus_tightness
       The tightness of the algorithm used to decide whether a window is on the DIR side
       of another window. Accept the following values: high, low.

   removal_adjustment
       Adjust the brother when unlinking a node from the tree in accordance with the
       automatic insertion scheme.

   presel_feedback
       Draw the preselection feedback area. Defaults to true.

   borderless_monocle
       Remove borders of tiled windows for the monocle desktop layout.

   gapless_monocle
       Remove gaps of tiled windows for the monocle desktop layout.

   top_monocle_padding, right_monocle_padding, bottom_monocle_padding,
   left_monocle_padding
       Padding space added at the sides of the screen for the monocle desktop layout.

   single_monocle
       Set the desktop layout to monocle if there’s only one tiled window in the tree.

   borderless_singleton
       Remove borders of the only window on the only monitor regardless its layout.

   pointer_motion_interval
       The minimum interval, in milliseconds, between two motion notify events.

   pointer_modifier
       Keyboard modifier used for moving or resizing windows. Accept the following values:
       shift, control, lock, mod1, mod2, mod3, mod4, mod5.

   pointer_action1, pointer_action2, pointer_action3
       Action performed when pressing pointer_modifier + button&lt;n&gt;. Accept the following
       values: move, resize_side, resize_corner, focus, none.

   click_to_focus
       Button used for focusing a window (or a monitor). The possible values are: button1,
       button2, button3, any, none. Defaults to button1.

   swallow_first_click
       Don’t replay the click that makes a window focused if click_to_focus isn’t none.

   focus_follows_pointer
       Focus the window under the pointer.

   pointer_follows_focus
       When focusing a window, put the pointer at its center.

   pointer_follows_monitor
       When focusing a monitor, put the pointer at its center.

   mapping_events_count
       Handle the next mapping_events_count mapping notify events. A negative value
       implies that every event needs to be handled.

   ignore_ewmh_focus
       Ignore EWMH focus requests coming from applications.

   ignore_ewmh_fullscreen
       Block the fullscreen state transitions that originate from an EWMH request. The
       possible values are: none, all, or a comma separated list of the following values:
       enter, exit.

   ignore_ewmh_struts
       Ignore strut hinting from clients requesting to reserve space (i.e. task bars).

   center_pseudo_tiled
       Center pseudo tiled windows into their tiling rectangles. Defaults to true.

   remove_disabled_monitors
       Consider disabled monitors as disconnected.

   remove_unplugged_monitors
       Remove unplugged monitors.

   merge_overlapping_monitors
       Merge overlapping monitors (the bigger remains).
Monitor and Desktop Settings
</code></pre>
<p>top_padding, right_padding, bottom_padding, left_padding
Padding space added at the sides of the monitor or desktop.</p>
<p>Desktop Settings
window_gap
Size of the gap that separates windows.</p>
<p>Node Settings
border_width
Window border width.</p>
<pre><code>   honor_size_hints
       If true, apply ICCCM window size hints to all windows. If floating, only apply them
       to floating and pseudo tiled windows. If tiled, only apply them to tiled windows.
       If false, don’t apply them. Defaults to false.
POINTER BINDINGS
</code></pre>
<p>click_to_focus
Focus the window (or the monitor) under the pointer if the value isn’t none.</p>
<pre><code>   pointer_modifier + button1
       Move the window under the pointer.

   pointer_modifier + button2
       Resize the window under the pointer by dragging the nearest side.

   pointer_modifier + button3
       Resize the window under the pointer by dragging the nearest corner.

   The behavior of pointer_modifier + button&lt;n&gt; can be modified through the
   pointer_action&lt;n&gt; setting.
EVENTS
</code></pre>
<p>report
See the next section for the description of the format.</p>
<pre><code>   monitor_add &lt;monitor_id&gt; &lt;monitor_name&gt; &lt;monitor_geometry&gt;
       A monitor is added.

   monitor_rename &lt;monitor_id&gt; &lt;old_name&gt; &lt;new_name&gt;
       A monitor is renamed.

   monitor_remove &lt;monitor_id&gt;
       A monitor is removed.

   monitor_swap &lt;src_monitor_id&gt; &lt;dst_monitor_id&gt;
       A monitor is swapped.

   monitor_focus &lt;monitor_id&gt;
       A monitor is focused.

   monitor_geometry &lt;monitor_id&gt; &lt;monitor_geometry&gt;
       The geometry of a monitor changed.

   desktop_add &lt;monitor_id&gt; &lt;desktop_id&gt; &lt;desktop_name&gt;
       A desktop is added.

   desktop_rename &lt;monitor_id&gt; &lt;desktop_id&gt; &lt;old_name&gt; &lt;new_name&gt;
       A desktop is renamed.

   desktop_remove &lt;monitor_id&gt; &lt;desktop_id&gt;
       A desktop is removed.

   desktop_swap &lt;src_monitor_id&gt; &lt;src_desktop_id&gt; &lt;dst_monitor_id&gt; &lt;dst_desktop_id&gt;
       A desktop is swapped.

   desktop_transfer &lt;src_monitor_id&gt; &lt;src_desktop_id&gt; &lt;dst_monitor_id&gt;
       A desktop is transferred.

   desktop_focus &lt;monitor_id&gt; &lt;desktop_id&gt;
       A desktop is focused.

   desktop_activate &lt;monitor_id&gt; &lt;desktop_id&gt;
       A desktop is activated.

   desktop_layout &lt;monitor_id&gt; &lt;desktop_id&gt; tiled|monocle
       The layout of a desktop changed.

   node_add &lt;monitor_id&gt; &lt;desktop_id&gt; &lt;ip_id&gt; &lt;node_id&gt;
       A node is added.

   node_remove &lt;monitor_id&gt; &lt;desktop_id&gt; &lt;node_id&gt;
       A node is removed.

   node_swap &lt;src_monitor_id&gt; &lt;src_desktop_id&gt; &lt;src_node_id&gt; &lt;dst_monitor_id&gt;
   &lt;dst_desktop_id&gt; &lt;dst_node_id&gt;
       A node is swapped.

   node_transfer &lt;src_monitor_id&gt; &lt;src_desktop_id&gt; &lt;src_node_id&gt; &lt;dst_monitor_id&gt;
   &lt;dst_desktop_id&gt; &lt;dst_node_id&gt;
       A node is transferred.

   node_focus &lt;monitor_id&gt; &lt;desktop_id&gt; &lt;node_id&gt;
       A node is focused.

   node_activate &lt;monitor_id&gt; &lt;desktop_id&gt; &lt;node_id&gt;
       A node is activated.

   node_presel &lt;monitor_id&gt; &lt;desktop_id&gt; &lt;node_id&gt; (dir DIR|ratio RATIO|cancel)
       A node is preselected.

   node_stack &lt;node_id_1&gt; below|above &lt;node_id_2&gt;
       A node is stacked below or above another node.

   node_geometry &lt;monitor_id&gt; &lt;desktop_id&gt; &lt;node_id&gt; &lt;node_geometry&gt;
       The geometry of a window changed.

   node_state &lt;monitor_id&gt; &lt;desktop_id&gt; &lt;node_id&gt; tiled|pseudo_tiled|floating|fullscreen
   on|off
       The state of a window changed.

   node_flag &lt;monitor_id&gt; &lt;desktop_id&gt; &lt;node_id&gt;
   hidden|sticky|private|locked|marked|urgent on|off
       One of the flags of a node changed.

   node_layer &lt;monitor_id&gt; &lt;desktop_id&gt; &lt;node_id&gt; below|normal|above
       The layer of a window changed.

   pointer_action &lt;monitor_id&gt; &lt;desktop_id&gt; &lt;node_id&gt; move|resize_corner|resize_side
   begin|end
       A pointer action occurred.

   Please note that bspwm initializes monitors before it reads messages on its socket,
   therefore the initial monitor events can’t be received.
REPORT FORMAT
</code></pre>
<p>Each report event message is composed of items separated by colons.</p>
<pre><code>   Each item has the form &lt;type&gt;&lt;value&gt; where &lt;type&gt; is the first character of the item.

   M&lt;monitor_name&gt;
       Focused monitor.

   m&lt;monitor_name&gt;
       Unfocused monitor.

   O&lt;desktop_name&gt;
       Occupied focused desktop.

   o&lt;desktop_name&gt;
       Occupied unfocused desktop.

   F&lt;desktop_name&gt;
       Free focused desktop.

   f&lt;desktop_name&gt;
       Free unfocused desktop.

   U&lt;desktop_name&gt;
       Urgent focused desktop.

   u&lt;desktop_name&gt;
       Urgent unfocused desktop.

   L(T|M)
       Layout of the focused desktop of a monitor.

   T(T|P|F|=|@)
       State of the focused node of a focused desktop.

   G(S?P?L?M?)
       Active flags of the focused node of a focused desktop.
ENVIRONMENT VARIABLES
</code></pre>
<p>BSPWM_SOCKET
The path of the socket used for the communication between bspc and bspwm. If it
isn’t defined, then the following path is used:
/tmp/bspwm&lt;host_name&gt;<em>&lt;display_number&gt;</em>&lt;screen_number&gt;-socket.</p>
<p>CONTRIBUTORS
•   Steven Allen : steven at stebalien.com</p>
<pre><code>   •   Thomas Adam &lt;thomas at xteddy.org&gt;

   •   Ivan Kanakarakis &lt;ivan.kanak at gmail.com&gt;
AUTHOR
</code></pre>
<p>Bastien Dejean : nihilhill at gmail.com</p>
<p>Bspwm 0.9.12                              10/08/2025                                  BSPWM(1)</p>
<p>Deeply explain all off these in seperate subheadings how to what to and with example  each of the feature in bspwm in 40000 words</p>
<p>Perfect! Now I have comprehensive information. Let me create a detailed, in-depth guide about bspwm. I’ll now generate the comprehensive answer.</p>
<h1 id="a-comprehensive-in-depth-guide-to-bspwm-the-binary-space-partitioning-window-manager"><a class="header" href="#a-comprehensive-in-depth-guide-to-bspwm-the-binary-space-partitioning-window-manager">A Comprehensive In-Depth Guide to BSPWM: The Binary Space Partitioning Window Manager</a></h1>
<p>This comprehensive guide provides an exhaustive explanation of BSPWM (Binary Space Partitioning Window Manager), covering all major features, domains, commands, and configurations with detailed examples and practical applications. BSPWM is a sophisticated tiling window manager that organizes windows using binary space partitioning algorithms, represented as leaves in a full binary tree structure. Unlike traditional window managers that require mouse interactions for window management, BSPWM operates through a client-server socket architecture where the <code>bspc</code> command client communicates with the <code>bspwm</code> server daemon, allowing keyboard-driven, highly customizable window management.</p>
<h2 id="i-introduction-to-bspwm-architecture-and-core-concepts"><a class="header" href="#i-introduction-to-bspwm-architecture-and-core-concepts">I. Introduction to BSPWM Architecture and Core Concepts</a></h2>
<h3 id="a-what-is-binary-space-partitioning-bsp"><a class="header" href="#a-what-is-binary-space-partitioning-bsp">A. What is Binary Space Partitioning (BSP)?</a></h3>
<p><strong>Binary Space Partitioning</strong> is a mathematical technique originally developed for three-dimensional computer graphics that recursively divides a rectangular space by splitting it along axis-aligned lines. In the context of BSPWM, this algorithm is applied to monitor screen rectangles, creating a hierarchical binary tree structure where each internal node represents a split (either horizontal or vertical) and each leaf node represents a window or empty receptacle.</p>
<p>The fundamental principle behind BSP in BSPWM is elegant: every node in the tree either has exactly zero children (leaf nodes) or exactly two children (internal nodes). Each internal node manages a rectangular area and decides how to split it between its two child nodes using two parameters: the split type (horizontal or vertical) and the split ratio (a value between 0 and 1, where 0.5 means equal distribution). This mathematical approach ensures that every pixel on the screen is always accounted for and that the layout remains perfectly tiled without gaps or overlaps, except for borders and user-configured gaps.</p>
<p><strong>Example of BSP in Action:</strong>
When you start with a single window filling the entire monitor (node 1), and open a second window (node 2), BSPWM creates an internal node (node b) that splits the screen according to the automatic insertion scheme. If the split is vertical with a ratio of 0.5, the first window gets 50% of the width on the left and the second window gets 50% on the right. Opening a third window (node 3) causes the tree to reorganize, with one of the existing nodes being displaced to create space for the new window.</p>
<h3 id="b-architecture-client-server-socket-model"><a class="header" href="#b-architecture-client-server-socket-model">B. Architecture: Client-Server Socket Model</a></h3>
<p>BSPWM operates using a three-component architecture where the window manager itself (the <code>bspwm</code> daemon) is separate from its control program (<code>bspc</code>) and keyboard binding manager (<code>sxhkd</code>). This separation of concerns provides several advantages:</p>
<pre><code>1. **bspwm daemon**: Runs in the background listening on a Unix domain socket (`/tmp/bspwm&lt;hostname&gt;_&lt;display&gt;_&lt;screen&gt;-socket`), managing all window operations and desktop state
</code></pre>
<ol start="2">
<li><strong>bspc client</strong>: Sends commands to the bspwm socket to manage windows, desktops, monitors, and query the window tree</li>
<li><strong>sxhkd daemon</strong>: A separate process that intercepts X11 keyboard and pointer events and translates them into <code>bspc</code> commands</li>
</ol>
<p>This architecture means BSPWM doesn’t handle any keyboard input directly—it only responds to socket messages. This makes BSPWM completely independent of any particular key binding system and allows the same window manager to be used with different hotkey daemons.</p>
<h3 id="c-fundamental-concepts-monitors-desktops-and-nodes"><a class="header" href="#c-fundamental-concepts-monitors-desktops-and-nodes">C. Fundamental Concepts: Monitors, Desktops, and Nodes</a></h3>
<p><strong>Monitors</strong> are physical displays or virtual output devices (detected via RandR or Xinerama protocols) that act as containers holding rectangular regions. Each monitor displays one focused desktop at a time. When you have multiple monitors, each can show a different desktop.</p>
<p><strong>Desktops</strong> (also called workspaces or virtual desktops) are independent tree structures that contain windows. A monitor shows one desktop at a time, but can switch between them. Each desktop has its own layout (tiled or monocle) and contains its own hierarchy of windows.</p>
<p><strong>Nodes</strong> are the abstract tree nodes—either internal nodes (which define splits) or leaf nodes (which hold windows or are empty receptacles). Every window in BSPWM is represented as a leaf node in the binary tree. Empty leaf nodes without windows are called <strong>receptacles</strong> and serve as placeholders for future window insertions.</p>
<p><strong>Example Monitor/Desktop/Node Hierarchy:</strong></p>
<pre><code>Monitor 1 (1920x1080)
├── Desktop 1 (focused) - containing Tree T1
│   ├── Node 1 (window: Firefox)
│   ├── Node 2 (window: Terminal)
│   └── Node 3 (receptacle)
├── Desktop 2 - containing Tree T2
│   └── Node 1 (window: Editor)
└── Desktop 3 - containing Tree T3
    └── (empty)

Monitor 2 (1920x1080)
└── Desktop 4 - containing Tree T4
    └── Node 1 (window: Media Player)
</code></pre>
<h2 id="ii-selectors-the-foundation-of-bspwm-control"><a class="header" href="#ii-selectors-the-foundation-of-bspwm-control">II. Selectors: The Foundation of BSPWM Control</a></h2>
<p>Selectors are the core mechanism through which you target windows, desktops, or monitors for operations. Understanding selectors is absolutely essential because almost every <code>bspc</code> command uses them to specify which object to operate on.</p>
<h3 id="a-selector-syntax-and-structure"><a class="header" href="#a-selector-syntax-and-structure">A. Selector Syntax and Structure</a></h3>
<p>The general syntax for a selector is:</p>
<pre><code>[REFERENCE#]DESCRIPTOR(.MODIFIER)*
</code></pre>
<p>This breaks down as:</p>
<ul>
<li><strong>REFERENCE</strong>: An optional reference node/desktop/monitor (defaults to focused)</li>
<li><strong>DESCRIPTOR</strong>: The primary selection method (direction, cycling, ID, etc.)</li>
<li><strong>MODIFIERS</strong>: Zero or more filtering conditions, each can be negated with <code>!</code></li>
</ul>
<p>For example: <code>node east.!floating.window</code> means “select the node to the east that is not floating and has a window in it”.</p>
<h3 id="b-node-selectors-in-depth"><a class="header" href="#b-node-selectors-in-depth">B. Node Selectors in Depth</a></h3>
<p><strong>Node Selectors</strong> target specific windows/nodes in the tree. The complete syntax is:</p>
<pre><code>NODE_SEL := [NODE_SEL#](DIR|CYCLE_DIR|PATH|any|first_ancestor|last|newest|older|newer|focused|pointed|biggest|smallest|&lt;node_id&gt;)[.[!]focused][.[!]active][.[!]automatic][.[!]local][.[!]leaf][.[!]window][.[!]STATE][.[!]FLAG][.[!]LAYER][.[!]SPLIT_TYPE][.[!]same_class][.[!]descendant_of][.[!]ancestor_of]
</code></pre>
<p><strong>Node Selector Descriptors</strong> (primary selection methods):</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th style="text-align: left">Descriptor</th><th style="text-align: left">Behavior</th><th style="text-align: left">Example</th></tr>
</thead>
<tbody>
<tr><td style="text-align: left"><code>north|south|east|west</code> (DIR)</td><td style="text-align: left">Select window spatially in given direction</td><td style="text-align: left"><code>bspc node west -f</code></td></tr>
<tr><td style="text-align: left"><code>next|prev</code> (CYCLE_DIR)</td><td style="text-align: left">Cycle within tree traversal order</td><td style="text-align: left"><code>bspc node next -f</code></td></tr>
<tr><td style="text-align: left"><code>any</code></td><td style="text-align: left">Select first matching node</td><td style="text-align: left"><code>bspc node any.floating -f</code></td></tr>
<tr><td style="text-align: left"><code>focused</code></td><td style="text-align: left">Currently focused node</td><td style="text-align: left"><code>bspc node focused -t floating</code></td></tr>
<tr><td style="text-align: left"><code>pointed</code></td><td style="text-align: left">Node under mouse pointer</td><td style="text-align: left"><code>bspc node pointed -c</code></td></tr>
<tr><td style="text-align: left"><code>biggest|smallest</code></td><td style="text-align: left">Largest or smallest leaf</td><td style="text-align: left"><code>bspc node biggest -s focused</code></td></tr>
<tr><td style="text-align: left"><code>last</code></td><td style="text-align: left">Previously focused node</td><td style="text-align: left"><code>bspc node last -f</code></td></tr>
<tr><td style="text-align: left"><code>newest|older|newer</code></td><td style="text-align: left">History-based selection</td><td style="text-align: left"><code>bspc node newest -n @^1</code></td></tr>
<tr><td style="text-align: left"><code>&lt;node_id&gt;</code></td><td style="text-align: left">Specific node by ID</td><td style="text-align: left"><code>bspc node 0x00800001 -t floating</code></td></tr>
<tr><td style="text-align: left"><code>@PATH</code></td><td style="text-align: left">Path-based navigation</td><td style="text-align: left"><code>bspc node @/first/brother -f</code></td></tr>
</tbody>
</table>
</div>
<p><strong>Node Selector Modifiers</strong> (filtering conditions):</p>
<pre><code># States
.tiled              - Only tiled windows
.pseudo_tiled       - Only pseudo-tiled windows
.floating           - Only floating windows
.fullscreen         - Only fullscreen windows

# Flags
.hidden             - Hidden (not displayed)
.sticky             - Stays on focused desktop
.private            - Resists movement/resize
.locked             - Can't be closed
.marked             - Custom marking
.urgent             - Has urgency hint

# Layers
.below              - Below normal layer
.normal             - Normal stacking layer
.above              - Above normal layer

# Tree structure
.leaf               - Leaf nodes only
.window             - Nodes with windows only
.same_class         - Windows of same application class
.descendant_of      - All descendants
.ancestor_of        - All ancestors
</code></pre>
<p><strong>Practical Node Selector Examples:</strong></p>
<pre><code class="language-bash"># Focus the window to the east
bspc node east -f

# Focus the largest window that's not fullscreen
bspc node biggest.!fullscreen -f

# Select first tiled window on current desktop
bspc node .local.tiled -f

# Move focused window to the second child position
bspc node -n @/second -f

# Select all windows of Firefox class
bspc node .same_class -t floating
</code></pre>
<h3 id="c-desktop-selectors"><a class="header" href="#c-desktop-selectors">C. Desktop Selectors</a></h3>
<p><strong>Desktop Selectors</strong> target specific workspaces and have the syntax:</p>
<pre><code>DESKTOP_SEL := [DESKTOP_SEL#](CYCLE_DIR|any|last|newest|older|newer|[MONITOR_SEL:](focused|^&lt;n&gt;)|&lt;desktop_id&gt;|&lt;desktop_name&gt;)[.[!]focused][.[!]active][.[!]occupied][.[!]urgent][.[!]local][.[!]LAYOUT][.[!]user_LAYOUT]
</code></pre>
<p><strong>Desktop Selector Descriptors:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th style="text-align: left">Descriptor</th><th style="text-align: left">Behavior</th></tr>
</thead>
<tbody>
<tr><td style="text-align: left"><code>next|prev</code></td><td style="text-align: left">Cycle to next/previous desktop</td></tr>
<tr><td style="text-align: left"><code>focused</code></td><td style="text-align: left">Currently active desktop</td></tr>
<tr><td style="text-align: left"><code>^&lt;n&gt;</code></td><td style="text-align: left">Nth desktop (^1 = first)</td></tr>
<tr><td style="text-align: left"><code>^1|^2|^3...</code></td><td style="text-align: left">Numbered desktops</td></tr>
<tr><td style="text-align: left"><code>&lt;desktop_name&gt;</code></td><td style="text-align: left">Desktop by name</td></tr>
<tr><td style="text-align: left"><code>occupied</code></td><td style="text-align: left">Desktops with windows</td></tr>
<tr><td style="text-align: left"><code>urgent</code></td><td style="text-align: left">Desktops with urgent windows</td></tr>
</tbody>
</table>
</div>
<p><strong>Practical Desktop Selector Examples:</strong></p>
<pre><code class="language-bash"># Focus the second desktop
bspc desktop ^2 -f

# Send window to desktop named "work" and follow
bspc node -d work --follow

# Focus an occupied desktop
bspc desktop .occupied -f

# List all unoccupied desktops
bspc query -D -d .!occupied
</code></pre>
<h3 id="d-monitor-selectors"><a class="header" href="#d-monitor-selectors">D. Monitor Selectors</a></h3>
<p><strong>Monitor Selectors</strong> target specific physical displays:</p>
<pre><code>MONITOR_SEL := [MONITOR_SEL#](DIR|CYCLE_DIR|any|last|newest|older|newer|focused|pointed|primary|^&lt;n&gt;|&lt;monitor_id&gt;|&lt;monitor_name&gt;)[.[!]focused][.[!]occupied]
</code></pre>
<p><strong>Practical Monitor Selector Examples:</strong></p>
<pre><code class="language-bash"># Focus the monitor to the right
bspc monitor east -f

# Focus the primary monitor
bspc monitor primary -f

# List all monitors
bspc query -M --names

# Send desktop to second monitor
bspc desktop -m ^2 --follow
</code></pre>
<h3 id="e-path-selectors-advanced-tree-navigation"><a class="header" href="#e-path-selectors-advanced-tree-navigation">E. Path Selectors: Advanced Tree Navigation</a></h3>
<p>Path selectors allow you to navigate the tree structure directly using spatial relationships:</p>
<pre><code>PATH := @[DESKTOP_SEL:][[/]JUMP](/JUMP)*
JUMP := first|1|second|2|brother|parent|DIR
</code></pre>
<p><strong>Path Navigation Examples:</strong></p>
<pre><code class="language-bash"># Focus first child of focused node
bspc node @/first -f

# Focus the second child
bspc node @/second -f

# Focus parent of focused node
bspc node @/parent -f

# Focus brother (sibling) of focused node
bspc node @/brother -f

# Navigate using directions within path
bspc node @/first/east -f

# Cross-desktop path navigation
bspc node @^2:/first -f  # First child of desktop 2
</code></pre>
<h2 id="iii-window-states-how-bspwm-manages-window-modes"><a class="header" href="#iii-window-states-how-bspwm-manages-window-modes">III. Window States: How BSPWM Manages Window Modes</a></h2>
<p>BSPWM provides four distinct window states that determine how windows are positioned and rendered. Understanding these states is crucial for effective window management.</p>
<h3 id="a-tiled-state"><a class="header" href="#a-tiled-state">A. Tiled State</a></h3>
<p><strong>Tiled</strong> windows are fully managed by the BSPWM tiling algorithm. Their size and position are entirely determined by their position in the binary tree and the tree’s split ratios. Windows in this state cannot overlap, and the entire monitor space is divided among them.</p>
<p><strong>Characteristics of Tiled Windows:</strong></p>
<ul>
<li>Respects and fills the rectangular region allocated by the tree</li>
<li>Cannot overlap other tiled or pseudo-tiled windows</li>
<li>Automatically resizes when the tree structure changes</li>
<li>Follows the configured border width and gaps</li>
<li>Cannot be freely moved or resized by the user (only through tree operations)</li>
</ul>
<p><strong>Example Configuration:</strong></p>
<pre><code class="language-bash"># Set focused window to tiled
bspc node focused -t tiled

# Set all windows of Firefox to tiled
bspc node .same_class -t tiled

# Create rule for specific application
bspc rule -a libroffice -t tiled
</code></pre>
<h3 id="b-pseudo-tiled-state"><a class="header" href="#b-pseudo-tiled-state">B. Pseudo-Tiled State</a></h3>
<p><strong>Pseudo-tiled</strong> (also called sticky floating or “forced”) windows are a hybrid between tiled and floating. They are positioned and sized according to the tree structure like tiled windows, but they automatically shrink to respect the application’s size hints (if enabled) and don’t stretch beyond their requested size.</p>
<p><strong>Characteristics of Pseudo-Tiled Windows:</strong></p>
<ul>
<li>Positioned like tiled windows (respects tree allocation)</li>
<li>Can shrink to respect window size hints</li>
<li>Won’t stretch beyond application’s preferred size</li>
<li>Useful for dialog windows, floating applications that you want managed by the tree</li>
<li>Still participate in the binary tree layout</li>
</ul>
<p><strong>Example Use Cases:</strong></p>
<pre><code class="language-bash"># Set to pseudo-tiled (good for dialogs)
bspc node focused -t pseudo_tiled

# Rule for GIMP tools palette (prefers fixed size)
bspc rule -a Gimp -t pseudo_tiled

# This window takes its tree space but respects its size hints
</code></pre>
<h3 id="c-floating-state"><a class="header" href="#c-floating-state">C. Floating State</a></h3>
<p><strong>Floating</strong> windows are completely freed from the tiling tree structure. They can be positioned and resized freely anywhere on the monitor, overlapping other windows. However, floating windows are still part of the tree structure (just not as visible participants) and still have a position in the tree hierarchy.</p>
<p><strong>Characteristics of Floating Windows:</strong></p>
<ul>
<li>Can be moved and resized freely with keyboard or mouse</li>
<li>Can overlap other windows</li>
<li>Still counted in the tree but don’t participate in tiling</li>
<li>Can be moved to different desktops</li>
<li>Useful for temporary windows, dialogs, notifications</li>
</ul>
<p><strong>Example Operations:</strong></p>
<pre><code class="language-bash"># Set focused window to floating
bspc node focused -t floating

# Move floating window by pixels
bspc node focused -v -20 0    # Move left 20 pixels
bspc node focused -v 0 20     # Move down 20 pixels

# Resize floating window
bspc node focused -z bottom 0 20  # Expand bottom side

# Focus floating windows only
bspc node .floating -f
</code></pre>
<h3 id="d-fullscreen-state"><a class="header" href="#d-fullscreen-state">D. Fullscreen State</a></h3>
<p><strong>Fullscreen</strong> windows fill the entire monitor rectangle with no borders or gaps. Fullscreen windows are always on top (in the NORMAL stacking layer by default) and completely hide other windows beneath them. Important: BSPWM uses different stacking layers which affect fullscreen behavior.</p>
<p><strong>Characteristics of Fullscreen Windows:</strong></p>
<ul>
<li>Fills entire monitor dimensions</li>
<li>No borders, gaps, or padding applied</li>
<li>Appears above all other windows</li>
<li>Can be overridden by ABOVE-layer windows</li>
<li>Useful for games, presentations, full-screen applications</li>
</ul>
<p><strong>Example Operations:</strong></p>
<pre><code class="language-bash"># Toggle current window fullscreen
bspc node focused -t fullscreen

# Set specific application to fullscreen
bspc rule -a mpv -t fullscreen

# Make fullscreen window exit
bspc node focused -t tiled  # Return to tiled

# Focus under fullscreen window (requires switching states)
bspc node focused.fullscreen -t floating
</code></pre>
<h3 id="e-state-toggling-and-dynamic-switching"><a class="header" href="#e-state-toggling-and-dynamic-switching">E. State Toggling and Dynamic Switching</a></h3>
<p>BSPWM supports elegant state toggling using the tilde <code>~</code> character, which switches between the current state and the previous state:</p>
<pre><code class="language-bash"># Toggle between current and previous state
bspc node focused -t ~

# Toggle to specific state (if currently in that state, revert)
bspc node focused -t ~floating  # If floating, goes back; if not, becomes floating

# Create sxhkd binding for cycling through states
super + {t,s,f}
    bspc node -t {tiled,pseudo_tiled,floating}
    
# Or with toggling
super + shift + {t,s,f}
    bspc node -t {~tiled,~pseudo_tiled,~floating}
</code></pre>
<h2 id="iv-node-flags-behavioral-modifiers-for-windows"><a class="header" href="#iv-node-flags-behavioral-modifiers-for-windows">IV. Node Flags: Behavioral Modifiers for Windows</a></h2>
<p>Node flags are boolean properties that modify how BSPWM treats a particular window beyond just its state. These flags enable powerful window management patterns and advanced configurations.</p>
<h3 id="a-hidden-flag"><a class="header" href="#a-hidden-flag">A. Hidden Flag</a></h3>
<p><strong>Hidden</strong> windows are completely removed from the layout and hidden from view. They don’t occupy any tiling space and can be toggled to reappear later.</p>
<p><strong>Usage Examples:</strong></p>
<pre><code class="language-bash"># Hide focused window
bspc node focused -g hidden

# Show all hidden windows on current desktop
bspc node .hidden -g hidden=off

# Toggle hidden state
bspc node focused -g hidden=toggle

# Script to create scratchpad functionality
#!/bin/bash
if bspc node focused -g | grep hidden; then
    bspc node focused -g hidden=off -f
else
    bspc node focused -g hidden=on
fi
</code></pre>
<h3 id="b-sticky-flag"><a class="header" href="#b-sticky-flag">B. Sticky Flag</a></h3>
<p><strong>Sticky</strong> windows automatically follow the focused desktop of their monitor. This means if you switch desktops on a monitor, the sticky window moves with you, remaining visible on every desktop you visit.</p>
<p><strong>Use Cases:</strong></p>
<ul>
<li>Always-visible status windows</li>
<li>Quick-reference applications</li>
<li>Floating notes or widgets</li>
<li>Monitor-persistent applications</li>
</ul>
<p><strong>Configuration:</strong></p>
<pre><code class="language-bash"># Make focused window sticky
bspc node focused -g sticky

# Rule for always-visible terminal
bspc rule -a sticky_terminal -g sticky=on -t floating

# Create sticky note/dashboard window
st -n sticky_widget &amp;  # Custom class
bspc rule -a sticky_widget -g sticky=on state=floating

# Sxhkd binding
super + shift + s
    bspc node focused -g sticky
</code></pre>
<h3 id="c-private-flag"><a class="header" href="#c-private-flag">C. Private Flag</a></h3>
<p><strong>Private</strong> windows attempt to maintain their tiling position and size even when other windows are added or removed from the tree. This prevents automatic resizing when the tree structure changes.</p>
<p><strong>Behavior:</strong></p>
<ul>
<li>Resists repositioning when tree changes</li>
<li>Useful for preventing windows from being moved around</li>
<li>Maintains size hints more strictly</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-bash"># Make a media player private so it stays in place
bspc node id:0x00800001 -g private

# Rule for video players
bspc rule -a vlc -g private=on

# Practical use: video window that shouldn't move when opening other windows
</code></pre>
<h3 id="d-locked-flag"><a class="header" href="#d-locked-flag">D. Locked Flag</a></h3>
<p><strong>Locked</strong> windows ignore the <code>node -c</code> (close) command, preventing accidental closure through keyboard shortcuts. They can only be closed using <code>node -k</code> (kill) or through the application’s own UI.</p>
<p><strong>Usage:</strong></p>
<pre><code class="language-bash"># Lock focused window against closure
bspc node focused -g locked

# Lock specific application
bspc rule -a firefox -g locked=on

# Toggle lock state
bspc node focused -g locked=toggle

# In sxhkd, you might have:
super + shift + l
    bspc node focused -g locked
    
# And then close uses -c which is ignored for locked nodes
super + shift + w
    bspc node focused -c  # Silently fails for locked windows
</code></pre>
<h3 id="e-marked-flag"><a class="header" href="#e-marked-flag">E. Marked Flag</a></h3>
<p><strong>Marked</strong> nodes are flagged with an arbitrary marker that serves as a building block for custom scripting. A marked node automatically becomes unmarked after being sent to a preselected node.</p>
<p><strong>Key Characteristics:</strong></p>
<ul>
<li>Completely arbitrary—doesn’t change behavior by itself</li>
<li>Used for deferred operations (mark now, operate later)</li>
<li>Automatically unmarks after preselection</li>
<li>Enables powerful multi-step workflows</li>
</ul>
<p><strong>Practical Examples:</strong></p>
<pre><code class="language-bash"># Mark a node for later operation
bspc node focused -g marked

# Move all marked nodes to preselected location
bspc node newest.marked.local -n newest.!automatic.local

# Sxhkd workflow example:
# Step 1: Mark windows
super + m
    bspc node focused -g marked

# Step 2: Navigate and preselect area
super + p; {h,j,k,l}
    bspc node -p {west,south,north,east}

# Step 3: Move marked nodes to preselection
super + y
    bspc node newest.marked.local -n newest.!automatic.local

# Practical workflow: mark multiple windows, define their layout with
# preselections, then move them all at once
</code></pre>
<h3 id="f-urgent-flag"><a class="header" href="#f-urgent-flag">F. Urgent Flag</a></h3>
<p><strong>Urgent</strong> windows have their urgency hint set externally (usually by applications requesting attention—like chat notifications). This flag indicates that a window requires user attention.</p>
<p><strong>BSPWM Behavior with Urgent:</strong></p>
<ul>
<li>Desktop containing urgent window can be highlighted differently</li>
<li>Can be used to style borders in unique colors</li>
<li>Can drive notifications to user</li>
</ul>
<p><strong>Configuration:</strong></p>
<pre><code class="language-bash"># Style urgent windows differently
bspc config urgent_border_color "#FF0000"

# Focus urgent windows
bspc node .urgent -f

# Clear urgency (focus the window)
bspc node focused -f
</code></pre>
<h3 id="g-managing-multiple-flags-simultaneously"><a class="header" href="#g-managing-multiple-flags-simultaneously">G. Managing Multiple Flags Simultaneously</a></h3>
<p>Flags can be combined and managed together:</p>
<pre><code class="language-bash"># Set multiple flags at once
bspc node focused -g hidden=on -g sticky=on -g locked=on

# Toggle specific flag
bspc node focused -g marked=toggle

# Create comprehensive window configuration
bspc rule -a myapp \
    -g hidden=off \
    -g sticky=on \
    -g private=on \
    state=floating
</code></pre>
<h2 id="v-stacking-layers-window-z-order-management"><a class="header" href="#v-stacking-layers-window-z-order-management">V. Stacking Layers: Window Z-Order Management</a></h2>
<p>BSPWM implements three stacking layers that determine the Z-order (depth) in which windows are rendered. This provides fine control over which windows appear on top.</p>
<h3 id="a-layer-overview"><a class="header" href="#a-layer-overview">A. Layer Overview</a></h3>
<pre><code>ABOVE ────────── (highest Z-order)
  ├── Fullscreen &gt; Floating &gt; Tiled
NORMAL ────────── (default)
  ├── Fullscreen &gt; Floating &gt; Tiled
BELOW ────────── (lowest Z-order)
  ├── Fullscreen &gt; Floating &gt; Tiled
</code></pre>
<p>Within each layer, windows follow a consistent drawing order: fullscreen windows appear above floating windows, which appear above tiled/pseudo-tiled windows.</p>
<h3 id="b-setting-and-managing-layers"><a class="header" href="#b-setting-and-managing-layers">B. Setting and Managing Layers</a></h3>
<p><strong>The ABOVE Layer:</strong>
Used for permanently visible windows that should never be hidden:</p>
<pre><code class="language-bash"># Make window appear above everything
bspc node focused -l above

# Typical use: notification windows, always-on-top utilities
bspc rule -a notification -l above

# Floating panel that should stay visible
</code></pre>
<p><strong>The NORMAL Layer:</strong>
The default layer for most windows:</p>
<pre><code class="language-bash"># Return to normal layer
bspc node focused -l normal

# Most windows stay here
</code></pre>
<p><strong>The BELOW Layer:</strong>
For background windows:</p>
<pre><code class="language-bash"># Place window below everything
bspc node focused -l below

# Use case: background wallpaper application, monitor display
bspc rule -a wallpaper_app -l below
</code></pre>
<h3 id="c-practical-layer-usage"><a class="header" href="#c-practical-layer-usage">C. Practical Layer Usage</a></h3>
<pre><code class="language-bash"># Create an always-on-top floating window
bspc node floating_app -l above

# Desktop setup: wallpaper below, then tiled windows, then floating on top
bspc node .wallpaper -l below
bspc node .tiled -l normal
bspc node .floating -l above

# Advanced: fullscreen overlay
# When you want a fullscreen window but something above it
bspc rule -a overlay_app -t floating -l above -r

# Solve fullscreen problems: put floating windows on above layer
bspc config external_rules_command ~/.config/bspwm/external_rules

# In external_rules script:
[[ "$(xdotool getactivewindow getwindowname)" == *"Overlay"* ]] &amp;&amp; \
    echo "layer=above"
</code></pre>
<h2 id="vi-receptacles-the-empty-node-concept"><a class="header" href="#vi-receptacles-the-empty-node-concept">VI. Receptacles: The Empty Node Concept</a></h2>
<p><strong>Receptacles</strong> are leaf nodes in the tree that don’t hold any window. They serve as placeholders for future window placements and enable powerful tree-building patterns.</p>
<h3 id="a-understanding-receptacles"><a class="header" href="#a-understanding-receptacles">A. Understanding Receptacles</a></h3>
<p>When you insert a receptacle at a node’s location, it becomes an empty leaf in the tree. When a new window is opened and directed to a receptacle (in automatic mode), the receptacle is replaced by the window node. This allows you to pre-build the entire tree structure before opening windows.</p>
<p><strong>Receptacle Key Properties:</strong></p>
<ul>
<li>Leaf nodes without windows</li>
<li>Can be inserted explicitly at any location</li>
<li>Automatically replaced when window inserted in automatic mode</li>
<li>Can be preselected and killed manually</li>
<li>Useful for creating fixed layouts</li>
</ul>
<h3 id="b-creating-and-managing-receptacles"><a class="header" href="#b-creating-and-managing-receptacles">B. Creating and Managing Receptacles</a></h3>
<pre><code class="language-bash"># Insert receptacle at focused node
bspc node focused -i

# Insert receptacle on specific location
bspc node -n @/first -i

# Kill a receptacle
bspc node receptacle_id -k

# Query all receptacles on desktop
bspc query -N -n .leaf.!window

# List receptacle IDs
bspc query -N -n .receptacle
</code></pre>
<h3 id="c-receptacle-based-layout-system"><a class="header" href="#c-receptacle-based-layout-system">C. Receptacle-Based Layout System</a></h3>
<p>Receptacles enable a sophisticated layout system using dump/load:</p>
<pre><code class="language-bash">#!/bin/bash
# Build layout with receptacles
bspc desktop ^1 -l monocle

# Create tree structure using receptacles
bspc node -i           # Receptacle 1
bspc node -i           # Receptacle 2
bspc node -i           # Receptacle 3

# Now when you open windows, they fill these receptacles in order
# Window 1 goes to receptacle 1
# Window 2 goes to receptacle 2
# Window 3 goes to receptacle 3

# Dump this state
bspc wm -d &gt; ~/.config/bspwm/layouts/my_layout.json

# Later, restore with:
bspc wm -l ~/.config/bspwm/layouts/my_layout.json
</code></pre>
<h3 id="d-receptacle-vs-preselection-comparison"><a class="header" href="#d-receptacle-vs-preselection-comparison">D. Receptacle vs. Preselection Comparison</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th style="text-align: left">Aspect</th><th style="text-align: left">Receptacle</th><th style="text-align: left">Preselection</th></tr>
</thead>
<tbody>
<tr><td style="text-align: left">Visual Feedback</td><td style="text-align: left">None</td><td style="text-align: left">Colored preview area</td></tr>
<tr><td style="text-align: left">Automatic Replacement</td><td style="text-align: left">Yes, in auto mode</td><td style="text-align: left">No, requires manual action</td></tr>
<tr><td style="text-align: left">Multiple Instances</td><td style="text-align: left">Yes, can have many</td><td style="text-align: left">Yes, one per node</td></tr>
<tr><td style="text-align: left">Persistence</td><td style="text-align: left">Until window inserted</td><td style="text-align: left">Canceled on split</td></tr>
<tr><td style="text-align: left">Use Case</td><td style="text-align: left">Pre-build layouts</td><td style="text-align: left">Interactive splitting</td></tr>
</tbody>
</table>
</div>
<pre><code class="language-bash"># Using receptacles for fixed layout
bspc node -i; bspc node -i; bspc node -i  # 3 receptacles
# Open windows - they fill the receptacles

# Using preselection for interactive layout
bspc node -p west      # Next window splits to west
# Open window - it appears to the west
</code></pre>
<h2 id="vii-insertion-modes-automatic-vs-manual-window-placement"><a class="header" href="#vii-insertion-modes-automatic-vs-manual-window-placement">VII. Insertion Modes: Automatic vs. Manual Window Placement</a></h2>
<p>BSPWM provides two insertion modes that determine how new windows are positioned in the tree: automatic and manual modes.</p>
<h3 id="a-automatic-insertion-mode-default"><a class="header" href="#a-automatic-insertion-mode-default">A. Automatic Insertion Mode (Default)</a></h3>
<p>In <strong>automatic</strong> mode, new windows are inserted according to one of three schemes that automatically determine where they should go:</p>
<p><strong>How Automatic Mode Works:</strong>
When in automatic insertion mode at node N, a new window takes the space of N, and N is displaced into a new branch. The tree automatically reorganizes to accommodate the new window.</p>
<p><strong>The Three Automatic Schemes:</strong></p>
<p><strong>1. Spiral Scheme (Default: “alternate”)</strong>
The spiral scheme creates a rotating pattern where windows are arranged in a spiral from outside inward (or inside outward, depending on <code>initial_polarity</code>). This is the most common and visually appealing default:</p>
<pre><code class="language-bash"># Enable spiral (alternate) scheme
bspc config automatic_scheme alternate

# How it works visually:
# With 4 windows:
#   ┌─────────────────┐
#   │       1         │
#   │  ┌────────┐     │
#   │  │   2    │  4  │
#   │  │ ┌──┐   │     │
#   │  │ │3 │   │     │
#   │  │ └──┘   │     │
#   │  └────────┘     │
#   └─────────────────┘

# Sxhkd binding to switch schemes
super + shift + a
    bspc config automatic_scheme alternate &amp;&amp; \
    notify-send "Spiral mode"
</code></pre>
<p><strong>2. Longest Side Scheme</strong>
The longest_side scheme always splits the longest side of the available rectangle, creating a more balanced layout:</p>
<pre><code class="language-bash"># Enable longest side scheme
bspc config automatic_scheme longest_side

# How it works: always splits the longest rectangle edge
# Tends to create more balanced, square-ish windows

# Practical comparison:
# Spiral creates:     │ Longest_side creates:
#    │ │ │ │ │         │  │  │
#    ├─┼─┼─┼─┤         ├──┼──┤
#    │ │ │ │ │         │  │  │
#    ├─┴─┴─┴─┤         └──┴──┘

super + shift + l
    bspc config automatic_scheme longest_side &amp;&amp; \
    notify-send "Longest side mode"
</code></pre>
<p><strong>3. Alternate Scheme</strong>
Alternates between horizontal and vertical splits in a consistent pattern:</p>
<pre><code class="language-bash"># Note: Recent versions use "alternate" for spiral
# Check documentation for your version
bspc config automatic_scheme spiral  # May be labeled "spiral" in newer versions
</code></pre>
<h3 id="b-manual-insertion-mode-preselection"><a class="header" href="#b-manual-insertion-mode-preselection">B. Manual Insertion Mode (Preselection)</a></h3>
<p>In <strong>manual</strong> mode, you explicitly specify where the next window should be placed using preselection. This allows precise control over window placement:</p>
<p><strong>How Manual Mode Works:</strong></p>
<ol>
<li>Select a node</li>
<li>Preselect a direction (north, south, east, west)</li>
<li>When a new window opens, it automatically appears in the preselected direction</li>
<li>The preselection is consumed and automatic mode resumes</li>
</ol>
<pre><code class="language-bash"># Enable preselection on focused node
bspc node -p west       # Next window splits to the west (left)
bspc node -p north      # Next window splits to the north (top)
bspc node -p south      # Next window splits to the south (bottom)
bspc node -p east       # Next window splits to the east (right)

# Cancel preselection
bspc node -p cancel

# Adjust preselection ratio (default 0.5)
bspc node -o 0.3        # Next window gets 30%, current gets 70%
bspc node -o 0.7        # Next window gets 70%, current gets 30%

# Example workflow:
# 1. Preselect split direction
bspc node -p west
# 2. Open new window (e.g., Alt+Enter in sxhkd)
# 3. New window appears to the west
# 4. Preselection is consumed, back to automatic mode
</code></pre>
<h3 id="c-configuration-options-for-insertion"><a class="header" href="#c-configuration-options-for-insertion">C. Configuration Options for Insertion</a></h3>
<pre><code class="language-bash"># Set automatic scheme
bspc config automatic_scheme {alternate|longest_side|spiral}

# Set initial polarity (where to attach on single-node tree)
bspc config initial_polarity first_child   # Attach as first child
bspc config initial_polarity second_child  # Attach as second child

# Set directional focus tightness (affects directional selection)
bspc config directional_focus_tightness high   # Strict direction matching
bspc config directional_focus_tightness low    # Loose direction matching

# Enable/disable removal adjustment
bspc config removal_adjustment true   # Adjust tree when removing windows
</code></pre>
<h3 id="d-practical-insertion-mode-usage"><a class="header" href="#d-practical-insertion-mode-usage">D. Practical Insertion Mode Usage</a></h3>
<pre><code class="language-bash"># Sxhkd complete example:
# Focus node and cycle insertion schemes
super + shift + {a,l,s}
    bspc config automatic_scheme {alternate,longest_side,spiral} &amp;&amp; \
    notify-send "Scheme: $(bspc config automatic_scheme)"

# Preselection workflow
super + ctrl + {h,j,k,l}
    bspc node -p {west,south,north,east}

# Clear preselection
super + ctrl + space
    bspc node -p cancel

# Adjust preselection ratio
super + {minus,equal}
    RATIO=$(bspc config split_ratio); \
    bspc config split_ratio $(bc &lt;&lt;&lt; "scale=2; $RATIO - 0.05") || \
    bspc config split_ratio $(bc &lt;&lt;&lt; "scale=2; $RATIO + 0.05")

# Open window (in preselection, goes to preselected location)
super + Return
    terminal
</code></pre>
<h2 id="viii-node-operations-commands-for-window-management"><a class="header" href="#viii-node-operations-commands-for-window-management">VIII. Node Operations: Commands for Window Management</a></h2>
<p>The <code>node</code> domain contains the most frequently used commands for managing individual windows.</p>
<h3 id="a-focus-operations"><a class="header" href="#a-focus-operations">A. Focus Operations</a></h3>
<p><strong>Focus</strong> moves keyboard and mouse input to a specific window:</p>
<pre><code class="language-bash"># Focus specific selector
bspc node SELECTOR -f

# Focus east window
bspc node east -f

# Focus the biggest window
bspc node biggest -f

# Focus floating windows
bspc node .floating -f

# Focus window by ID
bspc node 0x00800001 -f

# Focus and follow (for multi-monitor):
bspc node NODE_SEL -f --follow

# Sxhkd focus example:
super + {h,j,k,l}
    bspc node -f {west,south,north,east}

super + {comma,period}
    bspc node -f {prev,next}.local.!hidden.window

super + bracket{left,right}
    bspc desktop -f {prev,next}.local
</code></pre>
<h3 id="b-activation-operations"><a class="header" href="#b-activation-operations">B. Activation Operations</a></h3>
<p><strong>Activate</strong> sets a node as the active node of its desktop (for multi-monitor awareness):</p>
<pre><code class="language-bash"># Activate focused node
bspc node focused -a

# This differs from focus in multi-monitor setups
# Focus changes which window receives input
# Activate sets which is "most recent" on that desktop
</code></pre>
<h3 id="c-moving-windows-between-desktops"><a class="header" href="#c-moving-windows-between-desktops">C. Moving Windows Between Desktops</a></h3>
<p><strong>Send to Desktop</strong> moves a window to a different workspace:</p>
<pre><code class="language-bash"># Send to specific desktop
bspc node -d DESKTOP_SEL

# Send to desktop 2
bspc node -d ^2

# Send to named desktop
bspc node -d "work"

# Send and follow (keep focus on window)
bspc node -d ^2 --follow

# Sxhkd example:
super + shift + {1-9,0}
    bspc node -d '^{1-9,10}' --follow

# Move to next desktop
super + shift + bracket{left,right}
    bspc node -d {prev,next}.local --follow
</code></pre>
<h3 id="d-moving-windows-between-monitors"><a class="header" href="#d-moving-windows-between-monitors">D. Moving Windows Between Monitors</a></h3>
<p><strong>Send to Monitor</strong> moves windows to different physical displays:</p>
<pre><code class="language-bash"># Send to specific monitor
bspc node -m MONITOR_SEL

# Send to east monitor
bspc node -m east --follow

# Send to primary monitor
bspc node -m primary --follow

# Sxhkd example:
super + shift + m
    bspc node -m next --follow

# Send to specific monitor and follow
super + shift + {Left,Right}
    bspc node -m {west,east} --follow
</code></pre>
<h3 id="e-swapping-nodes"><a class="header" href="#e-swapping-nodes">E. Swapping Nodes</a></h3>
<p><strong>Swap</strong> exchanges the position of two nodes in the tree:</p>
<pre><code class="language-bash"># Swap with another node
bspc node -s NODE_SEL

# Swap with brother (sibling)
bspc node -s @brother

# Swap with previous window
bspc node -s prev

# Swap and follow (focus stays on window being swapped)
bspc node -s NODE_SEL --follow

# Practical example:
# Swap with biggest window
super + g
    bspc node -s biggest.window

# Swap with last focused
super + shift + g
    bspc node -s last
</code></pre>
<h3 id="f-resizing-and-adjusting-windows"><a class="header" href="#f-resizing-and-adjusting-windows">F. Resizing and Adjusting Windows</a></h3>
<p><strong>Move</strong> repositions floating windows:</p>
<pre><code class="language-bash"># Move floating window by pixels
bspc node -v dx dy

# Move left 20 pixels
bspc node -v -20 0

# Move down 20 pixels
bspc node -v 0 20

# Sxhkd example for floating window movement:
super + shift + {Left,Down,Up,Right}
    bspc node -v {-20 0,0 20,0 -20,20 0}
</code></pre>
<p><strong>Resize</strong> changes window dimensions:</p>
<pre><code class="language-bash"># Resize by moving a specific edge
bspc node -z EDGE dx dy

# EDGE options: top, left, bottom, right, top_left, top_right, bottom_left, bottom_right

# Expand bottom edge by 20 pixels
bspc node -z bottom 0 20

# Contract left edge by 20 pixels
bspc node -z left 20 0

# Sxhkd resizing mode:
super + alt + {h,j,k,l}
    bspc node -z {left -20 0,bottom 0 20,top 0 -20,right 20 0}

# Or contract:
super + alt + shift + {h,j,k,l}
    bspc node -z {left 20 0,bottom 0 -20,top 0 20,right -20 0}

# Continuous resize mode (like vim motions):
super + r : {h,j,k,l}
    bspc node -z {left -20 0,bottom 0 20,top 0 -20,right 20 0}
</code></pre>
<h3 id="g-managing-split-ratios-tiled-windows"><a class="header" href="#g-managing-split-ratios-tiled-windows">G. Managing Split Ratios (tiled windows)</a></h3>
<p><strong>Ratio</strong> adjusts how space is divided between windows:</p>
<pre><code class="language-bash"># Set specific ratio (0 &lt; ratio &lt; 1)
bspc node -r RATIO

# Set to 0.6 (60/40 split)
bspc node -r 0.6

# Adjust by relative amount
bspc node -r +0.05    # Increase ratio by 5%
bspc node -r -0.05    # Decrease ratio by 5%

# Change by pixel amount
bspc node -r +10px    # Increase by 10 pixels
bspc node -r -10px    # Decrease by 10 pixels

# Sxhkd ratio adjustment:
super + shift + {minus,equal}
    bspc node -r {-0.05,+0.05}

# Balance splits
super + b
    bspc node @focused -B
</code></pre>
<h3 id="h-tree-manipulation-operations"><a class="header" href="#h-tree-manipulation-operations">H. Tree Manipulation Operations</a></h3>
<p><strong>Rotate</strong> spins the tree structure at a node:</p>
<pre><code class="language-bash"># Rotate 90 degrees clockwise
bspc node -R 90

# Rotate 180 degrees
bspc node -R 180

# Rotate 270 degrees (or -90)
bspc node -R 270

# Sxhkd binding:
super + {comma,period}
    bspc node @focused -R {90,-90}
</code></pre>
<p><strong>Flip</strong> mirrors the tree:</p>
<pre><code class="language-bash"># Flip horizontally (left-right)
bspc node -F horizontal

# Flip vertically (top-bottom)
bspc node -F vertical

# Sxhkd bindings:
super + {slash,backslash}
    bspc node @focused -F {horizontal,vertical}
</code></pre>
<p><strong>Circulate</strong> rotates windows in the tree:</p>
<pre><code class="language-bash"># Circulate windows forward (clockwise)
bspc node -C forward

# Circulate windows backward (counter-clockwise)
bspc node -C backward

# Practical use: rotate order of windows without changing layout
super + shift + c
    bspc node -C forward

# This moves: window1 -&gt; window2 -&gt; window3 -&gt; window1
</code></pre>
<p><strong>Equalize</strong> resets all split ratios to default (0.5):</p>
<pre><code class="language-bash"># Reset all ratios in tree
bspc node -E

# Useful when tree becomes unbalanced
super + shift + e
    bspc node -E

# Undo manual resizing
</code></pre>
<p><strong>Balance</strong> adjusts ratios so all leaves occupy equal area:</p>
<pre><code class="language-bash"># Balance the tree
bspc node -B

# After resizing, rebalance:
super + shift + b
    bspc node -B

# Different from equalize:
# Equalize: all ratios = 0.5
# Balance: adjusts all ratios so leaf areas are equal
</code></pre>
<h3 id="i-window-state-and-flag-management"><a class="header" href="#i-window-state-and-flag-management">I. Window State and Flag Management</a></h3>
<p><strong>State</strong> changes window state:</p>
<pre><code class="language-bash"># Set specific state
bspc node -t STATE

# States: tiled, pseudo_tiled, floating, fullscreen

# Toggle to previous state
bspc node -t ~

# Toggle to specific state (if already in state, revert)
bspc node -t ~floating  # floating &lt;-&gt; previous state

# Sxhkd state cycling:
super + {t,shift+t,s,f}
    bspc node -t {tiled,pseudo_tiled,floating,fullscreen}

# Individual toggles:
super + shift + t
    bspc node -t floating
super + shift + f
    bspc node -t fullscreen
</code></pre>
<p><strong>Flag</strong> manages node flags:</p>
<pre><code class="language-bash"># Set flag on/off
bspc node -g FLAG={on|off}

# Toggle flag
bspc node -g FLAG

# Flags: hidden, sticky, private, locked, marked, urgent

# Examples:
bspc node -g hidden=on       # Hide window
bspc node -g locked=toggle   # Toggle lock
bspc node -g marked          # Mark (toggle)

# Sxhkd bindings:
super + ctrl + {m,x,y,z}
    bspc node -g {marked,locked,sticky,private}

# Sticky window:
super + shift + s
    bspc node -g sticky=toggle
</code></pre>
<p><strong>Layer</strong> sets stacking layer:</p>
<pre><code class="language-bash"># Set layer
bspc node -l LAYER

# Layers: below, normal, above

bspc node -l above    # Always on top
bspc node -l normal   # Standard (default)
bspc node -l below    # Background

# Sxhkd binding:
super + {comma,period}
    bspc node -l {below,above}
</code></pre>
<h3 id="j-closing-and-killing-windows"><a class="header" href="#j-closing-and-killing-windows">J. Closing and Killing Windows</a></h3>
<p><strong>Close</strong> sends a close signal to the window:</p>
<pre><code class="language-bash"># Close focused window (gracefully)
bspc node -c

# Close window by selector
bspc node NODE_SEL -c

# Sxhkd:
super + shift + w
    bspc node -c
</code></pre>
<p><strong>Kill</strong> forcefully terminates the window:</p>
<pre><code class="language-bash"># Kill focused window
bspc node -k

# Kill all windows on desktop
bspc node -k

# Use kill when close doesn't work
super + shift + q
    bspc node -k
</code></pre>
<h3 id="k-inserting-and-managing-receptacles"><a class="header" href="#k-inserting-and-managing-receptacles">K. Inserting and Managing Receptacles</a></h3>
<p><strong>Insert Receptacle</strong> creates empty placeholder nodes:</p>
<pre><code class="language-bash"># Insert receptacle at focused node location
bspc node -i

# Build layout with receptacles before opening windows
bspc node -i; bspc node -i; bspc node -i

# Then open windows and they fill receptacles

# Script to create grid layout:
#!/bin/bash
# Create 2x2 grid of receptacles
bspc desktop -l tiled
for i in {1..3}; do bspc node -i; done
</code></pre>
<h2 id="ix-desktop-operations-workspace-management"><a class="header" href="#ix-desktop-operations-workspace-management">IX. Desktop Operations: Workspace Management</a></h2>
<p>The <code>desktop</code> domain manages virtual desktops/workspaces.</p>
<h3 id="a-creating-and-managing-desktops"><a class="header" href="#a-creating-and-managing-desktops">A. Creating and Managing Desktops</a></h3>
<p><strong>Add Desktops</strong> to a monitor:</p>
<pre><code class="language-bash"># Create desktops
bspc monitor -a NAMES

# Add desktops to current monitor
bspc monitor -a I II III IV V

# Multiple desktops at once:
bspc monitor -a I II III IV V VI VII VIII IX X

# Sxhkd configuration (in bspwmrc):
bspc monitor -a 1 2 3 4 5 6 7 8 9 10
</code></pre>
<p><strong>Reset Desktops</strong> to match a list:</p>
<pre><code class="language-bash"># Replace desktop list
bspc monitor -d NAMES

# Removes, adds, or renames desktops to match list
bspc monitor -d one two three
</code></pre>
<p><strong>Rename Desktop:</strong></p>
<pre><code class="language-bash"># Rename desktop
bspc desktop -n NAME

# Example:
bspc desktop -n "work"
bspc desktop ^2 -n "media"
</code></pre>
<p><strong>Remove Desktop:</strong></p>
<pre><code class="language-bash"># Remove empty desktop
bspc desktop -r

# Remove desktop 5
bspc desktop ^5 -r
</code></pre>
<h3 id="b-focusing-desktops"><a class="header" href="#b-focusing-desktops">B. Focusing Desktops</a></h3>
<p><strong>Focus Desktop:</strong></p>
<pre><code class="language-bash"># Focus specific desktop
bspc desktop SELECTOR -f

# Focus desktop 2
bspc desktop ^2 -f

# Focus next desktop
bspc desktop next -f

# Focus previous
bspc desktop prev -f

# Focus by name
bspc desktop "work" -f

# Sxhkd bindings:
super + {1-9,0}
    bspc desktop -f '^{1-9,10}'

# Cycle through desktops
super + {Right,Left}
    bspc desktop -f {next,prev}.local
</code></pre>
<h3 id="c-desktop-layout"><a class="header" href="#c-desktop-layout">C. Desktop Layout</a></h3>
<p><strong>Layout</strong> switches between tiling modes:</p>
<pre><code class="language-bash"># Switch layout
bspc desktop -l LAYOUT

# Layouts: tiled (default), monocle

# Set to monocle (one window fullscreen)
bspc desktop -l monocle

# Cycle layout
bspc desktop -l next

# Sxhkd:
super + m
    bspc desktop -l next

# Or explicit:
super + {t,f}
    bspc desktop -l {tiled,monocle}
</code></pre>
<p><strong>Monocle Layout Options:</strong></p>
<pre><code class="language-bash"># Borderless monocle (no window borders)
bspc config borderless_monocle true

# Gapless monocle (no gaps)
bspc config gapless_monocle true

# Padding in monocle
bspc config top_monocle_padding 20
bspc config left_monocle_padding 20
bspc config right_monocle_padding 20
bspc config bottom_monocle_padding 20

# Single window uses monocle
bspc config single_monocle true
</code></pre>
<h3 id="d-moving-and-swapping-desktops"><a class="header" href="#d-moving-and-swapping-desktops">D. Moving and Swapping Desktops</a></h3>
<p><strong>Send Node to Desktop:</strong></p>
<pre><code class="language-bash"># Send focused window to desktop
bspc node -d DESKTOP_SEL

# Send to desktop 2
bspc node -d ^2

# Send and follow (keep focus on window)
bspc node -d ^2 --follow

# Send to named desktop
bspc node -d "work" --follow

# Sxhkd example:
super + shift + {1-9,0}
    bspc node -d '^{1-9,10}' --follow
</code></pre>
<p><strong>Swap Desktops:</strong></p>
<pre><code class="language-bash"># Swap position of two desktops
bspc desktop -s DESKTOP_SEL

# Swap focused with desktop 2
bspc desktop -s ^2

# Sxhkd:
super + shift + {Left,Right}
    bspc desktop -s {prev,next}.local
</code></pre>
<p><strong>Move Desktop to Monitor:</strong></p>
<pre><code class="language-bash"># Move desktop to different monitor
bspc desktop -m MONITOR_SEL

# Move desktop to east monitor
bspc desktop -m east

# Sxhkd:
super + alt + {Left,Right}
    bspc desktop -m {west,east}
</code></pre>
<h3 id="e-bubble-and-reorder-desktops"><a class="header" href="#e-bubble-and-reorder-desktops">E. Bubble and Reorder Desktops</a></h3>
<p><strong>Bubble</strong> moves desktop in focus order:</p>
<pre><code class="language-bash"># Bubble left (move before previous)
bspc desktop -b prev

# Bubble right (move after next)
bspc desktop -b next

# Sxhkd:
super + shift + {comma,period}
    bspc desktop -b {prev,next}
</code></pre>
<h2 id="x-monitor-operations-multi-display-management"><a class="header" href="#x-monitor-operations-multi-display-management">X. Monitor Operations: Multi-Display Management</a></h2>
<p>Monitor operations manage physical displays or virtual outputs.</p>
<h3 id="a-monitor-configuration"><a class="header" href="#a-monitor-configuration">A. Monitor Configuration</a></h3>
<p><strong>Add Monitor:</strong></p>
<pre><code class="language-bash"># Add virtual monitor
bspc wm -a NAME WIDTHxHEIGHT+X+Y

# Example: virtual 1920x1080 at position 0,0
bspc wm -a virtual_monitor 1920x1080+0+0
</code></pre>
<p><strong>Reset Monitor Rectangle:</strong></p>
<pre><code class="language-bash"># Set monitor dimensions and position
bspc monitor -g WIDTHxHEIGHT+X+Y

# Set to 1920x1080 at 0,0
bspc monitor -g 1920x1080+0+0

# Get current monitor dimensions
bspc query -M -m focused -T | jq '.rectangle'
</code></pre>
<p><strong>Rename Monitor:</strong></p>
<pre><code class="language-bash"># Rename monitor
bspc monitor -n NAME

# Rename primary monitor
bspc monitor primary -n "Main"
</code></pre>
<p><strong>Remove Monitor:</strong></p>
<pre><code class="language-bash"># Remove monitor
bspc monitor -r

# Must be empty or desktops transferred first
</code></pre>
<h3 id="b-focus-and-swap"><a class="header" href="#b-focus-and-swap">B. Focus and Swap</a></h3>
<p><strong>Focus Monitor:</strong></p>
<pre><code class="language-bash"># Focus specific monitor
bspc monitor SELECTOR -f

# Focus east monitor
bspc monitor east -f

# Focus primary
bspc monitor primary -f

# Focus next monitor
bspc monitor next -f

# Sxhkd:
super + shift + {h,j,k,l}
    bspc monitor -f {west,south,north,east}
</code></pre>
<p><strong>Swap Monitors:</strong></p>
<pre><code class="language-bash"># Swap positions of monitors
bspc monitor -s MONITOR_SEL

# Swap with east monitor
bspc monitor -s east

# Sxhkd:
super + shift + m
    bspc monitor -s next
</code></pre>
<h3 id="c-monitor-specific-configuration"><a class="header" href="#c-monitor-specific-configuration">C. Monitor-Specific Configuration</a></h3>
<pre><code class="language-bash"># Set padding per monitor
bspc config -m MONITOR top_padding 20

# Set for specific monitor
bspc config -m primary top_padding 20

# Window gap per monitor
bspc config -m eDP1 window_gap 10
</code></pre>
<h2 id="xi-query-operations-inspecting-the-window-tree"><a class="header" href="#xi-query-operations-inspecting-the-window-tree">XI. Query Operations: Inspecting the Window Tree</a></h2>
<p>The <code>query</code> domain allows you to inspect and extract information about the window tree.</p>
<h3 id="a-querying-nodes"><a class="header" href="#a-querying-nodes">A. Querying Nodes</a></h3>
<p><strong>Query Nodes:</strong></p>
<pre><code class="language-bash"># List node IDs matching selector
bspc query -N -n SELECTOR

# Get focused window ID
bspc query -N -n focused

# Get all tiled windows
bspc query -N -n .tiled

# Get all windows on current desktop
bspc query -N -d focused

# Use in scripts:
FOCUSED_ID=$(bspc query -N -n focused)
echo "Focused window ID: $FOCUSED_ID"

# Get multiple nodes:
for node in $(bspc query -N -n .floating); do
    echo "Floating window: $node"
done
</code></pre>
<h3 id="b-querying-desktops"><a class="header" href="#b-querying-desktops">B. Querying Desktops</a></h3>
<p><strong>Query Desktops:</strong></p>
<pre><code class="language-bash"># List desktop names
bspc query -D --names

# List desktop IDs
bspc query -D

# Get occupied desktops
bspc query -D -d .occupied

# Get empty desktops
bspc query -D -d .!occupied

# Get urgent desktops
bspc query -D -d .urgent

# Script example:
EMPTY_DESK=$(bspc query -D -d .!occupied | head -1)
echo "First empty desktop: $EMPTY_DESK"
</code></pre>
<h3 id="c-querying-monitors"><a class="header" href="#c-querying-monitors">C. Querying Monitors</a></h3>
<p><strong>Query Monitors:</strong></p>
<pre><code class="language-bash"># List monitor names
bspc query -M --names

# List monitor IDs
bspc query -M

# Get focused monitor
bspc query -M -m focused --names

# Get all monitors
for monitor in $(bspc query -M); do
    echo "Monitor: $monitor"
done
</code></pre>
<h3 id="d-tree-visualization"><a class="header" href="#d-tree-visualization">D. Tree Visualization</a></h3>
<p><strong>Query Tree:</strong></p>
<pre><code class="language-bash"># Print entire tree as JSON
bspc query -T

# Query desktop tree
bspc query -T -d focused

# Query node subtree
bspc query -T -n focused

# Pretty print with jq:
bspc query -T -d focused | jq .

# Extract specific info:
bspc query -T | jq '..[].id'  # All node IDs
bspc query -T | jq '..[].client.class'  # All window classes
</code></pre>
<h2 id="xii-window-rules-automatic-window-configuration"><a class="header" href="#xii-window-rules-automatic-window-configuration">XII. Window Rules: Automatic Window Configuration</a></h2>
<p>Rules apply automatic configurations to windows based on matching criteria.</p>
<h3 id="a-built-in-rules"><a class="header" href="#a-built-in-rules">A. Built-in Rules</a></h3>
<p><strong>Basic Rule Syntax:</strong></p>
<pre><code class="language-bash">bspc rule -a CLASS[:INSTANCE[:NAME]] [options]

# Options:
# State: state=STATE (tiled|pseudo_tiled|floating|fullscreen)
# Desktop: desktop=DESKTOP_SEL
# Monitor: monitor=MONITOR_SEL
# Flags: hidden=on|off, sticky=on|off, private=on|off, locked=on|off, marked=on|off
# Layer: layer=LAYER (below|normal|above)
# Splitting: split_dir=DIR, split_ratio=RATIO
# Size hints: honor_size_hints=true|false|tiled|floating
# Layout: rectangle=WxH+X+Y (for floating windows)
# Other: center=on|off, follow=on|off, manage=on|off, focus=on|off, border=on|off

# One-shot: -o|--one-shot (applies only once)
</code></pre>
<h3 id="b-creating-rules"><a class="header" href="#b-creating-rules">B. Creating Rules</a></h3>
<p><strong>Common Rule Examples:</strong></p>
<pre><code class="language-bash"># Firefox always opens on desktop 2
bspc rule -a Firefox desktop=^2

# GIMP tools floating, sticky
bspc rule -a Gimp -t floating -g sticky=on

# Media player fullscreen
bspc rule -a vlc -t fullscreen

# Dialog windows floating
bspc rule -a '*' -t floating -o  # One-shot for unmatched dialogs

# Locked terminal
bspc rule -a Termite -g locked=on

# Application on specific monitor
bspc rule -a Firefox monitor=HDMI-1

# Combination rule
bspc rule -a libreoffice \
    -t pseudo_tiled \
    desktop=^3 \
    -g sticky=on \
    split_ratio=0.7

# Multiple class selectors
bspc rule -a {Firefox,Chrome} desktop=^2
</code></pre>
<h3 id="c-matching-patterns"><a class="header" href="#c-matching-patterns">C. Matching Patterns</a></h3>
<p><strong>Class Matching:</strong></p>
<pre><code class="language-bash"># Exact class match
bspc rule -a Firefox state=floating

# Class and instance
bspc rule -a Firefox:Preferences state=floating

# Class, instance, and name
bspc rule -a "VLC:vlc::*" state=floating

# Wildcard patterns
bspc rule -a "*" state=floating -o  # Fallback rule
bspc rule -a "* notification*" state=floating layer=above

# Negation
bspc rule -a Firefox -r  # Remove Firefox rules
</code></pre>
<h3 id="d-list-and-manage-rules"><a class="header" href="#d-list-and-manage-rules">D. List and Manage Rules</a></h3>
<p><strong>Rule Management:</strong></p>
<pre><code class="language-bash"># List all rules
bspc rule -l

# List rules numbered
bspc rule -l | cat -n

# Remove rule by pattern
bspc rule -r Firefox

# Remove rule by number
bspc rule -r ^3

# Remove all rules
bspc rule -r '*'

# Remove specific rules
bspc rule -r Firefox Chromium
</code></pre>
<h3 id="e-external-rules-command"><a class="header" href="#e-external-rules-command">E. External Rules Command</a></h3>
<p>For more complex rules, use an external script:</p>
<pre><code class="language-bash"># Configure external rules
bspc config external_rules_command ~/.config/bspwm/external_rules

# Script receives: WID CLASS INSTANCE [INTERMEDIATE_RULES]
# Output format: key1=value1 key2=value2 ...

# Example external_rules script:
#!/bin/bash

wid=$1
class=$2
instance=$3

# Get window geometry with xdotool
geometry=$(xdotool getwindowgeometry "$wid" | awk '/Geometry/ {print $2}')

# Custom logic
if [[ "$class" == "Firefox" ]]; then
    echo "desktop=^2"
elif [[ "$geometry" == "1920x1080"* ]]; then
    # Large window - make floating
    echo "state=floating"
fi

# Can be very complex:
if xdotool getwindowname "$wid" | grep -q "Settings"; then
    echo "state=floating layer=above center=on"
fi

# Make executable:
chmod +x ~/.config/bspwm/external_rules
</code></pre>
<h2 id="xiii-events-and-subscriptions-reactive-programming-with-bspwm"><a class="header" href="#xiii-events-and-subscriptions-reactive-programming-with-bspwm">XIII. Events and Subscriptions: Reactive Programming with BSPWM</a></h2>
<p>BSPWM generates comprehensive events for every state change, enabling real-time monitoring and scripting.</p>
<h3 id="a-event-types"><a class="header" href="#a-event-types">A. Event Types</a></h3>
<p><strong>Available Events:</strong></p>
<pre><code>Monitor Events:
- monitor_add &lt;monitor_id&gt; &lt;name&gt; &lt;geometry&gt;
- monitor_remove &lt;monitor_id&gt;
- monitor_swap &lt;src_monitor_id&gt; &lt;dst_monitor_id&gt;
- monitor_focus &lt;monitor_id&gt;
- monitor_geometry &lt;monitor_id&gt; &lt;geometry&gt;
- monitor_rename &lt;monitor_id&gt; &lt;old_name&gt; &lt;new_name&gt;

Desktop Events:
- desktop_add &lt;monitor_id&gt; &lt;desktop_id&gt; &lt;name&gt;
- desktop_remove &lt;monitor_id&gt; &lt;desktop_id&gt;
- desktop_swap &lt;src_monitor_id&gt; &lt;src_desktop_id&gt; &lt;dst_monitor_id&gt; &lt;dst_desktop_id&gt;
- desktop_transfer &lt;src_monitor_id&gt; &lt;src_desktop_id&gt; &lt;dst_monitor_id&gt;
- desktop_focus &lt;monitor_id&gt; &lt;desktop_id&gt;
- desktop_activate &lt;monitor_id&gt; &lt;desktop_id&gt;
- desktop_layout &lt;monitor_id&gt; &lt;desktop_id&gt; &lt;layout&gt;
- desktop_rename &lt;monitor_id&gt; &lt;desktop_id&gt; &lt;old_name&gt; &lt;new_name&gt;

Node Events:
- node_add &lt;monitor_id&gt; &lt;desktop_id&gt; &lt;ip_id&gt; &lt;node_id&gt;
- node_remove &lt;monitor_id&gt; &lt;desktop_id&gt; &lt;node_id&gt;
- node_swap &lt;src_monitor_id&gt; &lt;src_desktop_id&gt; &lt;src_node_id&gt; &lt;dst_monitor_id&gt; &lt;dst_desktop_id&gt; &lt;dst_node_id&gt;
- node_transfer &lt;src_monitor_id&gt; &lt;src_desktop_id&gt; &lt;src_node_id&gt; &lt;dst_monitor_id&gt; &lt;dst_desktop_id&gt; &lt;dst_node_id&gt;
- node_focus &lt;monitor_id&gt; &lt;desktop_id&gt; &lt;node_id&gt;
- node_activate &lt;monitor_id&gt; &lt;desktop_id&gt; &lt;node_id&gt;
- node_presel &lt;monitor_id&gt; &lt;desktop_id&gt; &lt;node_id&gt; (dir DIR|ratio RATIO|cancel)
- node_stack &lt;node_id_1&gt; (below|above) &lt;node_id_2&gt;
- node_geometry &lt;monitor_id&gt; &lt;desktop_id&gt; &lt;node_id&gt; &lt;geometry&gt;
- node_state &lt;monitor_id&gt; &lt;desktop_id&gt; &lt;node_id&gt; &lt;state&gt; (on|off)
- node_flag &lt;monitor_id&gt; &lt;desktop_id&gt; &lt;node_id&gt; &lt;flag&gt; (on|off)
- node_layer &lt;monitor_id&gt; &lt;desktop_id&gt; &lt;node_id&gt; &lt;layer&gt;
- pointer_action &lt;monitor_id&gt; &lt;desktop_id&gt; &lt;node_id&gt; &lt;action&gt; (begin|end)
</code></pre>
<h3 id="b-subscribing-to-events"><a class="header" href="#b-subscribing-to-events">B. Subscribing to Events</a></h3>
<p><strong>Basic Subscribe:</strong></p>
<pre><code class="language-bash"># Subscribe to specific event type
bspc subscribe node_add | while read -a msg; do
    # msg array contains: monitor_id desktop_id ip_id node_id
    node_id="${msg[^1_4]}"
    echo "New node added: $node_id"
    # Perform action
done

# Subscribe to multiple event types
bspc subscribe node_add node_remove | while read -a msg; do
    event_type="${msg[^1_0]}"
    case "$event_type" in
        node_add)
            echo "Node added"
            ;;
        node_remove)
            echo "Node removed"
            ;;
    esac
done

# Subscribe to all events
bspc subscribe all | while read line; do
    echo "$line"
done
</code></pre>
<h3 id="c-practical-event-scripts"><a class="header" href="#c-practical-event-scripts">C. Practical Event Scripts</a></h3>
<p><strong>Example 1: Auto-fullscreen New Windows:</strong></p>
<pre><code class="language-bash">#!/bin/bash
# Make every new window fullscreen automatically

bspc subscribe node_add | while read -a msg; do
    monitor_id="${msg[^1_1]}"
    desktop_id="${msg[^1_2]}"
    node_id="${msg[^1_4]}"
    
    # Auto-fullscreen
    bspc node "$node_id" -t fullscreen
done
</code></pre>
<p><strong>Example 2: Auto-floating by Window Class:</strong></p>
<pre><code class="language-bash">#!/bin/bash
# Make certain applications floating automatically

FLOATING_APPS=("mpv" "VLC" "Zathura")

bspc subscribe node_add | while read -a msg; do
    node_id="${msg[^1_4]}"
    
    # Get window class (requires extra lookup)
    class=$(xdotool getactivewindow getwindowname 2&gt;/dev/null || echo "")
    
    for app in "${FLOATING_APPS[@]}"; do
        if [[ "$class" == *"$app"* ]]; then
            bspc node "$node_id" -t floating
            break
        fi
    done
done
</code></pre>
<p><strong>Example 3: Status Bar Integration:</strong></p>
<pre><code class="language-bash">#!/bin/bash
# Update polybar on window events

bspc subscribe node_focus desktop_focus | while read -a msg; do
    # Update status bar
    pkill -SIGUSR1 polybar
    
    # Or update custom status
    echo "$(date): $(bspc query -N -n focused)" &gt; /tmp/bspwm_status
done
</code></pre>
<p><strong>Example 4: Sticky Window Management:</strong></p>
<pre><code class="language-bash">#!/bin/bash
# Automatically make certain windows sticky

bspc subscribe node_add node_focus | while read -a msg; do
    node_id="${msg[^1_4]}"
    
    # Make all floating windows sticky automatically
    state=$(bspc query -N -n "$node_id" -T | jq -r '.client.state')
    
    if [[ "$state" == "floating" ]]; then
        bspc node "$node_id" -g sticky=on
    fi
done
</code></pre>
<h3 id="d-using-fifo-for-event-processing"><a class="header" href="#d-using-fifo-for-event-processing">D. Using FIFO for Event Processing</a></h3>
<p>Alternative method using named pipes:</p>
<pre><code class="language-bash"># Get FIFO path
FIFO_PATH=$(bspc --print-socket-path)

# Create monitoring script
#!/bin/bash
bspc subscribe -f | nc -l localhost 5000 &amp;

# In another terminal, connect:
nc localhost 5000 | while read event; do
    echo "$event"
done
</code></pre>
<h2 id="xiv-configuration-settings-customizing-bspwm-behavior"><a class="header" href="#xiv-configuration-settings-customizing-bspwm-behavior">XIV. Configuration Settings: Customizing BSPWM Behavior</a></h2>
<p>BSPWM provides numerous settings to customize appearance and behavior.</p>
<h3 id="a-global-settings"><a class="header" href="#a-global-settings">A. Global Settings</a></h3>
<p><strong>Color Settings:</strong></p>
<pre><code class="language-bash"># Set border colors (in hex #RRGGBB)
bspc config normal_border_color "#484848"           # Unfocused, unfocused monitor
bspc config focused_border_color "#1F8999"          # Focused, focused monitor
bspc config active_border_color "#CCCCCC"           # Focused, unfocused monitor
bspc config presel_feedback_color "#7C7C7C"         # Preselection area

# Practical configuration:
bspc config normal_border_color "#3c3836"
bspc config focused_border_color "#d79921"
bspc config active_border_color "#a89984"
bspc config presel_feedback_color "#458588"

# Test colors in terminal:
bspc config normal_border_color "#FF0000"  # Test red
# Changes apply immediately to new windows
</code></pre>
<p><strong>Dimension Settings:</strong></p>
<pre><code class="language-bash"># Border width
bspc config border_width 2              # 0-10 pixels

# Window gap (space between windows)
bspc config window_gap 10               # Default: 12

# Padding (space from screen edge)
bspc config top_padding 20
bspc config bottom_padding 0
bspc config left_padding 0
bspc config right_padding 0

# Combined padding:
for side in top right bottom left; do
    bspc config "${side}_padding" 20
done

# Per-monitor padding:
bspc config -m HDMI-1 top_padding 30
</code></pre>
<p><strong>Insertion and Splitting:</strong></p>
<pre><code class="language-bash"># Default split ratio
bspc config split_ratio 0.5            # 0 &lt; ratio &lt; 1

# Automatic insertion scheme
bspc config automatic_scheme alternate  # or longest_side

# Initial attachment direction
bspc config initial_polarity first_child  # or second_child

# Directional focus strictness
bspc config directional_focus_tightness high  # or low

# Removal behavior
bspc config removal_adjustment true
</code></pre>
<p><strong>Layout Options:</strong></p>
<pre><code class="language-bash"># Monocle-specific settings
bspc config borderless_monocle true     # Remove borders in monocle
bspc config gapless_monocle true        # Remove gaps in monocle

# Monocle padding
bspc config top_monocle_padding 20
bspc config bottom_monocle_padding 0
bspc config left_monocle_padding 0
bspc config right_monocle_padding 0

# Single window behavior
bspc config single_monocle false        # Switch to monocle with 1 window

# Singleton settings
bspc config borderless_singleton true   # Remove border on single window
</code></pre>
<h3 id="b-focus-and-click-behavior"><a class="header" href="#b-focus-and-click-behavior">B. Focus and Click Behavior</a></h3>
<pre><code class="language-bash"># Focus follows mouse pointer
bspc config focus_follows_pointer true

# Mouse moves to focused window
bspc config pointer_follows_focus false

# Mouse moves when focus changes to different monitor
bspc config pointer_follows_monitor false

# Click button to focus
bspc config click_to_focus button1     # button1, button2, button3, any, none

# Don't replay click that gave focus
bspc config swallow_first_click true
</code></pre>
<h3 id="c-pointer-and-mouse-settings"><a class="header" href="#c-pointer-and-mouse-settings">C. Pointer and Mouse Settings</a></h3>
<pre><code class="language-bash"># Pointer movement interval (milliseconds)
bspc config pointer_motion_interval 10  # Minimum between motion events

# Modifier key for pointer actions (Alt=mod1, Super=mod4, etc.)
bspc config pointer_modifier mod4

# Pointer actions (button 1, 2, 3)
bspc config pointer_action1 move        # Super+button1: move window
bspc config pointer_action2 resize_side # Super+button2: resize side
bspc config pointer_action3 resize_corner  # Super+button3: resize corner

# Possible values: move, resize_side, resize_corner, focus, none

# Example for alternative bindings:
bspc config pointer_modifier mod1       # Alt instead of Super
bspc config pointer_action1 focus       # Just focus, don't move
bspc config pointer_action2 move
bspc config pointer_action3 resize_corner
</code></pre>
<h3 id="d-ewmh-and-compatibility-settings"><a class="header" href="#d-ewmh-and-compatibility-settings">D. EWMH and Compatibility Settings</a></h3>
<pre><code class="language-bash"># Ignore EWMH focus requests from applications
bspc config ignore_ewmh_focus true

# Ignore EWMH fullscreen requests
bspc config ignore_ewmh_fullscreen none    # none, all, or: enter,exit

# Ignore window struts (panel reservations)
bspc config ignore_ewmh_struts false

# Example: allow fullscreen but not fullscreen changes
bspc config ignore_ewmh_fullscreen "exit"  # Ignore exit, allow enter

# Pseudo-tiled centering
bspc config center_pseudo_tiled true
</code></pre>
<h3 id="e-monitor-management"><a class="header" href="#e-monitor-management">E. Monitor Management</a></h3>
<pre><code class="language-bash"># Remove disabled monitors
bspc config remove_disabled_monitors false

# Remove unplugged monitors
bspc config remove_unplugged_monitors true

# Merge overlapping monitors
bspc config merge_overlapping_monitors true

# Mapping events to handle
bspc config mapping_events_count -1     # -1 = all events
</code></pre>
<h3 id="f-history-recording"><a class="header" href="#f-history-recording">F. History Recording</a></h3>
<pre><code class="language-bash"># Record focus history
bspc config record_history true

# Use in scripts:
bspc wm -h on    # Enable history recording
bspc node older -f  # Focus previously focused
bspc wm -h off   # Disable history
</code></pre>
<h3 id="g-size-hints"><a class="header" href="#g-size-hints">G. Size Hints</a></h3>
<pre><code class="language-bash"># Honor window size hints (ICCCM hints)
bspc config honor_size_hints false

# Options:
# false: ignore all hints
# true: apply to all windows
# tiled: apply only to tiled windows
# floating: apply only to floating windows
# floating|tiled: apply to both

# Example:
bspc config honor_size_hints floating   # Dialogs respect requested size
</code></pre>
<h3 id="h-practical-configuration-file-example"><a class="header" href="#h-practical-configuration-file-example">H. Practical Configuration File Example</a></h3>
<pre><code class="language-bash">#!/bin/bash
# ~/.config/bspwm/bspwmrc

# Monitor setup
bspc monitor -d I II III IV V VI VII VIII IX X

# Appearance
bspc config border_width 2
bspc config window_gap 10
bspc config split_ratio 0.5

bspc config normal_border_color "#3c3836"
bspc config focused_border_color "#d79921"
bspc config active_border_color "#a89984"

# Layout
bspc config borderless_monocle false
bspc config gapless_monocle false

# Behavior
bspc config automatic_scheme alternate
bspc config split_ratio 0.5
bspc config focus_follows_pointer true

# Rules
bspc rule -a Firefox desktop=^2
bspc rule -a Gimp state=floating sticky=on
bspc rule -a mpv state=floating

# Start additional daemons
sxhkd &amp;
polybar main &amp;
</code></pre>
<h2 id="xv-query-and-world-state-management"><a class="header" href="#xv-query-and-world-state-management">XV. Query and World State Management</a></h2>
<p>Advanced commands for inspecting and managing BSPWM’s global state.</p>
<h3 id="a-dumping-and-loading-state"><a class="header" href="#a-dumping-and-loading-state">A. Dumping and Loading State</a></h3>
<p><strong>Dump State:</strong></p>
<pre><code class="language-bash"># Get current state as JSON
bspc wm -d &gt; state.json

# This includes:
# - Monitor configuration
# - Desktop hierarchy
# - Window tree structure
# - Focus history
# - All settings

# Inspect structure:
bspc wm -d | jq '.' | less
</code></pre>
<p><strong>Load State:</strong></p>
<pre><code class="language-bash"># Restore state from file
bspc wm -l /path/to/state.json

# Requires absolute path
bspc wm -l ~/.config/bspwm/layouts/default.json

# Used internally for restart:
bspc wm -r  # Dumps state, restarts, loads state
</code></pre>
<h3 id="b-report-format"><a class="header" href="#b-report-format">B. Report Format</a></h3>
<p><strong>Status Messages:</strong></p>
<pre><code class="language-bash"># Get current status
bspc wm -g

# Returns format: M&lt;name&gt;:O&lt;name&gt;:F&lt;name&gt;:...

# Report format codes:
# M&lt;name&gt;    - Focused monitor
# m&lt;name&gt;    - Unfocused monitor
# O&lt;name&gt;    - Occupied focused desktop
# o&lt;name&gt;    - Occupied unfocused desktop
# F&lt;name&gt;    - Free focused desktop
# f&lt;name&gt;    - Free unfocused desktop
# U&lt;name&gt;    - Urgent focused desktop
# u&lt;name&gt;    - Urgent unfocused desktop
# L&lt;T|M&gt;     - Layout (T=tiled, M=monocle)
# T&lt;T|P|F|=|@&gt;  - Node state (T=tiled, P=pseudo-tiled, F=floating, ==fullscreen, @=manual)
# G&lt;flags&gt;   - Flags

# Example script to parse:
#!/bin/bash
bspc wm -g | while IFS=: read -ra items; do
    for item in "${items[@]}"; do
        type="${item:0:1}"
        value="${item:1}"
        
        case "$type" in
            M) echo "Focused monitor: $value" ;;
            O) echo "Occupied desktop: $value" ;;
            L) echo "Layout: $value" ;;
        esac
    done
done
</code></pre>
<h3 id="c-world-state-operations"><a class="header" href="#c-world-state-operations">C. World State Operations</a></h3>
<p><strong>Restart BSPWM:</strong></p>
<pre><code class="language-bash"># Restart, preserving all state
bspc wm -r

# Equivalent to:
# 1. Dump state
# 2. Kill bspwm
# 3. Restart bspwm
# 4. Load state

# Sxhkd binding:
super + alt + r
    bspc wm -r
</code></pre>
<p><strong>Adopt Orphans:</strong></p>
<pre><code class="language-bash"># Manage windows from previous session
bspc wm -o

# If X session crashed, windows still exist
# This command brings them under BSPWM management
</code></pre>
<h2 id="xvi-practical-sxhkd-configuration-for-bspwm"><a class="header" href="#xvi-practical-sxhkd-configuration-for-bspwm">XVI. Practical Sxhkd Configuration for BSPWM</a></h2>
<p>A complete, real-world sxhkd configuration demonstrating all major bindings.</p>
<h3 id="a-complete-sxhkd-configuration-example"><a class="header" href="#a-complete-sxhkd-configuration-example">A. Complete Sxhkd Configuration Example</a></h3>
<pre><code class="language-bash">#!/bin/bash
# ~/.config/sxhkd/sxhkdrc

# Application launching
super + Return
    kitty

super + d
    rofi -show drun

super + slash
    sxhkd-help

# WM control
super + alt + {q,r}
    bspc {quit,wm -r}

# Window state
super + {t,shift+t,s,f}
    bspc node -t {tiled,pseudo_tiled,floating,fullscreen}

# Window flags
super + ctrl + {m,x,y,z}
    bspc node -g {marked,locked,sticky,private}

# Focus operations
super + {h,j,k,l}
    bspc node -f {west,south,north,east}

super + {comma,period}
    bspc node -f {prev,next}.local.!hidden.window

super + shift + {h,j,k,l}
    bspc node -s {west,south,north,east}

super + g
    bspc node -s biggest.window

# Desktop navigation
super + {1-9,0}
    bspc desktop -f '^{1-9,10}'

super + bracket{left,right}
    bspc desktop -f {prev,next}.local

super + shift + {1-9,0}
    bspc node -d '^{1-9,10}' --follow

# Preselection (manual splitting)
super + ctrl + {h,j,k,l}
    bspc node -p {west,south,north,east}

super + ctrl + space
    bspc node -p cancel

super + ctrl + {minus,equal}
    bspc config split_ratio $(bspc config split_ratio){-,+}$(echo 0.05)

# Floating window management
super + shift + {Left,Down,Up,Right}
    bspc node -v {-20 0,0 20,0 -20,20 0}

super + alt + {h,j,k,l}
    bspc node -z {left -20 0,bottom 0 20,top 0 -20,right 20 0}

# Tree manipulation
super + {comma,period}
    bspc node @focused -R {90,-90}

super + {slash,backslash}
    bspc node @focused -F {horizontal,vertical}

super + shift + c
    bspc node -C forward

super + shift + e
    bspc node -E

super + b
    bspc node @focused -B

# Closing windows
super + shift + w
    bspc node -c

super + shift + q
    bspc node -k

# Monitor operations
super + shift + m
    bspc node -m next --follow

super + shift + {Left,Right}
    bspc monitor -f {west,east}

# Layout control
super + m
    bspc desktop -l next

# Scratchpad/hidden window
super + shift + space
    bash ~/.config/bspwm/toggle_scratchpad.sh
</code></pre>
<h3 id="b-advanced-sxhkd-patterns"><a class="header" href="#b-advanced-sxhkd-patterns">B. Advanced Sxhkd Patterns</a></h3>
<p><strong>Resize Mode:</strong></p>
<pre><code class="language-bash"># Enter resize mode with Super+E, then use hjkl
super + e : {h,j,k,l}
    bspc node -z {left -20 0,bottom 0 20,top 0 -20,right 20 0}

super + e : shift + {h,j,k,l}
    bspc node -z {right -20 0,top 0 20,bottom 0 -20,left 20 0}

# Exit with Escape key (default)
</code></pre>
<p><strong>Multi-key Sequences:</strong></p>
<pre><code class="language-bash"># Super+P enters preselect mode
super + p : {h,j,k,l}
    bspc node -p {west,south,north,east}

super + p : shift + {h,j,k,l}
    bspc node -p {east,north,south,west}

super + p : c
    bspc node -p cancel

super + p : space
    bspc node -p cancel
</code></pre>
<p><strong>Workspace Management:</strong></p>
<pre><code class="language-bash"># Super+W enters workspace mode
super + w : {1-9,0}
    bspc desktop -f '^{1-9,10}'

super + w : shift + {1-9,0}
    bspc node -d '^{1-9,10}' --follow

super + w : {Left,Right}
    bspc desktop -f {prev,next}.local
</code></pre>
<h2 id="xvii-real-world-usage-scenarios"><a class="header" href="#xvii-real-world-usage-scenarios">XVII. Real-World Usage Scenarios</a></h2>
<h3 id="a-setting-up-a-developer-workflow"><a class="header" href="#a-setting-up-a-developer-workflow">A. Setting Up a Developer Workflow</a></h3>
<pre><code class="language-bash">#!/bin/bash
# ~/.config/bspwm/setup_dev.sh

# Create desktop setup
bspc desktop ^1 -n code
bspc desktop ^2 -n terminal
bspc desktop ^3 -n browser
bspc desktop ^4 -n reference

# Rule for always-open applications
bspc rule -a Zathura desktop=^4 state=floating

# Code desktop layout (2 columns)
bspc desktop code -l tiled
bspc config -d code window_gap 15

# Terminal desktop (single window)
bspc desktop terminal -l monocle
bspc config -d terminal borderless_monocle true

# Browser floating on specific desktop
bspc rule -a Firefox desktop=^3 --follow

# Always open terminal on terminal desktop
bspc rule -a kitty desktop=^2
</code></pre>
<h3 id="b-multi-monitor-setup"><a class="header" href="#b-multi-monitor-setup">B. Multi-Monitor Setup</a></h3>
<pre><code class="language-bash">#!/bin/bash
# ~/.config/bspwm/bspwmrc

# Get monitor names
PRIMARY=$(xrandr -q | grep " connected" | head -1 | awk '{print $1}')
SECONDARY=$(xrandr -q | grep " connected" | tail -1 | awk '{print $1}')

# Configure primary monitor
bspc monitor "$PRIMARY" -d I II III IV V

# Configure secondary monitor
if [[ -n "$SECONDARY" ]]; then
    bspc monitor "$SECONDARY" -d VI VII VIII IX X
fi

# Set padding per monitor
bspc config -m "$PRIMARY" top_padding 30
bspc config -m "$SECONDARY" top_padding 30

# Move specific apps to secondary
bspc rule -a "VLC" -m "$SECONDARY"
</code></pre>
<h3 id="c-gaming-setup"><a class="header" href="#c-gaming-setup">C. Gaming Setup</a></h3>
<pre><code class="language-bash">#!/bin/bash
# Create gaming desktop

# Separate desktop for games
bspc desktop ^9 -n gaming

# Games go fullscreen on dedicated desktop
bspc rule -a "Steam" desktop=^9 state=floating follow=on
bspc rule -a "wine" desktop=^9 state=fullscreen
bspc rule -a ".*Game.*" state=fullscreen

# Disable window gaps for games
bspc config -d gaming window_gap 0

# Disable borders for games
bspc config -d gaming border_width 0

# Sxhkd binding to switch to gaming desktop
super + alt + g
    bspc desktop -f ^9
</code></pre>
<h3 id="d-productivity-mode"><a class="header" href="#d-productivity-mode">D. Productivity Mode</a></h3>
<pre><code class="language-bash">#!/bin/bash
# Simplified, distraction-free setup

# Single application per desktop
bspc config focus_follows_pointer false
bspc config split_ratio 0.5

# Balanced window gaps
bspc config window_gap 8
bspc config border_width 1

# Monocle for focus
bspc rule -a "Writer" desktop=^1 state=monocle
bspc rule -a "code-oss" desktop=^2 state=monocle
bspc rule -a "Firefox" desktop=^3 state=monocle

# Sxhkd bind to toggle distraction-free mode
super + alt + f
    bash ~/.config/bspwm/toggle_focus_mode.sh
</code></pre>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<ul>
<li>
<p>BSPWM represents a paradigm shift in window management philosophy, moving from direct graphical manipulation to declarative, keyboard-driven tree manipulation. Its strength lies in the separation of concerns: the window manager handles the tree logic, <code>bspc</code> provides the control interface, and <code>sxhkd</code> handles keyboard bindings. This architecture enables extraordinary flexibility and customization.</p>
</li>
<li>
<p>The binary space partitioning algorithm ensures that screen real estate is always optimally allocated, with no wasted space or overlapping windows in tiled mode. The rich selector syntax allows targeting any window configuration with surgical precision. Advanced features like receptacles, preselection, flags, and event subscriptions enable sophisticated window management workflows that would be difficult or impossible in traditional window managers.</p>
</li>
<li>
<p>Whether you’re a developer seeking efficient workspace management, a power user who wants complete control over your desktop environment, or someone simply tired of mouse-driven window management, BSPWM provides the tools and flexibility to create a window management system tailored exactly to your needs. The learning curve is steep, but the rewards in productivity and customization justify the investment.</p>
</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../ch4/Writing-Configs.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M41.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.3 256 246.6 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-160 160z"/></svg></span>
                            </a>


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../ch4/Writing-Configs.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M41.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.3 256 246.6 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-160 160z"/></svg></span>
                    </a>

            </nav>

        </div>

        <template id=fa-eye><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M288 32c-80.8 0-145.5 36.8-192.6 80.6C48.6 156 17.3 208 2.5 243.7c-3.3 7.9-3.3 16.7 0 24.6C17.3 304 48.6 356 95.4 399.4C142.5 443.2 207.2 480 288 480s145.5-36.8 192.6-80.6c46.8-43.5 78.1-95.4 93-131.1c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C433.5 68.8 368.8 32 288 32zM432 256c0 79.5-64.5 144-144 144s-144-64.5-144-144s64.5-144 144-144s144 64.5 144 144zM288 192c0 35.3-28.7 64-64 64c-11.5 0-22.3-3-31.6-8.4c-.2 2.8-.4 5.5-.4 8.4c0 53 43 96 96 96s96-43 96-96s-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6z"/></svg></span></template>
        <template id=fa-eye-slash><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M38.8 5.1C28.4-3.1 13.3-1.2 5.1 9.2S-1.2 34.7 9.2 42.9l592 464c10.4 8.2 25.5 6.3 33.7-4.1s6.3-25.5-4.1-33.7L525.6 386.7c39.6-40.6 66.4-86.1 79.9-118.4c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C465.5 68.8 400.8 32 320 32c-68.2 0-125 26.3-169.3 60.8L38.8 5.1zM223.1 149.5C248.6 126.2 282.7 112 320 112c79.5 0 144 64.5 144 144c0 24.9-6.3 48.3-17.4 68.7L408 294.5c5.2-11.8 8-24.8 8-38.5c0-53-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6c0 10.2-2.4 19.8-6.6 28.3l-90.3-70.8zm223.1 298L373 389.9c-16.4 6.5-34.3 10.1-53 10.1c-79.5 0-144-64.5-144-144c0-6.9 .5-13.6 1.4-20.2L83.1 161.5C60.3 191.2 44 220.8 34.5 243.7c-3.3 7.9-3.3 16.7 0 24.6c14.9 35.7 46.2 87.7 93 131.1C174.5 443.2 239.2 480 320 480c47.8 0 89.9-12.9 126.2-32.5z"/></svg></span></template>
        <template id=fa-copy><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M502.6 70.63l-61.25-61.25C435.4 3.371 427.2 0 418.7 0H255.1c-35.35 0-64 28.66-64 64l.0195 256C192 355.4 220.7 384 256 384h192c35.2 0 64-28.8 64-64V93.25C512 84.77 508.6 76.63 502.6 70.63zM464 320c0 8.836-7.164 16-16 16H255.1c-8.838 0-16-7.164-16-16L239.1 64.13c0-8.836 7.164-16 16-16h128L384 96c0 17.67 14.33 32 32 32h47.1V320zM272 448c0 8.836-7.164 16-16 16H63.1c-8.838 0-16-7.164-16-16L47.98 192.1c0-8.836 7.164-16 16-16H160V128H63.99c-35.35 0-64 28.65-64 64l.0098 256C.002 483.3 28.66 512 64 512h192c35.2 0 64-28.8 64-64v-32h-47.1L272 448z"/></svg></span></template>
        <template id=fa-play><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M73 39c-14.8-9.1-33.4-9.4-48.5-.9S0 62.6 0 80V432c0 17.4 9.4 33.4 24.5 41.9s33.7 8.1 48.5-.9L361 297c14.3-8.7 23-24.2 23-41s-8.7-32.2-23-41L73 39z"/></svg></span></template>
        <template id=fa-clock-rotate-left><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M75 75L41 41C25.9 25.9 0 36.6 0 57.9V168c0 13.3 10.7 24 24 24H134.1c21.4 0 32.1-25.9 17-41l-30.8-30.8C155 85.5 203 64 256 64c106 0 192 86 192 192s-86 192-192 192c-40.8 0-78.6-12.7-109.7-34.4c-14.5-10.1-34.4-6.6-44.6 7.9s-6.6 34.4 7.9 44.6C151.2 495 201.7 512 256 512c141.4 0 256-114.6 256-256S397.4 0 256 0C185.3 0 121.3 28.7 75 75zm181 53c-13.3 0-24 10.7-24 24V256c0 6.4 2.5 12.5 7 17l72 72c9.4 9.4 24.6 9.4 33.9 0s9.4-24.6 0-33.9l-65-65V152c0-13.3-10.7-24-24-24z"/></svg></span></template>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr-ef4e11c1.min.js"></script>
        <script src="../mark-09e88c2c.min.js"></script>
        <script src="../searcher-c2a407aa.js"></script>

        <script src="../clipboard-1626706a.min.js"></script>
        <script src="../highlight-abc7f01d.js"></script>
        <script src="../book-a0b12cfe.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
